"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Report = void 0;
const path = require("path");
const fs = require("fs");
const log4js = require("log4js");
const html_1 = require("./html");
const coverage_1 = require("../coverage");
const logger = log4js.getLogger();
const Object2ArrayKeys = new Set(['functions', 'regions', 'branches', 'group']);
function calcRegionLine(exeLineArr, i, executedLineCount, region) {
    if (exeLineArr.indexOf(i) !== -1 && executedLineCount[i] !== -2) {
        if (region.ignored === coverage_1.IgnoreType.None) {
            executedLineCount[i] = region.count;
        }
        else {
            executedLineCount[i] = -2;
        }
    }
}
class Report {
    constructor(covFile) {
        this.covFile = covFile;
    }
    generateReport() {
        this.coverage = new coverage_1.CoverageReport();
        let coverageData = JSON.parse(fs.readFileSync(this.covFile, 'utf-8'), (key, value) => {
            // Object to Array
            if (Object2ArrayKeys.has(key)) {
                return Object.values(value);
            }
            return value;
        });
        for (const file of Object.values(coverageData)) {
            let fileData = file;
            if (!fileData.version) {
                continue;
            }
            if (fileData.summary == undefined) {
                fileData.summary = new coverage_1.Summary();
            }
            this.coverage.files.push(fileData);
        }
        // calculate the coverage
        this.calcFunctionCoverage();
        this.calcLineCoverage();
        this.calcBranchCoverage();
        // summy coverageMapData
        this.calculateSummary();
        return this.coverage;
    }
    writeReport(output) {
        if (!this.coverage) {
            this.generateReport();
        }
        this.output = output;
        if (output == undefined) {
            this.output = path.resolve('.bjc');
        }
        fs.mkdirSync(this.output, { recursive: true });
        this.writeJsonReport();
        this.writeHtmlReport();
    }
    calculateSummary() {
        var _a;
        (_a = this.coverage) === null || _a === void 0 ? void 0 : _a.summary.update();
    }
    calcFunctionCoverage() {
        for (const fileData of this.coverage.files) {
            if (!fileData.functions) {
                continue;
            }
            let totalFunctions = 0;
            let executedFunctions = 0;
            fileData.functions.forEach((functionItem) => {
                if (functionItem.ignored === coverage_1.IgnoreType.None) {
                    totalFunctions++;
                    if (functionItem.count > 0) {
                        executedFunctions++;
                    }
                }
            });
            fileData.summary.functions = new coverage_1.Coverage(totalFunctions, executedFunctions);
            this.coverage.summary.functions.total += totalFunctions;
            this.coverage.summary.functions.covered += executedFunctions;
        }
    }
    calcFileLineCoverage(file) {
        if (!file.exeLine) {
            return;
        }
        let executedLineCount = [];
        const exeLineArr = Object.values(file.exeLine);
        // start line 1
        for (let i = 0; i < file.lineCnt + 1; i++) {
            executedLineCount[i] = -1;
        }
        // set executed line count
        for (const func of file.functions) {
            func.regions.sort((a, b) => {
                return a.startLoc.line - a.endLoc.line - (b.startLoc.line - b.endLoc.line);
            });
            for (const region of func.regions) {
                for (let i = region.startLoc.line; i <= region.endLoc.line; i++) {
                    calcRegionLine(exeLineArr, i, executedLineCount, region);
                }
            }
            for (const branch of func.branches) {
                for (let i = branch.startLoc.line; i <= branch.endLoc.line; i++) {
                    if (executedLineCount[i] === -2) {
                        continue;
                    }
                    if (branch.ignored == coverage_1.IgnoreType.None || branch.ignored == coverage_1.IgnoreType.Else) {
                        executedLineCount[i] = branch.trueCount + branch.falseCount;
                    }
                    else if (branch.ignored == coverage_1.IgnoreType.If) {
                        executedLineCount[i] = branch.falseCount;
                    }
                    else {
                        executedLineCount[i] = -2;
                    }
                }
            }
        }
        let totalLines = 0;
        let executedLines = 0;
        // Count valid lines of code
        for (let cnt of executedLineCount) {
            if (cnt >= 0) {
                totalLines++;
            }
            if (cnt >= 1) {
                executedLines++;
            }
        }
        let lineCoverage = new coverage_1.Coverage(totalLines, executedLines);
        lineCoverage.executedLineCount = executedLineCount;
        file.summary.lines = lineCoverage;
        this.coverage.summary.lines.total += totalLines;
        this.coverage.summary.lines.covered += executedLines;
    }
    calcLineCoverage() {
        for (const fileData of this.coverage.files) {
            this.calcFileLineCoverage(fileData);
        }
    }
    calcBranchCoverage() {
        for (const fileData of this.coverage.files) {
            if (!fileData.functions) {
                continue;
            }
            let totalBranches = 0;
            let executedBranches = 0;
            fileData.functions.forEach((functionItem) => {
                if (functionItem.ignored !== coverage_1.IgnoreType.None) {
                    return;
                }
                functionItem.branches.forEach((currentBranch) => {
                    if (currentBranch.ignored == coverage_1.IgnoreType.Next) {
                        return;
                    }
                    else if (currentBranch.ignored == coverage_1.IgnoreType.If) {
                        if (currentBranch.group.length > 0) {
                            return;
                        }
                        else {
                            totalBranches++;
                            if (currentBranch.falseCount > 0) {
                                executedBranches += 1;
                            }
                        }
                    }
                    else if (currentBranch.ignored == coverage_1.IgnoreType.Else) {
                        if (currentBranch.group.length > 0) {
                            return;
                        }
                        else {
                            totalBranches++;
                            if (currentBranch.trueCount > 0) {
                                executedBranches += 1;
                            }
                        }
                    }
                    else if (currentBranch.ignored == coverage_1.IgnoreType.None) {
                        if (currentBranch.group.length > 0) {
                            totalBranches++;
                            if (currentBranch.trueCount > 0) {
                                executedBranches += 1;
                            }
                        }
                        else {
                            totalBranches += 2;
                            if (currentBranch.trueCount > 0) {
                                executedBranches += 1;
                            }
                            if (currentBranch.falseCount > 0) {
                                executedBranches += 1;
                            }
                        }
                    }
                });
            });
            fileData.summary.branches = new coverage_1.Coverage(totalBranches, executedBranches);
            this.coverage.summary.branches.total += totalBranches;
            this.coverage.summary.branches.covered += executedBranches;
        }
    }
    writeJsonReport() {
        const filePath = path.join(this.output, 'coverageReport.json');
        fs.writeFile(filePath, JSON.stringify(this.coverage), (err) => {
            if (err) {
                logger.error('Error writing file:', err);
            }
            else {
                logger.debug('File written successfully.');
            }
        });
    }
    writeHtmlReport() {
        logger.info('write html report!');
        let html = new html_1.HtmlReport(this.coverage, this.output);
        html.write();
    }
}
exports.Report = Report;
