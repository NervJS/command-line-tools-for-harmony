"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HtmlReport = void 0;
const path = require("path");
const fs = require("fs");
const html_escaper_1 = require("html-escaper");
const log4js = require("log4js");
const coverage_1 = require("../coverage");
const file_utils_1 = require("../utils/file_utils");
const constants_1 = require("../utils/constants");
const reportNode_1 = require("./reportNode");
const logger = log4js.getLogger();
const EMPTY = '';
const SLASH = '/';
const DOT = '.';
const DOT_SLASH = './';
const INDEX_HTML = 'index.html';
const DOT_HTML = '.html';
const DATA_SIGN = '{{data}}';
const RELATIVE_HOME_RES_SIGN = /{{relativeHomeRes}}/g;
class HtmlReport {
    constructor(coverage, output) {
        this.date = new Date().toString();
        this.coverage = coverage;
        this.output = output;
        this.commonPrefixPath = this.buildCommonPath();
    }
    write() {
        this.onSummary();
        this.writeHtmlRes();
    }
    writeHtmlRes() {
        const resFiles = [constants_1.Constants.VUE_JS, constants_1.Constants.ELEMENT_PLUS_JS, constants_1.Constants.ELEMENT_PLUS_CSS, constants_1.Constants.PRETTIFY_JS, constants_1.Constants.PRETTIFY_CSS];
        resFiles.forEach((value) => {
            fs.copyFileSync(value, path.join(this.output, path.basename(value)));
        });
    }
    onSummary() {
        for (const file of this.coverage.files) {
            if (!fs.existsSync(file.path)) {
                continue;
            }
            // HTML file name
            const filePath = this.generateFilePath(file.path, this.commonPrefixPath) + DOT_HTML;
            this.onDetail(file, filePath);
            file.link = path.relative(this.output, path.join(this.output, filePath));
        }
        let template = (0, file_utils_1.loadTemplate)(constants_1.Constants.TEMPLATE_REPORT_INDEX);
        if (this.coverage.files.length == 0) {
            return;
        }
        let reportRoot = this.getReportRoot();
        let reportArrays = [reportRoot];
        while (reportArrays.length != 0) {
            let tmpArrays = [];
            for (let reportNode of reportArrays) {
                this.writeReport(reportNode, template);
                for (let reportNodeChild of reportNode.children.values()) {
                    tmpArrays.push(reportNodeChild);
                }
            }
            reportArrays = tmpArrays;
        }
    }
    writeReport(reportNode, template) {
        if (reportNode.children.size < 1) {
            return;
        }
        let myPath = reportNode.absolutePath + reportNode.relativePath;
        myPath = myPath.replace(this.commonPrefixPath, this.output);
        let files = [];
        for (let child of reportNode.children.values()) {
            this.getFiles(child, files);
        }
        let streamOut = fs.createWriteStream(path.join(myPath, INDEX_HTML));
        let urlPath = myPath.replace(this.output, EMPTY);
        let relative2Home = path.relative(path.join(this.output, urlPath), path.join(this.output, INDEX_HTML));
        let relative2HomeRes = relative2Home.replace(INDEX_HTML, '');
        template = template.replace(RELATIVE_HOME_RES_SIGN, relative2HomeRes);
        template = template.replace(DATA_SIGN, JSON.stringify({
            date: reportNode.date,
            files,
            summary: reportNode.htmlReport.coverage.summary
        }));
        streamOut.write(template);
        streamOut.close();
    }
    getFiles(child, files) {
        let file = {
            version: 'bjc v1.0.0',
            versionCode: 10000,
            path: '',
            link: '',
            hash: '',
            lineCnt: 0,
            count: 0,
            functions: new Array(),
            summary: new coverage_1.Summary(),
            exeLine: []
        };
        file.path = child.relativePath;
        file.link = DOT_SLASH + child.relativePath + SLASH + INDEX_HTML;
        file.summary = child.htmlReport.coverage.summary;
        if (file.path.includes(DOT)) {
            this.fileProcessing(child, files);
        }
        else {
            files.push(file);
        }
    }
    fileProcessing(child, files) {
        let tmpSrc = child.htmlReport.coverage.files[0].path;
        tmpSrc = tmpSrc.replace(child.absolutePath, EMPTY);
        child.htmlReport.coverage.files[0].link = tmpSrc + DOT_HTML;
        child.htmlReport.coverage.files[0].path = child.name;
        files.push(child.htmlReport.coverage.files[0]);
    }
    getReportRoot() {
        if (this.coverage.files.length == 1) {
            return this.oneFileGetNode();
        }
        let fileArr = this.coverage.files[0].path.split(SLASH);
        let reportRoot = new reportNode_1.ReportNode(EMPTY, new coverage_1.Summary(), EMPTY, this.date);
        reportRoot.htmlReport.coverage.summary.add(this.coverage.files[0].summary || new coverage_1.Summary());
        let next = reportRoot;
        let absolutePath = EMPTY;
        for (let file of fileArr) {
            let node = new reportNode_1.ReportNode(file, this.coverage.files[0].summary || new coverage_1.Summary(), absolutePath, this.date);
            node.htmlReport.coverage.files.push(this.coverage.files[0]);
            absolutePath += file + SLASH;
            next.addChild(node);
            next = node;
        }
        for (let i = 1; i < this.coverage.files.length; i++) {
            let fileArr = this.coverage.files[i].path.split(SLASH);
            reportRoot.htmlReport.coverage.summary.add(this.coverage.files[i].summary || new coverage_1.Summary());
            let next = reportRoot;
            absolutePath = EMPTY;
            for (let j = 0; j < fileArr.length; j++) {
                if (!next.children.has(fileArr[j])) {
                    let node = new reportNode_1.ReportNode(fileArr[j], new coverage_1.Summary(), absolutePath, this.date);
                    node.htmlReport.coverage.files.push(this.coverage.files[i]);
                    next.addChild(node);
                }
                absolutePath += fileArr[j] + SLASH;
                let node = next.children.get(fileArr[j]);
                next = node || new reportNode_1.ReportNode(EMPTY, new coverage_1.Summary(), EMPTY, this.date);
                next.htmlReport.coverage.summary.add(this.coverage.files[i].summary || new coverage_1.Summary());
            }
        }
        this.simplifiedReportTree(reportRoot);
        if (reportRoot.relativePath[0] == SLASH) {
            reportRoot.relativePath = reportRoot.relativePath.slice(1, reportRoot.relativePath.length);
        }
        return reportRoot;
    }
    oneFileGetNode() {
        let flag = this.coverage.files[0].path.lastIndexOf(SLASH);
        let myPath = this.coverage.files[0].path.substring(0, flag + SLASH.length);
        let absolutePath = this.commonPrefixPath + SLASH;
        let relativePath = myPath.replace(absolutePath, EMPTY);
        let reportRoot = new reportNode_1.ReportNode(relativePath, new coverage_1.Summary(), absolutePath, this.date);
        reportRoot.htmlReport.coverage.summary.add(this.coverage.files[0].summary || new coverage_1.Summary());
        let node = new reportNode_1.ReportNode(this.coverage.files[0].path, this.coverage.files[0].summary || new coverage_1.Summary(), myPath, this.date);
        node.htmlReport.coverage.files.push(this.coverage.files[0]);
        reportRoot.addChild(node);
        return reportRoot;
    }
    simplifiedReportTree(node) {
        if (node.children.size < 1) {
            return;
        }
        if (node.children.size === 1) {
            let child = node.children.values().next().value;
            if (child == undefined) {
                return;
            }
            node.relativePath += SLASH + child.relativePath;
            node.children.delete(child.name);
            node.children = child.children;
            node.name = child.name;
            this.simplifiedReportTree(node);
            return;
        }
        for (let child of node.children.values()) {
            this.simplifiedReportTree(child);
        }
    }
    onDetail(fileData, filePath) {
        fs.mkdirSync(path.dirname(path.join(this.output, filePath)), { recursive: true });
        let template = (0, file_utils_1.loadTemplate)(constants_1.Constants.TEMPLATE_REPORT_DETAIL);
        let fileContent = fs.readFileSync(fileData.path, 'utf8');
        template = template.replace('{{code}}', (0, html_escaper_1.escape)(this.addSpaceBeforeNewlines(fileContent)));
        let relative2Home = path.relative(path.dirname(path.join(this.output, filePath)), path.join(this.output, 'index.html'));
        template = template.replace('{{data}}', JSON.stringify({ date: this.date, file: fileData, title: path.basename(filePath), relativeHome: relative2Home }));
        let relative2HomeRes = relative2Home.replace('index.html', '');
        template = template.replace(/{{relativeHomeRes}}/g, relative2HomeRes);
        let excuteLinesHtml = [];
        let executedLineCount = fileData.summary.lines.executedLineCount;
        for (let i = 1; i <= executedLineCount.length; i++) {
            if (executedLineCount[i] == 0) {
                excuteLinesHtml.push('<span class="cline-any cline-no">&nbsp;</span>');
            }
            else if (executedLineCount[i] > 0) {
                excuteLinesHtml.push(`<span class="cline-any cline-yes">${executedLineCount[i]}x</span>`);
            }
            else {
                excuteLinesHtml.push('<span class="cline-any cline-neutral">&nbsp;</span>');
            }
        }
        template = template.replace('{{excute_lines}}', excuteLinesHtml.join('\n'));
        let streamOut = fs.createWriteStream(path.join(this.output, filePath));
        streamOut.write(template);
        streamOut.close();
    }
    // 在换行符前添加空格，保证存在空行时覆盖率数据不会偏移
    addSpaceBeforeNewlines(inputString) {
        // \r\n（Windows）或 \n（Unix/Linux/Mac）  
        return inputString.replace(/(?:\r\n|\n)/g, ' $&');
    }
    buildCommonPath() {
        let paths = [];
        for (const file of this.coverage.files) {
            paths.push(file.path);
        }
        if (paths.length === 0) {
            return '';
        }
        const minLength = paths.reduce((min, path) => Math.min(min, path.length), Infinity);
        let commonPrefix = '';
        for (let i = 0; i < minLength; i++) {
            if (paths.every((path) => path[i] === paths[0][i])) {
                commonPrefix += paths[0][i];
            }
            else {
                break;
            }
        }
        if (!commonPrefix.endsWith('/')) {
            const lastSlashIndex = commonPrefix.lastIndexOf('/');
            if (lastSlashIndex !== -1 && !commonPrefix.endsWith(':/')) {
                commonPrefix = commonPrefix.slice(0, lastSlashIndex + 1);
            }
        }
        if (commonPrefix.endsWith('/') && !commonPrefix.endsWith(':/')) {
            commonPrefix = commonPrefix.slice(0, -1);
        }
        return commonPrefix;
    }
    generateFilePath(filePath, commonPrefix) {
        if (!commonPrefix.endsWith('/')) {
            commonPrefix += '/';
        }
        if (filePath.startsWith(commonPrefix)) {
            return filePath.substring(commonPrefix.length);
        }
        else {
            logger.warn('The provided filePath does not start with commonPrefix!');
            const letter = filePath.charAt(0);
            const colon = filePath.charAt(1);
            if (letter && colon === ':') {
                filePath = letter + filePath.substring(2);
            }
            return filePath;
        }
    }
}
exports.HtmlReport = HtmlReport;
