"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Helper = void 0;
const ts = require("typescript");
const log4js = require("log4js");
const crypto = require("crypto");
const constants_1 = require("../utils/constants");
const file_utils_1 = require("../utils/file_utils");
const coverage_1 = require("../coverage");
const globals_1 = require("../../plugin/globals");
const logger = log4js.getLogger();
const COMMENT_PRE = '//';
const COMMENT_FILE_RE = /^\s*instrument\s+ignore\s+(file)(?=\W|$)/;
const COMMENT_NEXT_RE = /^\s*instrument\s+ignore\s+(next)(?=\W|$)/;
const COMMENT_IF_RE = /^\s*instrument\s+ignore\s+(if)(?=\W|$)/;
const COMMENT_ELSE_RE = /^\s*instrument\s+ignore\s+(else)(?=\W|$)/;
class Helper {
    /**
     * Build val define statement
     * @example
     * buildVariableStat(ts.NodeFlags.Const, 'gcv', ts.factory.createStringLiteral('__BJC_COV__');
     * gencode: const gcv = '__BJC_COV__';
     * @param flags
     * @param name
     * @param initializer
     * @returns
     */
    static buildVariableStatement(flags, name, initializer) {
        return globals_1.Globals.tsc.factory.createVariableStatement(undefined, globals_1.Globals.tsc.factory.createVariableDeclarationList([globals_1.Globals.tsc.factory.createVariableDeclaration(globals_1.Globals.tsc.factory.createIdentifier(name), undefined, undefined, initializer)], flags));
    }
    /**
     * Build object literal expr
     * eg:  {version: "bjc v1.0.0", path: "test.ts", hash: "45120b480233412eb76719261370cbc5ffdeae3bbfe5d94fb5bea452fa18fb21"}
     * @param obj
     * @returns
     */
    static buildObjectLiteralExpression(obj) {
        let properties = [];
        for (const [key, value] of Object.entries(obj)) {
            if (typeof value === 'string') {
                properties.push(globals_1.Globals.tsc.factory.createPropertyAssignment(globals_1.Globals.tsc.factory.createIdentifier(key), globals_1.Globals.tsc.factory.createStringLiteral(value)));
            }
            else if (typeof value === 'number') {
                properties.push(globals_1.Globals.tsc.factory.createPropertyAssignment(globals_1.Globals.tsc.factory.createIdentifier(key), globals_1.Globals.tsc.factory.createNumericLiteral(value)));
            }
            else if (globals_1.Globals.tsc.isIdentifier(value)) {
                properties.push(globals_1.Globals.tsc.factory.createPropertyAssignment(globals_1.Globals.tsc.factory.createIdentifier(key), value));
            }
            else if (typeof value === 'object') {
                properties.push(globals_1.Globals.tsc.factory.createPropertyAssignment(globals_1.Globals.tsc.factory.createIdentifier(key), Helper.buildObjectLiteralExpression(value)));
            }
            else if (Object.values(coverage_1.IgnoreType).includes(value)) {
                properties.push(globals_1.Globals.tsc.factory.createPropertyAssignment(globals_1.Globals.tsc.factory.createIdentifier(key), globals_1.Globals.tsc.factory.createPropertyAccessExpression(globals_1.Globals.tsc.factory.createIdentifier('IgnoreType'), value)));
            }
        }
        return globals_1.Globals.tsc.factory.createObjectLiteralExpression(properties, false);
    }
    /**
     * code to statements ast
     * @param code
     * @returns
     */
    static buildAst(code) {
        let ast;
        globals_1.Globals.tsc.transpileModule(code, {
            compilerOptions: {
                declaration: true,
                target: ts.ScriptTarget.ES2020,
                module: ts.ModuleKind.CommonJS,
            },
            transformers: {
                before: [
                    (context) => {
                        return (node) => {
                            ast = node;
                            function visitor(node) {
                                // @ts-ignore
                                node.pos = -1;
                                // @ts-ignore
                                node.end = -1;
                                return globals_1.Globals.tsc.visitEachChild(node, visitor, context);
                            }
                            globals_1.Globals.tsc.visitEachChild(node, visitor, context);
                            return node;
                        };
                    },
                ],
            },
        });
        return ast.statements;
    }
    /**
     * template to statments ast.
     * @param fileName
     * @returns
     */
    static buildAstFromTemplate(fileName) {
        let code = (0, file_utils_1.loadTemplate)(fileName);
        return Helper.buildAst(code);
    }
    /**
     * Instrument BjcCov class and new instance.
     * @param node
     * @param clsName
     * @param objName
     * @param coverageData
     */
    static instrumentBjcCovCls(node, objName, coverageData) {
        let clsDef = Helper.buildAstFromTemplate(constants_1.Constants.TEMPLATE_BJC_COV_CLASS)[0];
        let instanceStmt = Helper.buildVariableStatement(ts.NodeFlags.Let, objName, globals_1.Globals.tsc.factory.createNewExpression(globals_1.Globals.tsc.factory.createIdentifier(constants_1.Constants.BJC_COV_CLASS_NAME), undefined, [
            Helper.buildObjectLiteralExpression(coverageData),
        ]));
        let index = 0;
        for (let idx = 0; idx < node.statements.length; idx++) {
            if (!(globals_1.Globals.tsc.isImportDeclaration(node.statements[idx]) || globals_1.Globals.tsc.isImportEqualsDeclaration(node.statements[idx]))) {
                index = idx;
                break;
            }
        }
        const statements = Array.from(node.statements);
        statements.splice(index, 0, clsDef, instanceStmt);
        return globals_1.Globals.tsc.factory.updateSourceFile(node, statements);
    }
    /**
     * Instrument import ohos.file.fs
     * import bjc_fs from '@ohos.file.fs';
     * @param node
     */
    static instrumentImportOhosFs(node) {
        let importFs = globals_1.Globals.tsc.factory.createImportDeclaration(undefined, globals_1.Globals.tsc.factory.createImportClause(false, globals_1.Globals.tsc.factory.createIdentifier('bjc_fs'), undefined), globals_1.Globals.tsc.factory.createStringLiteral('@ohos.file.fs'));
        const statements = Array.from(node.statements);
        statements.unshift(importFs);
        return globals_1.Globals.tsc.factory.updateSourceFile(node, statements);
    }
    static instumentImportHilog(node) {
        let importHilog = globals_1.Globals.tsc.factory.createImportDeclaration(undefined, globals_1.Globals.tsc.factory.createImportClause(false, undefined, globals_1.Globals.tsc.factory.createNamedImports([globals_1.Globals.tsc.factory.createImportSpecifier(false, undefined, globals_1.Globals.tsc.factory.createIdentifier('hilog'))])), globals_1.Globals.tsc.factory.createStringLiteral('@kit.PerformanceAnalysisKit'));
        const statements = Array.from(node.statements);
        statements.unshift(importHilog);
        return globals_1.Globals.tsc.factory.updateSourceFile(node, statements);
    }
    /**
     * Instrument process.on('exit') hook to file
     * @param node
     */
    static instrumentProcessExitEvent(node) {
        const statements = Array.from(node.statements);
        return globals_1.Globals.tsc.factory.updateSourceFile(node, statements);
    }
    static parseClassDeclaration(clsNode) {
        var _a;
        let name = '';
        if (clsNode.name) {
            name = clsNode.name.text;
        }
        let cls = { name: name, extends: [], implements: [] };
        (_a = clsNode.heritageClauses) === null || _a === void 0 ? void 0 : _a.forEach((heritageClause) => {
            heritageClause.types.forEach((type) => {
                let heritageClauseName = '';
                if (globals_1.Globals.tsc.isIdentifier(type.expression)) {
                    heritageClauseName = type.expression.text;
                }
                else if (globals_1.Globals.tsc.isPropertyAccessExpression(type.expression)) {
                    heritageClauseName = Helper.handlePropertyAccessExpression(type.expression);
                }
                else {
                    logger.warn('Other type expression found!!!');
                }
                if (heritageClause.token == ts.SyntaxKind.ExtendsKeyword) {
                    cls.extends.push(heritageClauseName);
                }
                else {
                    cls.implements.push(heritageClauseName);
                }
            });
        });
        return cls;
    }
    static handlePropertyAccessExpression(node) {
        let right = node.name.text;
        let left = '';
        if (ts.SyntaxKind[node.expression.kind] == 'Identifier') {
            left = node.expression.text;
        }
        else if (globals_1.Globals.tsc.isStringLiteral(node.expression)) {
            left = node.expression.text;
        }
        else if (globals_1.Globals.tsc.isPropertyAccessExpression(node.expression)) {
            left = Helper.handlePropertyAccessExpression(node.expression);
        }
        let propertyAccessExpressionName = left + '.' + right;
        return propertyAccessExpressionName;
    }
    static shouldIgnoreNode(node, sourceFile) {
        if (node.pos < 0 || node.end < 0) {
            return coverage_1.IgnoreType.None;
        }
        const commentRanges = globals_1.Globals.tsc.getLeadingCommentRanges(node.getFullText(sourceFile), 0) || [];
        for (const range of commentRanges.reverse()) {
            const comment = node.getFullText(sourceFile).slice(range.pos, range.end);
            const tempComment = comment.trim().substring(COMMENT_PRE.length);
            if (COMMENT_FILE_RE.test(tempComment)) {
                return coverage_1.IgnoreType.File;
            }
            if (COMMENT_NEXT_RE.test(tempComment)) {
                return coverage_1.IgnoreType.Next;
            }
            if (globals_1.Globals.tsc.isIfStatement(node)) {
                if (COMMENT_IF_RE.test(tempComment)) {
                    return coverage_1.IgnoreType.If;
                }
                if (COMMENT_ELSE_RE.test(tempComment)) {
                    return coverage_1.IgnoreType.Else;
                }
            }
        }
        return coverage_1.IgnoreType.None;
    }
    static markNodeIgnored(node, ignoreType, recursive = true) {
        node.ignored = ignoreType;
        if (recursive) {
            globals_1.Globals.tsc.forEachChild(node, (child) => {
                Helper.markNodeIgnored(child, ignoreType, recursive);
            });
        }
    }
    static hashNodeContent(node) {
        let sha256 = crypto.createHash('sha256');
        sha256.update(node.getText());
        return sha256.digest('hex');
    }
}
exports.Helper = Helper;
