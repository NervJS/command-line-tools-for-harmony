"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.normalWorker=exports.watchWorker=void 0;const cluster_1=__importDefault(require("cluster")),worker_threads_1=require("worker_threads"),noop_js_1=require("../../../../common/util/noop.js"),build_event_js_1=require("../../../common/daemon-protocol/build-event.js"),hvigor_log_js_1=require("../../../log/hvigor-log.js"),duration_event_js_1=require("../../../metrics/event/duration-event.js"),log_event_js_1=require("../../../metrics/event/log-event.js"),constant_js_1=require("../constant/constant.js"),hvigor_lifecycle_hook_js_1=require("../../lifecycle/hook/hvigor-lifecycle-hook.js"),hook_const_js_1=require("../../../../common/const/hook-const.js"),log=hvigor_log_js_1.HvigorLogger.getLogger("daemon");class WorkerItem{constructor(e,r){this.worker=e,this.hasCustomTerminate=r}}const genPromiseAndTriggers=(e,r)=>{let t=noop_js_1.noop,o=noop_js_1.noop;const n=new Promise(((n,s)=>{t=t=>{e.taskExecutedStatus.setWorkerTimePeriod([r,Number(process.hrtime.bigint())]),s(t)},o=t=>{e.taskExecutedStatus.setWorkerTimePeriod([r,Number(process.hrtime.bigint())]),n(t)}}));return{reject:t,resolve:o,promise:n}};async function handleResponse(e,r,t,o,n,s){if(e.event!==constant_js_1.PoolConstant.WORK_DONE){if(e.event===constant_js_1.PoolConstant.WORK_ERROR){null==s||s.stop(duration_event_js_1.DurationEventState.FAILED),null==s||s.setLog(null==s?void 0:s.getName(),log_event_js_1.MetricLogType.ERROR),await n(e.returnVal);const a=e.error,i=`${r.getName()} ${o?"watch":"normal"} work[${t}] failed.`;throw log.debug(i),new Error(a||i)}throw new Error(`Unknown worker event: ${e}.`)}null==s||s.stop(duration_event_js_1.DurationEventState.SUCCESS),null==s||s.setLog(null==s?void 0:s.getName(),log_event_js_1.MetricLogType.INFO),await n(e.returnVal)}class WorkerCountManager{static allocateWorkerId(){return this.cnt++}static reset(){this.cnt=1}}WorkerCountManager.cnt=1;class WatchWorker{constructor(){this.workerMap=new Map,this.addListenersOnSessionManager()}getWorker(e){var r;return null===(r=this.workerMap.get(e))||void 0===r?void 0:r.worker}createWorker(e,r,t,o,n){const s=Number(process.hrtime.bigint()),a=new worker_threads_1.Worker(r,n),i=WorkerCountManager.allocateWorkerId();this.workerMap.set(i,new WorkerItem(a,t));const l=e.addSubDurationEvent(i.toString()).start();null==l||l.setTid(`Worker${i}`),cluster_1.default.isWorker&&process.send({type:build_event_js_1.WatchEvent.NEW_WATCH_WORKER,workerId:i});const{promise:c,resolve:_,reject:u}=genPromiseAndTriggers(e,s);return e.pendingPromises.add(c),this.createWorkerOnMessageListener(a,_,u,e,i,o,l),this.createWorkerOnErrorListener(a,u,e,i),i.toString()}createWorkerOnMessageListener(e,r,t,o,n,s,a){e.on("message",(async e=>{if(e)if(e.event)try{await handleResponse(e,o,n,!0,s,a),r("succeed")}catch(e){t(e)}else if(e.type!==build_event_js_1.WatchEvent.WATCH_COMPILE_RESULT&&e.type!==build_event_js_1.WatchEvent.WATCH_START&&e.type!==build_event_js_1.WatchEvent.WATCH_RESULT&&e.type!==build_event_js_1.WatchEvent.WATCH_LOG){if(e.type===build_event_js_1.WatchEvent.TERMINATE_WORKER)return log.debug("watch worker: worker is ready to be terminated."),void this.terminateWorker(e.content);t(new Error(`Unknown watch event: ${e}.`))}else{log.debug(`watch worker: send response to session manager. Response type: ${e.type}`);try{await hvigor_lifecycle_hook_js_1.HvigorLifecycleHook.getInstance().runHook(hook_const_js_1.HookType.onWatchWorkerMessage,e,a)}catch(e){log.error(`custom onWatchWorkerMessage hook exception: ${e.message}`)}cluster_1.default.isWorker&&process.send({...e,workerId:n})}else t(new Error("Undefined response."))}))}createWorkerOnErrorListener(e,r,t,o){e.on("error",(async e=>{log.error(`${t.getName()} watch work[${o}] failed.`),log.error(e),r(e)}))}beforeTerminate(e){var r,t;(null===(r=this.workerMap.get(e))||void 0===r?void 0:r.hasCustomTerminate)?null===(t=this.workerMap.get(e))||void 0===t||t.worker.postMessage({type:build_event_js_1.WatchEvent.TERMINATE_WORKER,content:e}):this.terminateWorker(e)}terminateWorker(e){var r;null===(r=this.workerMap.get(e))||void 0===r||r.worker.terminate(),this.workerMap.delete(e),log.debug(`Server currently has ${this.workerMap.size} `+(this.workerMap.size>1?"watch-workers":"watch-worker"))}addListenersOnSessionManager(){cluster_1.default.isWorker&&cluster_1.default.worker.on("message",(e=>{var r;void 0!==e.workerId&&0!==e.workerId?e.type===build_event_js_1.WatchEvent.WATCH_COMPILE_DATA?(log.debug("watch worker: receive watch compile tata."),null===(r=this.getWorker(e.workerId))||void 0===r||r.postMessage(e.content)):e.type===build_event_js_1.WatchEvent.CLOSE_WATCH&&this.beforeTerminate(e.workerId):log.debug("watch worker: worker id should be larger than 0. Nothing will be sent to any worker thread.")}))}}class NormalWorker{constructor(){this.maxWorkerNum=constant_js_1.PoolConstant.MAX_POOL_NUM>1?constant_js_1.PoolConstant.MAX_POOL_NUM-1:1}createWorker(e,r,t,o,n){const s=Number(process.hrtime.bigint()),a=WorkerCountManager.allocateWorkerId(),{promise:i,resolve:l,reject:c}=genPromiseAndTriggers(e,s);return e.pendingPromises.add(i),NormalWorker.promiseMap.set(a,{resolve:l,reject:c}),NormalWorker.runningThreadCnt>=this.maxWorkerNum?(log.debug(`Creating worker failed since runningThreadCnt is not smaller than ${this.maxWorkerNum}.`),NormalWorker.workQueue.push({workerId:a,task:e,filename:r,callback:o,options:n})):(log.debug(`Creating worker with id ${a}.`),this.executeWorker(a,e,r,o,n)),a.toString()}reset(){NormalWorker.runningThreadCnt=0,NormalWorker.workQueue.length=0,NormalWorker.promiseMap.clear()}executeWorker(e,r,t,o,n){const s=new worker_threads_1.Worker(t,n);NormalWorker.runningThreadCnt++;const{resolve:a,reject:i}=NormalWorker.promiseMap.get(e);NormalWorker.promiseMap.delete(e);const l=r.addSubDurationEvent(e.toString()).start();null==l||l.setTid(`Worker${e}`),s.on("message",(async t=>{if(t)if(t.event)try{if(await handleResponse(t,r,e,!1,o,l),s.terminate(),NormalWorker.runningThreadCnt--,NormalWorker.workQueue.length){const e=NormalWorker.workQueue.shift();log.debug(`Normal worker queue is not empty. Create worker with id: ${e.workerId}.`),this.executeWorker(e.workerId,e.task,e.filename,e.callback,e.options)}a(!0)}catch(e){i(e)}else t.type!==build_event_js_1.WatchEvent.WATCH_COMPILE_RESULT&&t.type!==build_event_js_1.WatchEvent.WATCH_START&&t.type!==build_event_js_1.WatchEvent.WATCH_RESULT&&t.type!==build_event_js_1.WatchEvent.WATCH_LOG&&(t.type!==build_event_js_1.WatchEvent.TERMINATE_WORKER?i(new Error(`Unknown watch event: ${t}.`)):log.debug("Impossible response type in normal worker: TERMINATE_WORKER"));else i(new Error("Undefined response."))})),s.on("error",(async t=>{log.debug(`${r.getName()} normal work[${e}] failed.`),i(t)}))}}NormalWorker.runningThreadCnt=0,NormalWorker.workQueue=[],NormalWorker.promiseMap=new Map,exports.watchWorker=new WatchWorker,exports.normalWorker=new NormalWorker;