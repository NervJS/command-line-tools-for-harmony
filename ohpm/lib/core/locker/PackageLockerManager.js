"use strict";var e=this&&this.__awaiter||function(e,t,i,s){return new(i||(i=Promise))((function(a,c){function r(e){try{n(s.next(e))}catch(e){c(e)}}function o(e){try{n(s.throw(e))}catch(e){c(e)}}function n(e){var t;e.done?a(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(r,o)}n((s=s.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.PackageLockerManager=void 0;const i=require("../dependency/dep-builder/DepBuilderFactory"),s=require("../dependency/util"),a=require("../../util"),c=require("./PackageLocker"),r=require("./index"),o=require("../registry/registry"),n=require("../../util/FsUtil"),l=t(require("path")),h=t(require("../../log")),d=require("../install/service/handleCliInput"),p=require("../override-dependency-map/OverrideDepMapManager"),u=require("../../common/message"),g=require("../../tools/json5"),k=require("../../config"),f=require("../../common/Constants"),m=t(require("os")),v=require("../version-conflict/VersionConflictManager"),S=require("../overrides"),L=require("../dependency/inner-dep-cache/InnerDepCache");class y{static getInstance(){return this.Instance||(this.Instance=new y),this.Instance}syncLoadLockers(e){e.forEach((e=>{this.getModuleLocker(e)}))}constructor(){this.SUFFIX_CONTENT_HASH="#SHA256",this.moduleLockers=new Map,this.deDupeCache=new Map,this.localDepCache=new Map,this.maxSatisfyingVersionCache=new Map,this.nodeDataPromiseCache=new Map,this.versionsMap=new Map,this.resolveFailedDepNameSet=new Set,this.fetchSpecMap=new Map,this.projectLockJson=g.JSON5.parse(g.JSON5.stringify(r.LockFile.defaultLockJson));const e=l.default.resolve(m.default.homedir(),f.Constants.PmDir),t=a.HashUtil.getDigest(k.config.getProjectRoot());this.mtimeCacheFilePath=l.default.resolve(e,f.Constants.MtimeCacheDir,t),a.FsBlockingUtil.existsSync(this.mtimeCacheFilePath)?this.readLocalArtifactMtimeCache=a.FsBlockingUtil.readJSON5Sync(this.mtimeCacheFilePath):this.readLocalArtifactMtimeCache={},this.writeLocalArtifactMtimeCache=Object.assign({},this.readLocalArtifactMtimeCache),this.innerDepCache=new L.InnerDepCache}addResolveFailedDepName(e){this.resolveFailedDepNameSet.add(e)}hasResolveFailedDepName(e){return this.resolveFailedDepNameSet.has(e)}getDepNodeData(t){return e(this,void 0,void 0,(function*(){const e=this.getModuleLocker(t.rootDir),i=(0,s.parseDependency)(t.pkg,t.where),a=this.getDedupeKey(i.getName(),i.getFetchSpec());let c=this.tryGetNodeDataFromCache(a,e);return c||(c=yield this.buildNodeDataAsync(t,a)),this.saveInTargetLockFile(c,t.rootDir,i,e),c}))}updateGlobalMtimeCacheAfterInstallation(e,t){this.readLocalArtifactMtimeCache[e]=t,this.updateLocalArtifactMtime(e,t)}updateGlobalHashCache(e,t){this.readLocalArtifactMtimeCache[e.concat(this.SUFFIX_CONTENT_HASH)]=t,this.updateLocalArtifactHash(e,t)}tryGetNodeDataFromCache(e,t){let i=t.getDepNodeDataFromCache(e);return i||(i=this.deDupeCache.get(e)||this.localDepCache.get(e)),i}buildNodeDataAsync(t,s){return e(this,void 0,void 0,(function*(){let e=this.nodeDataPromiseCache.get(s);if(e)h.default.debug("PackageLockerManager",`nodeData ${s} building promise found`);else{h.default.debug("PackageLockerManager",`start building nodeData ${s}.`);e=i.DepBuilderFactory.getInstance().getBuilder(t.pkg,t.builderType,t.where).build(t),this.nodeDataPromiseCache.set(s,e)}const a=yield e;return a.unmet?(this.nodeDataPromiseCache.delete(s),a):(a.isNativeSoType||(this.updateMaxSatisfyingVersion(a),this.collectFetchSpecs(a),this.collectDepVersions(a)),this.deDupeCache.set(s,a),a.registryType===o.RegistryType.local&&this.localDepCache.set(s,a),a)}))}saveInTargetLockFile(e,t,i,a){const c=this.getDedupeKey(i.getName(),i.getFetchSpec());if(!e.unmet){this.applySpecChangedIfNeeded(e,t,i,c),a.addDepNodeData(c,e);const r=e.pinnedSpec;this.updateLockSpec(t,e.name,this.getVersionByRegistryType(e),r),this.updateLockPkg(t,e.name,r,(0,s.getLockPkgFromNodeData)(e))}}applySpecChangedIfNeeded(e,t,i,a){i.getRawSpec()||(0,s.isLocalDependency)(e.pinnedSpec)||!d.cliInputNames.includes(e.name)||(this.deleteSpecifier(t,a),e.saveSpec=`^${e.pinnedSpec}`)}getDedupeKey(e,t){return`${e}@${t}`}getVersionByRegistryType(e){return e.registryType===o.RegistryType.local?e.fetchSpec:e.saveSpec}getModuleLocker(e){if(!this.moduleLockers.get(e)){const t=this.createPkgLocker(e);this.moduleLockers.set(e,t)}return this.moduleLockers.get(e)}flushAllLockers(){return e(this,void 0,void 0,(function*(){const e=[];this.moduleLockers.forEach((t=>{e.push(t.flush())})),yield Promise.all(e),((yield n.FsUtil.exists(this.mtimeCacheFilePath))||Object.keys(this.writeLocalArtifactMtimeCache).length>0)&&(yield n.FsUtil.createDirIfNotExists(l.default.dirname(this.mtimeCacheFilePath)),yield n.FsUtil.writeFile(this.mtimeCacheFilePath,JSON.stringify(this.writeLocalArtifactMtimeCache,null,2)))}))}createPkgLocker(e){const t=new c.PackageLocker(e);if(a.FsBlockingUtil.existsSync(t.lockFilePath)){const e=a.FsBlockingUtil.readJSON5Sync(t.lockFilePath);r.LockFile.version===e.lockfileVersion&&(this.mergeLockJson(t,e),t.lockJson.lockfileVersion=r.LockFile.defaultLockJson.lockfileVersion,t.lockJson.ATTENTION=r.LockFile.defaultLockJson.ATTENTION)}return t}mergeLockJson(e,t){if(!e.lockJson.specifiers&&!e.lockJson.packages)return void(e.lockJson=t);const i=t.specifiers;e.lockJson.specifiers&&Object.keys(e.lockJson.specifiers).forEach((t=>{i[t]=e.lockJson.specifiers[t]}));const s=t.packages;e.lockJson.packages&&Object.keys(e.lockJson.packages).forEach((t=>{s[t]=e.lockJson.packages[t]})),!t.meta&&t.specifiers&&t.packages&&(t.meta={stableOrder:!1}),e.lockJson.meta.stableOrder=!!t.meta&&t.meta.stableOrder,e.lockJson.specifiers=i,e.lockJson.packages=s}parseSpecKey(e){let t,i,s=e,a=e;if(e.startsWith("@")&&e.includes("/")){const i=e.indexOf("/");t=e.substring(0,i),a=s.substring(i+1,s.length)}const c=a.indexOf("@");if(!(c>0))throw new Error((0,u.format)(u.Messages.Locker.InvalidSpecKey,{specKey:e}));return s=a.substring(0,c),i=a.substring(c+1,a.length),a=s,{scope:t,name:s,pkgName:a,version:i}}getLocalArtifactMtime(e){return this.readLocalArtifactMtimeCache[e]}getLocalArtifactHash(e){return this.readLocalArtifactMtimeCache[e.concat(this.SUFFIX_CONTENT_HASH)]}updateLocalArtifactMtime(e,t){this.writeLocalArtifactMtimeCache[e]=t}updateLocalArtifactHash(e,t){this.writeLocalArtifactMtimeCache[e.concat(this.SUFFIX_CONTENT_HASH)]=t}relativeSpec(e,t){return(0,s.isLocalDependency)(t)?(t.startsWith("file:")&&(t=t.substring(5)),l.default.isAbsolute(t)?n.FsUtil.slash(l.default.relative(e,t)):n.FsUtil.slash(t)):t}relativeLockPkg(e,t){return t?(t.resolved&&(0,s.isLocalDependency)(t.resolved)&&(t.resolved=this.relativeSpec(e,t.resolved)),t.resolved_hsp&&(0,s.isLocalDependency)(t.resolved_hsp)&&(t.resolved_hsp=this.relativeSpec(e,t.resolved_hsp)),t):t}resolveLockPkg(e,t){return t?(t.resolved&&(0,s.isLocalDependency)(t.resolved)&&(t.resolved=l.default.resolve(e,t.resolved)),t.resolved_hsp&&(0,s.isLocalDependency)(t.resolved_hsp)&&(t.resolved_hsp=l.default.resolve(e,t.resolved_hsp)),t):t}resolveLockSpec(e,t){if(!t)return t;const i=this.parseSpecKey(t);if(i.version&&(0,s.isLocalDependency)(i.version)){const s=l.default.resolve(e,i.version);return t=`${i.name}@${s}`}return t}getLockSpec(e,t,i){const s=this.relativeSpec(e,i),a=this.getModuleLocker(e),c=`${t}@${i}`,r=this.projectLockJson.specifiers;let o=a.getLockSpec(t,s);if(!o&&r&&(o=r[c],o)){const s=this.parseSpecKey(o);a.updateLockSpec(t,i,this.relativeSpec(e,s.version))}return this.resolveLockSpec(e,o)}updateLockSpec(e,t,i,s){const a=this.relativeSpec(e,i),c=this.relativeSpec(e,s),r=`${t}@${i}`,o=this.getModuleLocker(e),n=this.projectLockJson.specifiers;o.updateLockSpec(t,a,c),n[r]=`${t}@${s}`}getLockPkg(e,t,i){const s=this.relativeSpec(e,i),a=this.getLockSpec(e,t,i),c=this.projectLockJson.packages,r=this.getModuleLocker(e);let o=r.getLockPkg(t,s);return o||(o=this.relativeLockPkg(e,c[a]),a&&o&&r.updateLockPkg(t,s,o)),this.resolveLockPkg(e,o)}updateLockPkg(e,t,i,s){const a=Object.assign({},s),c=this.getModuleLocker(e),r=this.relativeSpec(e,i),o=this.relativeLockPkg(e,a);this.addOrRemoveOverrideDependencyMapTag(e,t,r,o),c.updateLockPkg(t,r,o);this.projectLockJson.packages[`${t}@${i}`]=a}addOrRemoveOverrideDependencyMapTag(e,t,i,s){s.registryType!==o.RegistryType.local||l.default.isAbsolute(i)||(i=l.default.resolve(e,i));const a=p.OverrideDepMapManager.getInstance();a.hasConfig()&&a.needOverride(t,i,i)?s.maskedByOverrideDependencyMap=!0:delete s.maskedByOverrideDependencyMap}clearSpecifiers(e,t){if(t.allModules)for(const e of this.moduleLockers.values())e.clearSpecifiers();else{this.getModuleLocker(e).clearSpecifiers()}}deleteSpecifier(e,t){const i=this.getModuleLocker(e),s=this.parseSpecKey(t);if(s.version&&l.default.isAbsolute(s.version)){const i=n.FsUtil.slash(l.default.relative(e,s.version));t=`${s.name}@${i}`}i.deleteSpecifier(t)}clearVisitedSet(e){this.getModuleLocker(e).clearVisitedSet()}deletePackage(e,t){const i=this.parseSpecKey(t);if(i.version&&l.default.isAbsolute(i.version)){const s=n.FsUtil.slash(l.default.relative(e,i.version));t=`${i.name}@${s}`}this.getModuleLocker(e).deletePackage(t)}clearLockerCache(){this.deDupeCache.clear(),this.nodeDataPromiseCache.clear(),this.versionsMap.clear(),this.localDepCache.clear(),this.projectLockJson.packages={},this.projectLockJson.specifiers={},this.moduleLockers.forEach((e=>{e.dedupeCache.clear()}))}getFetchSpecSet(e){var t;return null!==(t=this.fetchSpecMap.get(e))&&void 0!==t?t:new Set}collectFetchSpecs(e){if(e.isNativeSoType)return;this.fetchSpecMap.has(e.name)||this.fetchSpecMap.set(e.name,new Set);const t=S.overridesMap.get(e.name);this.fetchSpecMap.get(e.name).add(null!=t?t:e.fetchSpec)}getVersionSet(e){var t;return null!==(t=this.versionsMap.get(e))&&void 0!==t?t:new Set}collectDepVersions(e){e.isNativeSoType||(this.versionsMap.has(e.name)||this.versionsMap.set(e.name,new Set),this.versionsMap.get(e.name).add(e.pinnedSpec))}getMaxSatisfyingVersionData(e){return this.maxSatisfyingVersionCache.get(e)}isMaxSatisfyingVersionData(e){const t=this.maxSatisfyingVersionCache.get(e.name);return!!t&&t.pinnedSpec===e.pinnedSpec}delMaxSatisfyingVersionData(e){this.maxSatisfyingVersionCache.delete(e)}getInnerDepCache(){return this.innerDepCache}registryInnerNode(e){this.innerDepCache.addDependencyNode(e)}updateMaxSatisfyingVersion(e){!this.resolveFailedDepNameSet.has(e.name)&&v.VersionConflictManager.getInstance().isMaxSatisfying(e,this.maxSatisfyingVersionCache,this.fetchSpecMap)&&this.maxSatisfyingVersionCache.set(e.name,e)}}exports.PackageLockerManager=y;