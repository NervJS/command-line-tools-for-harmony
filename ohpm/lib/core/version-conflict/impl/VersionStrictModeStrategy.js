"use strict";var e=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.VersionStrictModeStrategy=void 0;const n=require("../../dependency/util"),i=e(require("semver")),t=require("../../../common/message"),a=require("../../locker"),s=e(require("../../../log")),d=require("../../../util/semverRangesConversion");exports.VersionStrictModeStrategy=class{isMaxSatisfying(e,i,d){if(s.default.debug("",`Start strict mode strategy, target: ${e.name}, fetchSpec: ${e.fetchSpec}, pinnedSpec: ${e.pinnedSpec}`),e.isRoot)return!0;if(e.isNativeSoType)return!1;if(!(0,n.isLocalDependency)(e.pinnedSpec)&&!this.isFixedVersion(e.pinnedSpec))throw new Error((0,t.format)(t.Messages.DepBuilder.InvalidDepVersion,{version:e.version,depKey:`${e.name}@${e.pinnedSpec}`}));const r=i.get(e.name);return!(r&&!r.unmet)||!e.unmet&&(e.pinnedSpec!==r.pinnedSpec&&((0,n.isLocalDependency)(e.pinnedSpec)||(0,n.isLocalDependency)(r.pinnedSpec))?(s.default.debug("",`Found resolve fail case of local dependency conflict, target: ${e.name}, ${e.fetchSpec}, ${e.pinnedSpec}, resolvedNode: ${r.name}, ${r.fetchSpec}, ${r.pinnedSpec}`),a.PackageLockerManager.getInstance().addResolveFailedDepName(e.name),!1):this.strictDecisionMakingMode(e,r,d))}strictDecisionMakingMode(e,n,i){return this.isFixedVersion(n.fetchSpec)?this.handleWhileResolvedNodeIsFixedVersion(e,n):this.isFixedVersion(e.fetchSpec)?this.handleWhileTargetNodeIsFixedVersion(e,n,i):this.handleWhileTargetAndResolvedNodeIsRangeVersion(e,n,i)}isFixedVersion(e){return null!==i.default.valid(e,{loose:!0})}handleWhileResolvedNodeIsFixedVersion(e,n){return s.default.debug("",`Starting to handle the case where the resolved node is fixed version, target: ${e.name}, ${e.fetchSpec}, ${e.pinnedSpec}, resolvedNode: ${n.name}, ${n.fetchSpec}, ${n.pinnedSpec}`),this.isFixedVersion(e.fetchSpec)?(n.pinnedSpec===e.pinnedSpec||(s.default.debug("",`Found resolve fail case of two fixed versions, target: ${e.name}, ${e.fetchSpec}, ${e.pinnedSpec}, resolvedNode: ${n.name}, ${n.fetchSpec}, ${n.pinnedSpec}`),a.PackageLockerManager.getInstance().addResolveFailedDepName(e.name)),!1):(this.isVersionInMultiRanges(n.pinnedSpec,[e.fetchSpec])||(s.default.debug("",`Found resolve fail case of resolved not in range of target, target: ${e.name}, ${e.fetchSpec}, ${e.pinnedSpec}, resolvedNode: ${n.name}, ${n.fetchSpec}, ${n.pinnedSpec}`),a.PackageLockerManager.getInstance().addResolveFailedDepName(e.name)),!1)}handleWhileTargetNodeIsFixedVersion(e,n,i){if(s.default.debug("",`Starting to handle the case where target node is a fixed version, target: ${e.name}, ${e.fetchSpec}, ${e.pinnedSpec}, resolvedNode: ${n.name}, ${n.fetchSpec}, ${n.pinnedSpec}`),e.pinnedSpec===n.pinnedSpec)return!0;if(this.isVersionInMultiRanges(e.pinnedSpec,[n.fetchSpec])){const t=this.validAndGetRawVersions(e,i),{rangeVersions:d}=this.getFixedAndRanges(t);return!!this.isVersionInMultiRanges(e.pinnedSpec,d)||(s.default.debug("",`Found resolve fail case of target not in raw versions, target: ${e.name}, ${e.fetchSpec}, ${e.pinnedSpec}, resolvedNode: ${n.name}, ${n.fetchSpec},${n.pinnedSpec}`),a.PackageLockerManager.getInstance().addResolveFailedDepName(e.name),!1)}return s.default.debug("",`Found resolve fail case of target not in range of resolved, target: ${e.name}, ${e.fetchSpec}, ${e.pinnedSpec}, resolvedNode: ${n.name}, ${n.fetchSpec},${n.pinnedSpec}`),a.PackageLockerManager.getInstance().addResolveFailedDepName(e.name),!1}handleWhileTargetAndResolvedNodeIsRangeVersion(e,n,i){if(s.default.debug("",`Starting to handle the case where both the target and resolved dependency nodes have range versions, target: ${e.name}, ${e.fetchSpec}, ${e.pinnedSpec}, resolvedNode: ${n.name}, ${n.fetchSpec}, ${n.pinnedSpec}`),e.pinnedSpec<n.pinnedSpec){const t=this.validAndGetRawVersions(e,i),{rangeVersions:d}=this.getFixedAndRanges(t);return!!this.isVersionInMultiRanges(e.pinnedSpec,d)||(s.default.debug("",`Found resolve fail case of target not in range of raw versions, target: ${e.name}, ${e.fetchSpec}, ${e.pinnedSpec}, resolvedNode: ${n.name}, ${n.fetchSpec},${n.pinnedSpec}`),a.PackageLockerManager.getInstance().addResolveFailedDepName(e.name),!1)}return!!this.isVersionInMultiRanges(e.pinnedSpec,[n.fetchSpec])||(this.isVersionInMultiRanges(n.pinnedSpec,[e.fetchSpec])||(s.default.debug("",`Found resolve fail case of resolved not in range of target, target: ${e.name}, ${e.fetchSpec}, ${e.pinnedSpec}, resolvedNode: ${n.name}, ${n.fetchSpec},${n.pinnedSpec}`),a.PackageLockerManager.getInstance().addResolveFailedDepName(e.name)),!1)}validAndGetRawVersions(e,n){if(!n||0===n.size)return new Set;const i=n.get(e.name);return i&&0!==i.size?i:new Set}getFixedAndRanges(e){const i=[],t=[];return e.forEach((e=>{(0,n.isLocalDependency)(e)||(this.isFixedVersion(e)?i.push(e):t.push(e))})),{fixedVersions:i,rangeVersions:t}}isVersionInMultiRanges(e,n){if(!n||!n.length)return!0;return(0,d.convertVersions)(n).every((n=>i.default.satisfies(e,n,{loose:!0,includePrerelease:!0})))}};