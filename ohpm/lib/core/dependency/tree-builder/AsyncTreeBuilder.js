"use strict";var e=this&&this.__awaiter||function(e,r,i,t){return new(i||(i=Promise))((function(n,o){function d(e){try{l(t.next(e))}catch(e){o(e)}}function a(e){try{l(t.throw(e))}catch(e){o(e)}}function l(e){var r;e.done?n(e.value):(r=e.value,r instanceof i?r:new i((function(e){e(r)}))).then(d,a)}l((t=t.apply(e,r||[])).next())}))},r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.AsyncTreeBuilder=void 0;const i=require("../struct/dependencyTree"),t=require("../../../concurrent/ConcurrentExecutor"),n=r(require("../../../log")),o=require("../../overrides"),d=require("../struct/dependencyNode"),a=require("../util"),l=require("../dep-builder/types"),s=require("../dep-install"),c=require("../../../tools/posh"),u=require("../../locker"),p=require("../util/isInnerPkgDependency"),h=require("../../override-dependency-map/OverrideDepMapManager"),y=require("../../../common/message"),f=require("../../../util/FsUtil"),v=require("../../../tools/ohpa/OhpaType"),g=require("../../../config"),T=require("../../version-conflict/VersionConflictManager"),m=require("../../version-conflict/impl/VersionStrictModeStrategy"),D=require("../../install-targets/ProjectBuildProfile");exports.AsyncTreeBuilder=class{constructor(e){this.tree=void 0,this.builderType=(null==e?void 0:e.builderType)||l.BuilderType.ToBeInstalled,this.faultCallBack=null==e?void 0:e.faultCallback,this.resolveVersionConflict=null==e?void 0:e.resolveConflict,g.config.get(g.types.RESOLVE_CONFLICT_STRICT)&&T.VersionConflictManager.getInstance().setVerConflictStrategy(new m.VersionStrictModeStrategy)}reset(){this.tree=void 0}getResult(){const e=this.tree;return this.reset(),e}build(r,t,n=1/0){return e(this,void 0,void 0,(function*(){this.tree=new i.DependencyTree(r,t,this.resolveVersionConflict),yield this.buildChildren(t,-1,n)}))}buildChildren(r,i,o=1/0){return e(this,void 0,void 0,(function*(){const d=t.ConcurrentExecutor.creatInstance(),s=r.name,c=r.pinnedSpec,p=(r,i)=>e(this,void 0,void 0,(function*(){var e;if(!r.isRoot&&s===r.name)throw n.default.error("Invalid dependency",`${r.name}@${r.pinnedSpec} -> ${s}@${c}`),new Error(y.Messages.DepBuilder.InvalidDependency);if(r.unmet&&this.builderType===l.BuilderType.ToBeInstalled)throw r.fault&&n.default.error("",r.fault),r.nodeData.error?r.nodeData.error:new Error("DependencyNode build failed.");if(!(i>o||(null===(e=this.tree)||void 0===e?void 0:e.findNode(r.name,r.fetchSpec))))if(r.nodeData.innerAddressChain&&u.PackageLockerManager.getInstance().registryInnerNode(r),(0,a.isNeedChildren)(r)){r.isRoot||this.builderType!==l.BuilderType.ToBeInstalled||(yield this.installNativeDependency(r.requirements,r)),this.tree.registerNode(r);for(const e of Object.keys(r.requirements))this.addChildBuildTask({childName:e,curNode:r,executor:d,curDepth:i,dfs:p})}else this.tree.registerNode(r)}));d.addAsyncTask((()=>p(r,i))),yield d.runWithErrorHandle()}))}addChildBuildTask(r){const{childName:i,curNode:t,executor:n,curDepth:d,dfs:a}=r,l=(0,o.resolveSpecWithOverrides)(this.tree.moduleRootDir,i,t.requirements),s=t.isRoot?t.requirements[i].depType:t.depType;n.addAsyncTask((()=>e(this,void 0,void 0,(function*(){const e=yield this.createChildNode({depth:d+1,childName:i,childSpec:l,depType:s,parent:t});e&&(yield a(e,d+1))}))))}createChildNode(r){return e(this,void 0,void 0,(function*(){const e=this.tree,i=e.whereToFindChildNode(r.childSpec,r.parent),t=u.PackageLockerManager.getInstance(),n=yield t.getDepNodeData({depType:r.depType,name:r.childName,builderType:this.builderType,rootDir:e.moduleRootDir,pkg:`${r.childName}@${r.childSpec}`,where:i,parentSaveRoot:r.parent.resolveSaveRootDir(e.moduleRootDir),isLink:r.parent.isLink,isShared:r.parent.isShared}),o=yield h.OverrideDepMapManager.getInstance().getConfig(n.name,n.pinnedSpec,n.fetchSpec,n.pkgStoreDir),a=new d.DependencyNode(n,r.depType,o);if(this.needResolveInnerPkg(r.childSpec,a,r.parent)){const e=0===r.parent.innerAddressChain.length?[r.parent]:r.parent.innerAddressChain;a.nodeData.innerAddressChain=[...e,a]}return this.handleFaultyNode(a,r.parent,r.depth-1),a}))}needResolveInnerPkg(e,r,i){if(!(r.ohpaType===v.OhpaType.File&&(0,p.isInnerPkgDependency)(e)))return!1;const t=i.nodeData.pkgStoreDir;return!(i.ohpaType===v.OhpaType.SourceCode&&(i.isNativeSoType||g.config.getProjectRoot()===t||D.projectBuildProfile.isModuleRoot(t)))}handleFaultyNode(e,r,i){e.unmet&&(e.fault=`missing: ${e.name}@${e.fetchSpec}, required by ${r.nodeKey}`,this.faultCallBack&&this.faultCallBack(e.fault,i),e.prefixLabel=`${c.posh.red.bgBlack("UNMET DEPENDENCY")} `)}installNativeDependency(r,i){return e(this,void 0,void 0,(function*(){const e=this.tree;for(const t of Object.keys(r)){const d=(0,o.resolveSpecWithOverrides)(e.moduleRootDir,t,r);if(d&&(0,a.isLocalDependency)(d)&&(0,p.isInnerPkgDependency)(d)&&!(yield(0,a.checkAndRemoveOldLocalPkg)(e.moduleRootDir,i))){if(n.default.debug("InstallNativePkg",`found native dependency. install parent: ${i.name}@${i.pinnedSpec}`),yield(0,s.installDependency)(e.moduleRootDir,i),i.ohpaType===v.OhpaType.File){const e=yield f.FsUtil.readModifyTime(i.pinnedSpec);u.PackageLockerManager.getInstance().updateGlobalMtimeCacheAfterInstallation(i.pinnedSpec,e)}break}}}))}};