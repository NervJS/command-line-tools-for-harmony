"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DependencyTree=void 0;const e=require("../util"),t=require("../../overrides"),o=require("../../../tools/ohpa/OhpaType"),i=require("../../../common/message"),s=require("../../version-conflict/VersionConflictManager");exports.DependencyTree=class{constructor(e,t,o){this.versionsMap=new Map,this._finalDepNodeCache=new Map,this.fetchSpecMap=new Map,this.maxSatisfyingVersionCache=new Map,this._nativeSoTypeNodeCache=new Map,this._roughDepCache=new Map,this._root=t,this._moduleRootDir=e,this._isResolveConflict=!!o}get root(){return this._root}get moduleRootDir(){return this._moduleRootDir}get finalDepList(){return Array.from(this._finalDepNodeCache.values())}get roughDepList(){const e=Array.from(this._roughDepCache.values()),t=[];return e.forEach((e=>{t.push(...Object.values(e))})),t}flatTree(){return this._isResolveConflict?[...this.finalDepList,...this._nativeSoTypeNodeCache.values()]:this.roughDepList}registerNode(e){this.addNode(e),e.isNativeSoType||(this.updateMaxSatisfyingVersionMap(e.name,e),this.collectFetchSpecs(e.name,e.fetchSpec),this.collectPkgVersions(e.name,e.pinnedSpec))}findNode(e,t){const o=this._roughDepCache.get(e);if(o)return o[t]}whereToFindChildNode(t,i){return(0,e.isLocalDependency)(t)?i.isLink||i.ohpaType!==o.OhpaType.SourceCode?i.resolvePkgStoreDir(this.moduleRootDir):i.fetchSpec:i.resolveSaveRootDir(this.moduleRootDir)}pickNode(o,s,r){s=(0,t.resolveSpecWithOverrides)(this.moduleRootDir,o,r.requirements);const a=this.whereToFindChildNode(s,r),h=(0,e.parseDependency)(`${o}@${s}`,a);let n;if(this._nativeSoTypeNodeCache.has(h.getFetchSpec())&&(n=this._nativeSoTypeNodeCache.get(h.getFetchSpec())),!n&&this._isResolveConflict)n=this._finalDepNodeCache.get(o);else if(!n){const e=this._roughDepCache.get(o);e&&(n=e[h.getFetchSpec()])}if(!n)throw new Error((0,i.format)(i.Messages.Common.DepNodeNotFound,{name:o,fetchSpec:s}));return n}pickMaxVersion(e){const t=this._finalDepNodeCache.get(e);if(!t)throw new Error((0,i.format)(i.Messages.Common.DepNodeMaxVersionNotFound,{name:e}));return t}pickRoughNode(o,s,r){s=(0,t.resolveSpecWithOverrides)(this.moduleRootDir,o,r.requirements);const a=this.whereToFindChildNode(s,r),h=(0,e.parseDependency)(`${o}@${s}`,a),n=this._roughDepCache.get(o);if(n)return n[h.getFetchSpec()];throw new Error((0,i.format)(i.Messages.Common.RoughDepNodeNotFound,{name:o,fetchSpec:s}))}updateMaxSatisfyingVersionMap(e,t){s.VersionConflictManager.getInstance().isMaxSatisfying(t.nodeData,this.maxSatisfyingVersionCache,this.fetchSpecMap)&&(this._finalDepNodeCache.set(e,t),this.maxSatisfyingVersionCache.set(e,t.nodeData))}collectFetchSpecs(e,o){this.fetchSpecMap.has(e)||this.fetchSpecMap.set(e,new Set);const i=t.overridesMap.get(e);this.fetchSpecMap.get(e).add(null!=i?i:o)}getVersionSet(e){return this.versionsMap.get(e)}collectPkgVersions(e,t){this.versionsMap.has(e)||this.versionsMap.set(e,new Set),this.versionsMap.get(e).add(t)}addNode(e){let t=this._roughDepCache.get(e.name);t?t[e.fetchSpec]=e:(t={[e.fetchSpec]:e},this._roughDepCache.set(e.name,t)),e.isNativeSoType&&this._nativeSoTypeNodeCache.set(e.fetchSpec,e)}};