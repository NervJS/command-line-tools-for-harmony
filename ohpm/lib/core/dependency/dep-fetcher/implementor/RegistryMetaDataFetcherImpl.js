"use strict";var e=this&&this.__awaiter||function(e,t,r,s){return new(r||(r=Promise))((function(i,o){function n(e){try{c(s.next(e))}catch(e){o(e)}}function a(e){try{c(s.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(n,a)}c((s=s.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.RegistryMetaDataFetcherImpl=void 0;const r=require("../../../registry/registry"),s=t(require("../../../../log")),i=require("../../../registry/OhpmRequestInit"),o=require("../../../registry"),n=t(require("node-fetch")),a=require("../../../../common/ohpm.config"),c=require("../../../../common/Constants"),h=require("../../util"),g=require("../../../../common/message"),u=require("../../../../common/GlobalState"),l=require("../../util/getRedirectUrlFromResponse");exports.RegistryMetaDataFetcherImpl=class{constructor(){this.registryMap=new Map,this.fetchResultMap=new Map,this.memoizeFetchByRegistry=(t,r,s)=>e(this,void 0,void 0,(function*(){const e=`${t}@${s}`;let i=this.fetchResultMap.get(e);return i||(i=yield this.realMetadataFetch(t,r,s),this.fetchResultMap.set(e,i),i)}))}fetch(t){return e(this,void 0,void 0,(function*(){const e=yield this.fetchMetaDataFromRegistry(t.name,t.fetchSpec),r=e.versions,s=Object.keys(r);let i;return i=(0,h.isTagDependency)(t.fetchSpec)?(0,h.getVersionByDistTags)(t.fetchSpec,e):(0,h.semverMaxSatisfying)(s,t.fetchSpec),null!==i&&(u.GlobalState.installMode.includes(u.ExperimentalOption.NO_CHECK_REGISTRY)||this.checkRegistry(t.name,i,{versions:r},e.responsePkgType)),{name:t.name,versions:r,packageType:e.packageType,registryType:e.registryType,isFromLockFile:!1,distTags:e["dist-tags"]}}))}fetchMetaDataFromRegistry(t,i){return e(this,void 0,void 0,(function*(){const e=(0,r.getRegistryList)(t);if(0===e.length)throw s.default.error("",'The install registry is not set, please edit .ohpmrc file or use "ohpm config set registry https://ohpm.openharmony.cn/ohpm/" command to set the install registry.'),new Error((0,g.format)(g.Messages.Fetcher.Registry.FetchPkgInfoFailed,{pkgName:t}));for(const o of e){const e=yield this.memoizeFetchByRegistry(t,i,o);if(e&&e.versions&&((0,h.semverMaxSatisfying)(Object.keys(e.versions),i)||(0,h.getVersionByDistTags)(i,e)))return this.registryMap.set(t,o),s.default.info(`fetch meta info of package '${t}' success`,`${o}${t}`),e.registryType=a.PmConfig.registryWhiteList.includes(o)?r.RegistryType.npm:r.RegistryType.ohpm,e;s.default.debug(`fetch meta info of package '${t}' success, but version '${i}' not exist`,`${o}${t}`)}throw s.default.error("NOTFOUND",`package '${t}@${i}' not found from all the registries ${e.join(", ")}`),new Error((0,g.format)(g.Messages.Fetcher.Registry.FetchPkgInfoFailed,{pkgName:t}))}))}realMetadataFetch(t,a,c){return e(this,void 0,void 0,(function*(){const e=yield(0,o.getAuth)(c),h=`${c}${t}`;try{s.default.info("MetaDataFetcher",`fetching meta info of package '${t}' from ${c}`);const g=(new i.OhpmRequestInit).withAgent((0,o.getProxyAgent)(c)).withTimeout((0,r.getFetchTimeout)()).withRedirect("manual");e&&g.withHeaders({Authorization:e});let u=yield(0,n.default)(h,g);const d=(0,l.getRedirectUrlFromResponse)(u);return d&&(u=yield this.redirectFetch(t,d)),yield this.handleResponse(t,a,c,u)}catch(e){this.handleException(t,c,e)}}))}redirectFetch(t,s){return e(this,void 0,void 0,(function*(){const e=(0,r.getAvailableAuthByUrl)(s),a=(new i.OhpmRequestInit).withAgent((0,o.getProxyAgent)(s)).withTimeout((0,r.getFetchTimeout)());return e&&a.withHeaders({Authorization:e}),(0,n.default)(`${s}${t}`,a)}))}handleResponse(t,r,i,o){return e(this,void 0,void 0,(function*(){if(!o.ok){const e=yield this.getErrorMsgFromResponse(o);return void s.default.warn(`fetch meta info of package '${t}' failed`,`- GET ${i}${t} ${o.status}( ${e} )`)}const e=yield o.json();return e.responsePkgType=o.headers.get("package-type"),e}))}getErrorMsgFromResponse(t){return e(this,void 0,void 0,(function*(){let e={};try{e=yield t.json()}catch(e){return t.statusText}if(Array.isArray(e.error)||Array.isArray(e.errors)){const t=[];return(e.error||e.errors).forEach((e=>{t.push(e.message)})),t.join(",")}return e.error}))}handleException(e,t,r){if(r.errno=c.Constants.ERR_TYPE_MAP[r.type]?c.Constants.ERR_TYPE_MAP[r.type]:r.errno,c.Constants.ERRNO_RETRY_LIST.includes(r.errno))throw s.default.error(r.errno,`${this.paddingRetryErrorMsg(r.message,t)}`),r;if(c.Constants.ERRNO_EXIT_LIST.includes(r.errno))throw s.default.error(r.errno,`${this.paddingSslErrorMsg(r.message)}`),r;const i=r.message;if(i&&i.toLowerCase().includes(c.Constants.TAGTIMEOUT)){const e=new Error(i);throw e.errno=c.Constants.ERRORTIMEOUT,s.default.error(r.errno,`${this.paddingRetryErrorMsg(r.message,t)}`),e}s.default.warn(r.errno,`exception found while fetch package "${e}" from "${t}", exception: ${r.message}`)}checkRegistry(e,t,r,s){const i=r.versions[t];if(i&&!i._ohpmVersion&&"ohpm"!==s){const t=this.registryMap.get(e);if(t&&!a.PmConfig.registryWhiteList.includes(t))throw new Error((0,g.format)(g.Messages.Fetcher.Registry.CheckRegistryFailed,{registry:t}))}}paddingRetryErrorMsg(e,t){return`${e}, please check the network connectivity to the registry ${t}`}paddingSslErrorMsg(e){return`${e}, did not configure "ca_files" in ".ohpmrc" or configured "ca_files" incorrectly.`}};