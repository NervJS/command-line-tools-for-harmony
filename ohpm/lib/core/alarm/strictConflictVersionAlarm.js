"use strict";var e=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.strictConflictVersionAlarm=void 0;const o=require("../locker"),r=e(require("../../log")),t=require("../../common/message"),n=require("../../tools/posh"),s="Found version conflict(s) in dependencies of project";function a(e,o,t){t?r.default.error("",`dependency "${e.packageName}" has conflict versions: "${Array.from(e.versionSet).sort().join('", "')}" and we can not resolve these conflicts, the affected modules are as follows:\n\t - "${Array.from(e.whichModules).sort().join('"\n\t - "')}"\n`):r.default.warn("",`dependency "${e.packageName}" has conflict versions: "${Array.from(e.versionSet).sort().join('", "')}",`+(o?` and has been resolved as "${e.resolvedVersion}",`:"")+" the affected modules are as follows:\n"+`\t - "${Array.from(e.whichModules).sort().join('"\n\t - "')}"\n`)}function i(e,o,r,t,n){if(e.isRoot)return;if(e.isNativeSoType)return;const s=o.getFetchSpecSet(e.name);let a;if(s.size>1)if(r.has(e.name))a=r.get(e.name),a.whichModules.add(t.moduleRootDir);else if(n()){const n=o.getMaxSatisfyingVersionData(e.name);a={packageName:e.name,whichModules:new Set([t.moduleRootDir]),versionSet:s,resolvedVersion:n.pinnedSpec},r.set(e.name,a)}}exports.strictConflictVersionAlarm=function(e){const l=new Map,c=new Map;return{recordData:c,recordConflictMessage:e=>{const r=o.PackageLockerManager.getInstance();e.roughDepList.forEach((o=>{i(o,r,l,e,(()=>!0)),i(o,r,c,e,(()=>r.hasResolveFailedDepName(o.name)))}))},alarmConflictMessage:o=>{!function(e,o,i,l){if(e){if(o.size>0)throw r.default.error("",s),o.forEach((o=>a(o,!1,e))),new Error((0,t.format)(t.Messages.DepBuilder.BuildFailure))}else{let e=s;i&&(e=`${s}, and we have helped you resolve it automatically.`),l.size>0&&(r.default.log("warn",`${n.posh.bold.bgBlack.yellowBright(e)}`),l.forEach((e=>a(e,i))))}}(o,c,e,l)}}};