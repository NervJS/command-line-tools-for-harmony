"use strict";var e=this&&this.__awaiter||function(e,t,r,s){return new(r||(r=Promise))((function(n,i){function o(e){try{u(s.next(e))}catch(e){i(e)}}function a(e){try{u(s.throw(e))}catch(e){i(e)}}function u(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(o,a)}u((s=s.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.ConcurrentExecutor=exports.RETRY_INTERVAL_MAX=exports.RETRY_INTERVAL_MIN=exports.RETRY_TIMES_MAX=exports.RETRY_TIMES_MIN=exports.MAX_CONCURRENT_MAX=exports.MAX_CONCURRENT_MIN=void 0;const r=require("../common/message"),s=t(require("../log")),n=require("../config"),i=require("../config/DefaultConfig"),o=require("../common/Constants"),a=require("../core/scripts/Queue"),u=require("./ExecutorResult");exports.MAX_CONCURRENT_MIN=1,exports.MAX_CONCURRENT_MAX=200,exports.RETRY_TIMES_MIN=0,exports.RETRY_TIMES_MAX=5,exports.RETRY_INTERVAL_MIN=1e3,exports.RETRY_INTERVAL_MAX=6e4;const c=/^\d+$/;class R{constructor(){this.taskQueue=new a.Queue(null),this.executingTasks=[],this.executorRunning=!1,this.retry=(t,r=this.getRetryTimes(),n=this.getRetryInterval())=>{let i=r;const a=this.getTaskName(t),u=function(){return e(this,void 0,void 0,(function*(){try{return yield t()}catch(e){if(i<=0||!o.Constants.ERRNO_RETRY_LIST.includes(e.errno))throw s.default.error("",`Found exception: ${e}, reached retry limit or non retryable error encountered.`),e;return s.default.debug("Executor",`${a} execute failed: ${e}, will retry after ${n} ms with ${i} retries remaining.`),i-=1,yield new Promise((e=>setTimeout(e,n))),u()}}))};return u}}static creatInstance(){return new R}addAsyncTask(e){this.taskQueue.push(e)}run(t=this.getMaxConcurrent(),r=this.getRetryTimes(),n=this.getRetryInterval(),i=!1){return e(this,void 0,void 0,(function*(){const e=new u.ExecutorResult;if(this.executorRunning)return e.addExtraError("the executor is running!");if(this.taskQueue.isEmpty())return e;if(!this.executorParamValid(t,r,n,e))return e;this.resetExecutor(),s.default.debug("Executor",`Running [max_concurrent:${t}, retry_times:${r}, retry_interval:${n}]`);const o=(new Date).getTime();for(;;){if(!i&&e.getRejects().length>0){s.default.debug("Executor","found task execute failed, exit process!");break}const o=this.taskQueue.pop();if(!o&&0===this.executingTasks.length){s.default.debug("Executor","all task execute finished.");break}if(o){const t=this.retry(o,r,n)().then((t=>{e.addResolve(t)})).catch((t=>{e.addReject(t)})).finally((()=>this.executingTasks.splice(this.executingTasks.indexOf(t),1)));this.executingTasks.push(t)}(this.executingTasks.length>=t||!o)&&(yield Promise.race(this.executingTasks))}return this.executorRunning=!1,this.printCostTime(o,"Run"),e}))}runWithErrorHandle(t,r,s,n=!1){return e(this,void 0,void 0,(function*(){const e=yield this.run(t,r,s,n);e.isSuccess()||this.handleError(e)}))}handleError(e){const t=[];e.getExtraErrors().length&&e.getExtraErrors().forEach((e=>{t.push(e)})),e.getRejects().length&&e.getRejects().forEach((e=>{t.push(e)}));const r=t.toString();throw s.default.debug("ERUNNING",`execute tasks failed, ${r}`),r}getMaxConcurrent(){const e=n.config.get(n.types.MAX_CONCURRENT);return void 0===e?i.defaultConfig.max_concurrent:e}getRetryTimes(){const e=n.config.get(n.types.RETRY_TIMES);return void 0===e?i.defaultConfig.retry_times:e}getRetryInterval(){const e=n.config.get(n.types.RETRY_INTERVAL);return void 0===e?i.defaultConfig.retry_interval:e}resetExecutor(){this.executorRunning=!0,this.executingTasks=[]}getTaskName(e){return e.toString().replace("()","").replace("=>","").replace(/\s+/,"")}executorParamValid(e,t,r,s){return!!this.checkMaxConcurrent(e,s)&&(!!this.checkRetryTimes(t,s)&&this.checkRetryInterval(r,s))}checkMaxConcurrent(e,t){return!!this.isNumValid(e,exports.MAX_CONCURRENT_MIN,exports.MAX_CONCURRENT_MAX)||(t.addExtraError((0,r.format)(r.Messages.Limit.NumberInvalid,{paramName:"max_concurrent",min:`${exports.MAX_CONCURRENT_MIN}`,max:`${exports.MAX_CONCURRENT_MAX}`})),!1)}checkRetryTimes(e,t){return!!this.isNumValid(e,exports.RETRY_TIMES_MIN,exports.RETRY_TIMES_MAX)||(t.addExtraError((0,r.format)(r.Messages.Limit.NumberInvalid,{paramName:"retry_times",min:`${exports.RETRY_TIMES_MIN}`,max:`${exports.RETRY_TIMES_MAX}`})),!1)}checkRetryInterval(e,t){return!!this.isNumValid(e,exports.RETRY_INTERVAL_MIN,exports.RETRY_INTERVAL_MAX)||(t.addExtraError((0,r.format)(r.Messages.Limit.NumberInvalid,{paramName:"retry_interval",min:`${exports.RETRY_INTERVAL_MIN}`,max:`${exports.RETRY_INTERVAL_MAX}`})),!1)}checkTask(e){if(!e)throw new Error((0,r.format)(r.Messages.Limit.FnInvalid,{paramName:"task"}))}checkTasks(e){if(!e)throw new Error((0,r.format)(r.Messages.Limit.TaskArrInvalid,{paramName:"tasks"}))}isNumValid(e,t,r){return c.test(e)&&e>=t&&e<=r}printCostTime(e,t){const r=(new Date).getTime()-e,n=Math.floor(r/1e3),i=r%1e3,o=t?`${t}`:"";s.default.debug("Executor",`${o} completed in ${n}s ${i}ms`)}}exports.ConcurrentExecutor=R;