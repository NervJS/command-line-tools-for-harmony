"use strict";
/*
 * Copyright (c) 2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArkObfuscatorForTest = void 0;
const ArkObfuscator_1 = require("./ArkObfuscator");
const ApiReaderForTest_1 = require("./common/ApiReaderForTest");
const FileUtils_1 = require("./utils/FileUtils");
const PrinterUtils_1 = require("./utils/PrinterUtils");
const TransformUtil_1 = require("./utils/TransformUtil");
const NameCacheUtil_1 = require("./utils/NameCacheUtil");
const fs = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const ingoreTest262List_json_1 = __importDefault(require("./configs/ingoreFilenameList/ingoreTest262List.json"));
const ingoreCompilerTestList_json_1 = __importDefault(require("./configs/ingoreFilenameList/ingoreCompilerTestList.json"));
const CommonCollections_1 = require("./utils/CommonCollections");
const CommonObject_1 = require("./initialization/CommonObject");
const ConfigResolver_1 = require("./initialization/ConfigResolver");
const utils_1 = require("./initialization/utils");
const JSON_TEXT_INDENT_LENGTH = 2;
class ArkObfuscatorForTest extends ArkObfuscator_1.ArkObfuscator {
    constructor(sourceFiles, configPath) {
        super();
        this.mTestType = undefined;
        this.mSourceFiles = sourceFiles;
        this.mConfigPath = configPath;
    }
    get configPath() {
        return this.mConfigPath;
    }
    setTestType(testType) {
        this.mTestType = testType;
    }
    /**
     * init ArkObfuscator according to user config
     * should be called after constructor
     */
    init(config) {
        var _a;
        if (!config) {
            console.error('obfuscation config file is not found and no given config.');
            return false;
        }
        CommonCollections_1.UnobfuscationCollections.printKeptName = (_a = config.mUnobfuscationOption) === null || _a === void 0 ? void 0 : _a.mPrintKeptNames;
        (0, TransformUtil_1.handleReservedConfig)(config, 'mNameObfuscation', 'mReservedProperties', 'mUniversalReservedProperties');
        (0, TransformUtil_1.handleReservedConfig)(config, 'mNameObfuscation', 'mReservedToplevelNames', 'mUniversalReservedToplevelNames');
        return super.init(config);
    }
    /**
     * Obfuscate all the source files.
     */
    obfuscateFiles() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!path_1.default.isAbsolute(this.mCustomProfiles.mOutputDir)) {
                this.mCustomProfiles.mOutputDir = path_1.default.join(path_1.default.dirname(this.mConfigPath), this.mCustomProfiles.mOutputDir);
            }
            (0, PrinterUtils_1.startFilesEvent)(PrinterUtils_1.EventList.ALL_FILES_OBFUSCATION);
            (0, ApiReaderForTest_1.readProjectProperties)(this.mSourceFiles, structuredClone(this.mCustomProfiles), this);
            const propertyCachePath = path_1.default.join(this.mCustomProfiles.mOutputDir, path_1.default.basename(this.mSourceFiles[0])); // Get dir name
            this.readPropertyCache(propertyCachePath);
            // support directory and file obfuscate
            for (const sourcePath of this.mSourceFiles) {
                if (!fs.existsSync(sourcePath)) {
                    console.error(`File ${FileUtils_1.FileUtils.getFileName(sourcePath)} is not found.`);
                    return;
                }
                if (fs.lstatSync(sourcePath).isFile()) {
                    yield this.obfuscateFile(sourcePath, this.mCustomProfiles.mOutputDir);
                    continue;
                }
                const dirPrefix = FileUtils_1.FileUtils.getPrefix(sourcePath);
                yield this.obfuscateDir(sourcePath, dirPrefix);
            }
            if ((_a = this.mCustomProfiles.mUnobfuscationOption) === null || _a === void 0 ? void 0 : _a.mPrintKeptNames) {
                const dir = path_1.default.dirname(this.mSourceFiles[0]).replace('grammar', 'local');
                const basename = path_1.default.basename(this.mSourceFiles[0]);
                let printKeptNamesPath = path_1.default.join(dir, basename, '/keptNames.unobf.json');
                let printWhitelistPath = path_1.default.join(dir, basename, '/whitelist.unobf.json');
                this.writeUnobfuscationContentForTest(printKeptNamesPath, printWhitelistPath);
            }
            this.producePropertyCache(propertyCachePath);
            (0, PrinterUtils_1.printTimeSumInfo)('All files obfuscation:');
            (0, PrinterUtils_1.printTimeSumData)();
            (0, PrinterUtils_1.endFilesEvent)(PrinterUtils_1.EventList.ALL_FILES_OBFUSCATION);
        });
    }
    writeUnobfuscationContentForTest(printKeptNamesPath, printWhitelistPath) {
        (0, ConfigResolver_1.printUnobfuscationReasons)('', printKeptNamesPath);
        this.printWhitelist(this.mCustomProfiles, printWhitelistPath);
    }
    printWhitelist(obfuscationOptions, printPath) {
        var _a, _b;
        const nameOption = obfuscationOptions.mNameObfuscation;
        const enableToplevel = nameOption.mTopLevel;
        const enableProperty = nameOption.mRenameProperties;
        const enableStringProp = !nameOption.mKeepStringProperty;
        const enableExport = obfuscationOptions.mExportObfuscation;
        const reservedConfToplevelArrary = (_a = nameOption.mReservedToplevelNames) !== null && _a !== void 0 ? _a : [];
        const reservedConfPropertyArray = (_b = nameOption.mReservedProperties) !== null && _b !== void 0 ? _b : [];
        let whitelistObj = {
            lang: [],
            conf: [],
            struct: [],
            exported: [],
            strProp: []
        };
        if (enableExport || enableProperty) {
            const languageSet = (0, utils_1.mergeSet)(CommonCollections_1.UnobfuscationCollections.reservedLangForProperty, CommonCollections_1.UnobfuscationCollections.reservedLangForTopLevel);
            whitelistObj.lang = (0, utils_1.convertSetToArray)(languageSet);
            const strutSet = CommonCollections_1.UnobfuscationCollections.reservedStruct;
            whitelistObj.struct = (0, utils_1.convertSetToArray)(strutSet);
            const exportSet = (0, utils_1.mergeSet)(CommonCollections_1.UnobfuscationCollections.reservedExportName, CommonCollections_1.UnobfuscationCollections.reservedExportNameAndProp);
            whitelistObj.exported = (0, utils_1.convertSetToArray)(exportSet);
            if (!enableStringProp) {
                const stringSet = CommonCollections_1.UnobfuscationCollections.reservedStrProp;
                whitelistObj.strProp = (0, utils_1.convertSetToArray)(stringSet);
            }
        }
        const hasPropertyConfig = enableProperty && (reservedConfPropertyArray === null || reservedConfPropertyArray === void 0 ? void 0 : reservedConfPropertyArray.length) > 0;
        const hasTopLevelConfig = enableToplevel && (reservedConfToplevelArrary === null || reservedConfToplevelArrary === void 0 ? void 0 : reservedConfToplevelArrary.length) > 0;
        if (hasPropertyConfig) {
            // if -enable-property-obfuscation and -enable-toplevel-obfuscation,
            // the mReservedToplevelNames has already been merged into the mReservedToplevelNames.
            whitelistObj.conf.push(...reservedConfPropertyArray);
            this.handleUniversalReservedList(nameOption.mUniversalReservedProperties, whitelistObj.conf);
        }
        else if (hasTopLevelConfig) {
            whitelistObj.conf.push(...reservedConfToplevelArrary);
            this.handleUniversalReservedList(nameOption.mUniversalReservedToplevelNames, whitelistObj.conf);
        }
        let whitelistContent = JSON.stringify(whitelistObj, null, 2);
        if (!fs.existsSync(path_1.default.dirname(printPath))) {
            fs.mkdirSync(path_1.default.dirname(printPath), { recursive: true });
        }
        fs.writeFileSync(printPath, whitelistContent);
    }
    handleUniversalReservedList(universalList, configArray) {
        if ((universalList === null || universalList === void 0 ? void 0 : universalList.length) > 0) {
            universalList.forEach((value) => {
                const originalString = CommonCollections_1.UnobfuscationCollections.reservedWildcardMap.get(value);
                if (originalString) {
                    configArray.push(originalString);
                }
            });
        }
    }
    /**
     * obfuscate directory
     * @private
     */
    obfuscateDir(dirName, dirPrefix) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const currentDir = FileUtils_1.FileUtils.getPathWithoutPrefix(dirName, dirPrefix);
            let newDir = this.mCustomProfiles.mOutputDir;
            // there is no need to create directory because the directory names will be obfuscated.
            if (!((_a = this.mCustomProfiles.mRenameFileName) === null || _a === void 0 ? void 0 : _a.mEnable)) {
                newDir = path_1.default.join(this.mCustomProfiles.mOutputDir, currentDir);
            }
            const fileNames = fs.readdirSync(dirName);
            for (let fileName of fileNames) {
                const filePath = path_1.default.join(dirName, fileName);
                if (fs.lstatSync(filePath).isFile()) {
                    yield this.obfuscateFile(filePath, newDir);
                    continue;
                }
                yield this.obfuscateDir(filePath, dirPrefix);
            }
        });
    }
    /**
     * Obfuscate single source file with path provided
     *
     * @param sourceFilePath single source file path
     * @param outputDir
     */
    obfuscateFile(sourceFilePath, outputDir) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const fileName = FileUtils_1.FileUtils.getFileName(sourceFilePath);
            const config = this.mCustomProfiles;
            if (this.isObfsIgnoreFile(fileName)) {
                fs.mkdirSync(outputDir, { recursive: true });
                fs.copyFileSync(sourceFilePath, path_1.default.join(outputDir, fileName));
                return;
            }
            // To skip the path where 262 and compiler test will fail.
            if (this.shouldIgnoreFile(sourceFilePath)) {
                return;
            }
            // Add the whitelist of file name obfuscation for ut.
            if ((_a = config.mRenameFileName) === null || _a === void 0 ? void 0 : _a.mEnable) {
                const reservedArray = config.mRenameFileName.mReservedFileNames;
                FileUtils_1.FileUtils.collectPathReservedString(this.mConfigPath, reservedArray);
            }
            let content = FileUtils_1.FileUtils.readFile(sourceFilePath);
            this.readNameCache(sourceFilePath, outputDir);
            (0, PrinterUtils_1.startFilesEvent)(sourceFilePath);
            let filePath = { buildFilePath: sourceFilePath, relativeFilePath: sourceFilePath };
            (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.OBFUSCATE, ArkObfuscator_1.performancePrinter.timeSumPrinter, sourceFilePath);
            const mixedInfo = yield this.obfuscate(content, filePath);
            (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.OBFUSCATE, ArkObfuscator_1.performancePrinter.timeSumPrinter);
            (0, PrinterUtils_1.endFilesEvent)(sourceFilePath, undefined, true);
            if (this.mWriteOriginalFile && mixedInfo) {
                // Write the obfuscated content directly to orignal file.
                fs.writeFileSync(sourceFilePath, mixedInfo.content);
                return;
            }
            if (outputDir && mixedInfo) {
                const outputPathObj = this.getOutputPath(sourceFilePath, mixedInfo);
                this.writeContent(outputPathObj.outputPath, outputPathObj.relativePath, mixedInfo);
            }
        });
    }
    getOutputPath(sourceFilePath, mixedInfo) {
        var _a;
        const config = this.mCustomProfiles;
        if (this.mTestType === 'grammar') {
            const testCasesRootPath = path_1.default.join(__dirname, '../', 'test/grammar');
            let relativePath = '';
            if (((_a = config.mRenameFileName) === null || _a === void 0 ? void 0 : _a.mEnable) && mixedInfo.filePath) {
                relativePath = mixedInfo.filePath.replace(testCasesRootPath, '');
            }
            else {
                relativePath = sourceFilePath.replace(testCasesRootPath, '');
            }
            const resultPath = path_1.default.join(config.mOutputDir, relativePath);
            return { outputPath: resultPath, relativePath: relativePath };
        }
        else if (this.mTestType === 'combinations') {
            const outputDir = this.mCustomProfiles.mOutputDir;
            const directory = outputDir.substring(0, outputDir.lastIndexOf('/') + 1);
            const sourceBaseDir = directory.replace('local/combinations', 'combinations');
            const relativePath = sourceFilePath.replace(sourceBaseDir, '');
            const resultPath = path_1.default.join(this.mCustomProfiles.mOutputDir, relativePath);
            return { outputPath: resultPath, relativePath: relativePath };
        }
        else {
            throw new Error('Please select a test type');
        }
    }
    writeContent(outputPath, relativePath, mixedInfo) {
        if (!fs.existsSync(path_1.default.dirname(outputPath))) {
            fs.mkdirSync(path_1.default.dirname(outputPath), { recursive: true });
        }
        fs.writeFileSync(outputPath, mixedInfo.content);
        if (this.mCustomProfiles.mEnableSourceMap && mixedInfo.sourceMap) {
            fs.writeFileSync(path_1.default.join(outputPath + '.map'), JSON.stringify(mixedInfo.sourceMap, null, JSON_TEXT_INDENT_LENGTH));
        }
        if (this.mCustomProfiles.mEnableNameCache && this.mCustomProfiles.mEnableNameCache) {
            this.produceNameCache(mixedInfo.nameCache, outputPath);
        }
        if (mixedInfo.unobfuscationNameMap) {
            this.loadunobfuscationNameMap(mixedInfo, relativePath);
        }
    }
    loadunobfuscationNameMap(mixedInfo, relativePath) {
        let arrayObject = {};
        // The type of unobfuscationNameMap's value is Set, convert Set to Array.
        mixedInfo.unobfuscationNameMap.forEach((value, key) => {
            let array = Array.from(value);
            arrayObject[key] = array;
        });
        CommonObject_1.unobfuscationNamesObj[relativePath] = arrayObject;
    }
    shouldIgnoreFile(sourceFilePath) {
        const isIgnored = (path, ignoreList) => ignoreList.includes(path);
        // 1: Relative path of the first-level directory after '.local'
        const compilerTestFilename = this.getPathAfterDirectory(sourceFilePath, '.local', 1);
        if (isIgnored(compilerTestFilename, ingoreCompilerTestList_json_1.default)) {
            return true;
        }
        // 2: Relative path of the second-level directory after 'test262'
        const test262Filename = this.getPathAfterDirectory(sourceFilePath, 'test262', 2);
        return isIgnored(test262Filename, ingoreTest262List_json_1.default);
    }
    getPathAfterDirectory(fullPath, directory, level) {
        const pathParts = fullPath.split('/');
        const dataIndex = pathParts.indexOf(directory);
        // -1: The directory name does not exist in the absolute path
        const targetIndex = dataIndex !== -1 ? dataIndex + level : -1;
        if (targetIndex < pathParts.length) {
            return pathParts.slice(targetIndex).join('/');
        }
        return fullPath;
    }
    produceNameCache(namecache, resultPath) {
        const nameCachePath = resultPath + NameCacheUtil_1.NAME_CACHE_SUFFIX;
        fs.writeFileSync(nameCachePath, JSON.stringify(namecache, null, JSON_TEXT_INDENT_LENGTH));
    }
    readNameCache(sourceFile, outputDir) {
        var _a;
        if (!((_a = this.mCustomProfiles.mNameObfuscation) === null || _a === void 0 ? void 0 : _a.mEnable) || !this.mCustomProfiles.mEnableNameCache) {
            return;
        }
        const nameCachePath = path_1.default.join(outputDir, FileUtils_1.FileUtils.getFileName(sourceFile) + NameCacheUtil_1.NAME_CACHE_SUFFIX);
        const nameCache = (0, NameCacheUtil_1.readCache)(nameCachePath);
        let historyNameCache = new Map();
        let identifierCache = nameCache ? Reflect.get(nameCache, NameCacheUtil_1.IDENTIFIER_CACHE) : undefined;
        (0, NameCacheUtil_1.deleteLineInfoForNameString)(historyNameCache, identifierCache);
        ArkObfuscator_1.renameIdentifierModule.historyNameCache = historyNameCache;
    }
    producePropertyCache(outputDir) {
        if (this.mCustomProfiles.mNameObfuscation &&
            this.mCustomProfiles.mNameObfuscation.mRenameProperties &&
            this.mCustomProfiles.mEnableNameCache) {
            const propertyCachePath = path_1.default.join(outputDir, NameCacheUtil_1.PROPERTY_CACHE_FILE);
            (0, NameCacheUtil_1.writeCache)(ArkObfuscator_1.PropCollections.globalMangledTable, propertyCachePath);
        }
    }
    readPropertyCache(outputDir) {
        var _a;
        if (!((_a = this.mCustomProfiles.mNameObfuscation) === null || _a === void 0 ? void 0 : _a.mRenameProperties) || !this.mCustomProfiles.mEnableNameCache) {
            return;
        }
        const propertyCachePath = path_1.default.join(outputDir, NameCacheUtil_1.PROPERTY_CACHE_FILE);
        const propertyCache = (0, NameCacheUtil_1.readCache)(propertyCachePath);
        if (!propertyCache) {
            return;
        }
        ArkObfuscator_1.PropCollections.historyMangledTable = (0, NameCacheUtil_1.getMapFromJson)(propertyCache);
    }
}
exports.ArkObfuscatorForTest = ArkObfuscatorForTest;
//# sourceMappingURL=ArkObfuscatorForTest.js.map