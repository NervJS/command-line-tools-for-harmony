"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.recordHistoryUnobfuscatedNames = exports.recordReservedName = exports.isInLocalWhitelist = exports.isInPropertyWhitelist = exports.isInTopLevelWhitelist = exports.needToRecordProperty = exports.WhitelistType = exports.isReservedProperty = exports.isReservedTopLevel = exports.isReservedLocalVariable = exports.handleReservedConfig = exports.isMatchWildcard = exports.needToBeReserved = exports.wildcardTransformer = exports.containWildcards = exports.separateUniversalReservedItem = exports.isSuperCallStatement = exports.isCommentedNode = exports.collectIdentifiersAndStructs = exports.collectExistNames = void 0;
const typescript_1 = require("typescript");
const CommonCollections_1 = require("./CommonCollections");
const RenameIdentifierTransformer_1 = require("../transformers/rename/RenameIdentifierTransformer");
/**
 * collect exist identifier names in current source file
 * @param sourceFile
 */
function collectExistNames(sourceFile) {
    const identifiers = new Set();
    let visit = (node) => {
        if ((0, typescript_1.isIdentifier)(node)) {
            identifiers.add(node.text);
        }
        (0, typescript_1.forEachChild)(node, visit);
    };
    (0, typescript_1.forEachChild)(sourceFile, visit);
    return identifiers;
}
exports.collectExistNames = collectExistNames;
/**
 * collect exist identifiers in current source file
 * @param sourceFile
 * @param context
 */
function collectIdentifiersAndStructs(sourceFile, context) {
    const identifiers = [];
    const structs = [];
    let visit = (node) => {
        if ((0, typescript_1.isStructDeclaration)(node)) {
            structs.push(node);
        }
        // @ts-ignore
        if (getOriginalNode(node).virtual) {
            return node;
        }
        if (!(0, typescript_1.isIdentifier)(node) || !node.parent) {
            return (0, typescript_1.visitEachChild)(node, visit, context);
        }
        identifiers.push(node);
        return node;
    };
    visit(sourceFile);
    return { shadowIdentifiers: identifiers, shadowStructs: structs };
}
exports.collectIdentifiersAndStructs = collectIdentifiersAndStructs;
function isCommentedNode(node, sourceFile) {
    const ranges = (0, typescript_1.getLeadingCommentRangesOfNode)(node, sourceFile);
    return ranges !== undefined;
}
exports.isCommentedNode = isCommentedNode;
function isSuperCallStatement(node) {
    return (0, typescript_1.isExpressionStatement)(node) &&
        (0, typescript_1.isCallExpression)(node.expression) &&
        node.expression.expression.kind === typescript_1.SyntaxKind.SuperKeyword;
}
exports.isSuperCallStatement = isSuperCallStatement;
/**
 * separate wildcards from specific items.
 */
function separateUniversalReservedItem(originalArray) {
    if (!originalArray) {
        throw new Error('Unable to handle the empty array.');
    }
    const reservedInfo = {
        universalReservedArray: [],
        specificReservedArray: []
    };
    originalArray.forEach(reservedItem => {
        if (containWildcards(reservedItem)) {
            const regexPattern = wildcardTransformer(reservedItem);
            const regexOperator = new RegExp(`^${regexPattern}$`);
            reservedInfo.universalReservedArray.push(regexOperator);
            recordWildcardMapping(reservedItem, regexOperator);
        }
        else {
            reservedInfo.specificReservedArray.push(reservedItem);
        }
    });
    return reservedInfo;
}
exports.separateUniversalReservedItem = separateUniversalReservedItem;
function recordWildcardMapping(originString, regExpression) {
    if (CommonCollections_1.UnobfuscationCollections.printKeptName) {
        CommonCollections_1.UnobfuscationCollections.reservedWildcardMap.set(regExpression, originString);
    }
}
/**
 * check if the item contains '*', '?'.
 */
function containWildcards(item) {
    return /[\*\?]/.test(item);
}
exports.containWildcards = containWildcards;
/**
 * Convert specific characters into regular expressions.
 */
function wildcardTransformer(wildcard, isPath) {
    // Add an escape character in front of special characters
    // special characters: '\', '^', '$', '.', '+', '|', '[', ']', '{', '}', '(', ')'
    let escapedItem = wildcard.replace(/[\\+^${}()|\[\]\.]/g, '\\$&');
    // isPath: containing '**', and '*', '?' can not be matched with '/'. 
    if (isPath) {
        // before: ../**/a/b/c*/?.ets
        // after: ../.*/a/b/c[^/]*/[^/].ets
        return escapedItem.replace(/\*\*/g, '.*').replace(/(?<!\.)\*/g, '[^/]*').replace(/\?/g, '[^/]');
    }
    // before: *a?
    // after: .*a.
    return escapedItem.replace(/\*/g, '.*').replace(/\?/g, '.');
}
exports.wildcardTransformer = wildcardTransformer;
/**
 * Determine whether the original name needs to be preserved.
 */
function needToBeReserved(reservedSet, universalArray, originalName) {
    return reservedSet.has(originalName) || isMatchWildcard(universalArray, originalName);
}
exports.needToBeReserved = needToBeReserved;
/**
 * Determine whether it can match the wildcard character in the array.
 */
function isMatchWildcard(wildcardArray, item) {
    for (const wildcard of wildcardArray) {
        if (wildcard.test(item)) {
            return true;
        }
    }
    return false;
}
exports.isMatchWildcard = isMatchWildcard;
/**
 * Separate parts of an array that contain wildcard characters.
 */
function handleReservedConfig(config, optionName, reservedListName, universalLisName, enableRemove) {
    const reservedConfig = config === null || config === void 0 ? void 0 : config[optionName];
    let needSeparate = !!(reservedConfig === null || reservedConfig === void 0 ? void 0 : reservedConfig[reservedListName]);
    if (enableRemove) {
        needSeparate && (needSeparate = reservedConfig[enableRemove]);
    }
    if (needSeparate) {
        // separate items which contain wildcards from others
        const reservedInfo = separateUniversalReservedItem(reservedConfig[reservedListName]);
        reservedConfig[reservedListName] = reservedInfo.specificReservedArray;
        reservedConfig[universalLisName] = reservedInfo.universalReservedArray;
    }
}
exports.handleReservedConfig = handleReservedConfig;
function isReservedLocalVariable(mangledName) {
    var _a, _b, _c, _d;
    return CommonCollections_1.LocalVariableCollections.reservedLangForLocal.has(mangledName) ||
        ((_a = CommonCollections_1.LocalVariableCollections.reservedConfig) === null || _a === void 0 ? void 0 : _a.has(mangledName)) ||
        ((_b = CommonCollections_1.LocalVariableCollections.reservedStruct) === null || _b === void 0 ? void 0 : _b.has(mangledName)) ||
        ((_c = CommonCollections_1.UnobfuscationCollections.reservedSdkApiForProp) === null || _c === void 0 ? void 0 : _c.has(mangledName)) ||
        ((_d = CommonCollections_1.UnobfuscationCollections.reservedExportName) === null || _d === void 0 ? void 0 : _d.has(mangledName));
}
exports.isReservedLocalVariable = isReservedLocalVariable;
function isReservedTopLevel(originalName) {
    var _a, _b, _c;
    if (CommonCollections_1.PropCollections.enablePropertyObfuscation) {
        return isReservedProperty(originalName);
    }
    // The 'mReservedToplevelNames' has already been added to 'PropCollections.reservedProperties'.
    return CommonCollections_1.UnobfuscationCollections.reservedLangForTopLevel.has(originalName) ||
        ((_a = CommonCollections_1.UnobfuscationCollections.reservedSdkApiForGlobal) === null || _a === void 0 ? void 0 : _a.has(originalName)) ||
        ((_b = CommonCollections_1.UnobfuscationCollections.reservedExportName) === null || _b === void 0 ? void 0 : _b.has(originalName)) ||
        ((_c = CommonCollections_1.PropCollections.reservedProperties) === null || _c === void 0 ? void 0 : _c.has(originalName)) ||
        isMatchWildcard(CommonCollections_1.PropCollections.universalReservedProperties, originalName);
}
exports.isReservedTopLevel = isReservedTopLevel;
function isReservedProperty(originalName) {
    var _a, _b, _c, _d, _e, _f, _g;
    return ((_a = CommonCollections_1.UnobfuscationCollections.reservedSdkApiForProp) === null || _a === void 0 ? void 0 : _a.has(originalName)) ||
        ((_b = CommonCollections_1.UnobfuscationCollections.reservedLangForProperty) === null || _b === void 0 ? void 0 : _b.has(originalName)) ||
        ((_c = CommonCollections_1.UnobfuscationCollections.reservedStruct) === null || _c === void 0 ? void 0 : _c.has(originalName)) ||
        ((_d = CommonCollections_1.UnobfuscationCollections.reservedExportNameAndProp) === null || _d === void 0 ? void 0 : _d.has(originalName)) ||
        ((_e = CommonCollections_1.UnobfuscationCollections.reservedStrProp) === null || _e === void 0 ? void 0 : _e.has(originalName)) ||
        ((_f = CommonCollections_1.UnobfuscationCollections.reservedEnum) === null || _f === void 0 ? void 0 : _f.has(originalName)) ||
        ((_g = CommonCollections_1.PropCollections.reservedProperties) === null || _g === void 0 ? void 0 : _g.has(originalName)) ||
        isMatchWildcard(CommonCollections_1.PropCollections.universalReservedProperties, originalName);
}
exports.isReservedProperty = isReservedProperty;
/**
 * Reasons for not being obfuscated.
 */
var WhitelistType;
(function (WhitelistType) {
    WhitelistType["SDK"] = "sdk";
    WhitelistType["LANG"] = "lang";
    WhitelistType["CONF"] = "conf";
    WhitelistType["STRUCT"] = "struct";
    WhitelistType["EXPORT"] = "exported";
    WhitelistType["STRPROP"] = "strProp";
    WhitelistType["ENUM"] = "enum";
})(WhitelistType = exports.WhitelistType || (exports.WhitelistType = {}));
function needToRecordTopLevel(originalName, recordMap, nameWithScope) {
    var _a, _b, _c;
    if (CommonCollections_1.PropCollections.enablePropertyObfuscation) {
        return needToRecordProperty(originalName, recordMap, nameWithScope);
    }
    let reservedFlag = false;
    if (CommonCollections_1.UnobfuscationCollections.reservedLangForTopLevel.has(originalName)) {
        recordReservedName(nameWithScope, WhitelistType.LANG, recordMap);
        reservedFlag = true;
    }
    if ((_a = CommonCollections_1.UnobfuscationCollections.reservedSdkApiForGlobal) === null || _a === void 0 ? void 0 : _a.has(originalName)) {
        recordReservedName(nameWithScope, WhitelistType.SDK, recordMap);
        reservedFlag = true;
    }
    if ((_b = CommonCollections_1.UnobfuscationCollections.reservedExportName) === null || _b === void 0 ? void 0 : _b.has(originalName)) {
        recordReservedName(nameWithScope, WhitelistType.EXPORT, recordMap);
        reservedFlag = true;
    }
    // The 'mReservedToplevelNames' has already been added to 'PropCollections.reservedProperties'.
    if (((_c = CommonCollections_1.PropCollections.reservedProperties) === null || _c === void 0 ? void 0 : _c.has(originalName)) ||
        isMatchWildcard(CommonCollections_1.PropCollections.universalReservedProperties, originalName)) {
        recordReservedName(nameWithScope, WhitelistType.CONF, recordMap);
        reservedFlag = true;
    }
    return reservedFlag;
}
function needToReservedLocal(originalName, recordMap, nameWithScope) {
    var _a, _b, _c, _d;
    let reservedFlag = false;
    if (CommonCollections_1.LocalVariableCollections.reservedLangForLocal.has(originalName)) {
        recordReservedName(nameWithScope, WhitelistType.LANG, recordMap);
        reservedFlag = true;
    }
    if ((_a = CommonCollections_1.UnobfuscationCollections.reservedSdkApiForLocal) === null || _a === void 0 ? void 0 : _a.has(originalName)) {
        recordReservedName(nameWithScope, WhitelistType.SDK, recordMap);
        reservedFlag = true;
    }
    if ((_b = CommonCollections_1.UnobfuscationCollections.reservedExportName) === null || _b === void 0 ? void 0 : _b.has(originalName)) {
        recordReservedName(nameWithScope, WhitelistType.EXPORT, recordMap);
        reservedFlag = true;
    }
    if ((_c = CommonCollections_1.LocalVariableCollections.reservedConfig) === null || _c === void 0 ? void 0 : _c.has(originalName)) {
        recordReservedName(nameWithScope, WhitelistType.CONF, recordMap);
        reservedFlag = true;
    }
    if ((_d = CommonCollections_1.LocalVariableCollections.reservedStruct) === null || _d === void 0 ? void 0 : _d.has(originalName)) {
        recordReservedName(nameWithScope, WhitelistType.STRUCT, recordMap);
        reservedFlag = true;
    }
    return reservedFlag;
}
/**
 * If the property name is in the whitelist, record the reason for not being obfuscated.
 * @param nameWithScope: If both property obfuscation and top-level obfuscation or export obfuscation are enabled,
 * this interface is also used to record the reasons why the top-level names or export names were not obfuscated,
 * and the top-level names or export names include the scope.
 */
function needToRecordProperty(originalName, recordMap, nameWithScope) {
    var _a, _b, _c, _d, _e, _f, _g;
    let reservedFlag = false;
    let recordName = nameWithScope ? nameWithScope : originalName;
    if ((_a = CommonCollections_1.UnobfuscationCollections.reservedSdkApiForProp) === null || _a === void 0 ? void 0 : _a.has(originalName)) {
        recordReservedName(recordName, WhitelistType.SDK, recordMap);
        reservedFlag = true;
    }
    if ((_b = CommonCollections_1.UnobfuscationCollections.reservedLangForProperty) === null || _b === void 0 ? void 0 : _b.has(originalName)) {
        recordReservedName(recordName, WhitelistType.LANG, recordMap);
        reservedFlag = true;
    }
    if ((_c = CommonCollections_1.UnobfuscationCollections.reservedStruct) === null || _c === void 0 ? void 0 : _c.has(originalName)) {
        recordReservedName(recordName, WhitelistType.STRUCT, recordMap);
        reservedFlag = true;
    }
    if ((_d = CommonCollections_1.UnobfuscationCollections.reservedExportNameAndProp) === null || _d === void 0 ? void 0 : _d.has(originalName)) {
        recordReservedName(recordName, WhitelistType.EXPORT, recordMap);
        reservedFlag = true;
    }
    if ((_e = CommonCollections_1.UnobfuscationCollections.reservedStrProp) === null || _e === void 0 ? void 0 : _e.has(originalName)) {
        recordReservedName(recordName, WhitelistType.STRPROP, recordMap);
        reservedFlag = true;
    }
    if ((_f = CommonCollections_1.UnobfuscationCollections.reservedEnum) === null || _f === void 0 ? void 0 : _f.has(originalName)) {
        recordReservedName(recordName, WhitelistType.ENUM, recordMap);
        reservedFlag = true;
    }
    if (((_g = CommonCollections_1.PropCollections.reservedProperties) === null || _g === void 0 ? void 0 : _g.has(originalName)) ||
        isMatchWildcard(CommonCollections_1.PropCollections.universalReservedProperties, originalName)) {
        recordReservedName(recordName, WhitelistType.CONF, recordMap);
        reservedFlag = true;
    }
    return reservedFlag;
}
exports.needToRecordProperty = needToRecordProperty;
function isInTopLevelWhitelist(originalName, recordMap, nameWithScope) {
    if (CommonCollections_1.UnobfuscationCollections.printKeptName) {
        return needToRecordTopLevel(originalName, recordMap, nameWithScope);
    }
    return isReservedTopLevel(originalName);
}
exports.isInTopLevelWhitelist = isInTopLevelWhitelist;
function isInPropertyWhitelist(originalName, recordMap) {
    if (CommonCollections_1.UnobfuscationCollections.printKeptName) {
        return needToRecordProperty(originalName, recordMap);
    }
    return isReservedProperty(originalName);
}
exports.isInPropertyWhitelist = isInPropertyWhitelist;
function isInLocalWhitelist(originalName, recordMap, nameWithScope) {
    if (CommonCollections_1.UnobfuscationCollections.printKeptName) {
        return needToReservedLocal(originalName, recordMap, nameWithScope);
    }
    return isReservedLocalVariable(originalName);
}
exports.isInLocalWhitelist = isInLocalWhitelist;
function recordReservedName(originalName, type, recordObj) {
    if (!CommonCollections_1.UnobfuscationCollections.printKeptName || !recordObj) {
        return;
    }
    if (!recordObj.has(originalName)) {
        recordObj.set(originalName, new Set());
    }
    recordObj.get(originalName).add(type);
}
exports.recordReservedName = recordReservedName;
function recordHistoryUnobfuscatedNames(nameWithScope) {
    if (RenameIdentifierTransformer_1.historyUnobfuscatedNamesMap === null || RenameIdentifierTransformer_1.historyUnobfuscatedNamesMap === void 0 ? void 0 : RenameIdentifierTransformer_1.historyUnobfuscatedNamesMap.has(nameWithScope)) {
        CommonCollections_1.UnobfuscationCollections.unobfuscatedNamesMap.set(nameWithScope, new Set(RenameIdentifierTransformer_1.historyUnobfuscatedNamesMap.get(nameWithScope)));
    }
}
exports.recordHistoryUnobfuscatedNames = recordHistoryUnobfuscatedNames;
//# sourceMappingURL=TransformUtil.js.map