"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const typescript_1 = require("typescript");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const TransformPlugin_1 = require("../TransformPlugin");
const INameObfuscationOption_1 = require("../../configs/INameObfuscationOption");
const NameFactory_1 = require("../../generator/NameFactory");
const FileUtils_1 = require("../../utils/FileUtils");
const ArkObfuscator_1 = require("../../ArkObfuscator");
const PrinterUtils_1 = require("../../utils/PrinterUtils");
const TransformUtil_1 = require("../../utils/TransformUtil");
var secharmony;
(function (secharmony) {
    // global mangled file name table used by all files in a project
    secharmony.globalFileNameMangledTable = new Map();
    // used for file name cache
    secharmony.historyFileNameMangledTable = undefined;
    // When the module is compiled, call this function to clear global collections related to file name.
    function clearCaches() {
        secharmony.globalFileNameMangledTable.clear();
        secharmony.historyFileNameMangledTable === null || secharmony.historyFileNameMangledTable === void 0 ? void 0 : secharmony.historyFileNameMangledTable.clear();
    }
    secharmony.clearCaches = clearCaches;
    let profile;
    let generator;
    let reservedFileNames;
    let localPackageSet;
    let useNormalized = false;
    let universalReservedFileNames;
    /**
     * Rename Properties Transformer
     *
     * @param option obfuscation options
     */
    const createRenameFileNameFactory = function (options) {
        var _a, _b;
        profile = options === null || options === void 0 ? void 0 : options.mRenameFileName;
        if (!profile || !profile.mEnable) {
            return null;
        }
        let nameGeneratorOption = {};
        generator = (0, NameFactory_1.getNameGenerator)(profile.mNameGeneratorType, nameGeneratorOption);
        let configReservedFileNameOrPath = (_a = profile === null || profile === void 0 ? void 0 : profile.mReservedFileNames) !== null && _a !== void 0 ? _a : [];
        const tempReservedName = ['.', '..', ''];
        configReservedFileNameOrPath.map(fileNameOrPath => {
            if (!fileNameOrPath || fileNameOrPath.length === 0) {
                return;
            }
            const directories = FileUtils_1.FileUtils.splitFilePath(fileNameOrPath);
            directories.forEach(directory => {
                tempReservedName.push(directory);
                const pathOrExtension = FileUtils_1.FileUtils.getFileSuffix(directory);
                if (pathOrExtension.ext) {
                    tempReservedName.push(pathOrExtension.ext);
                    tempReservedName.push(pathOrExtension.path);
                }
            });
        });
        reservedFileNames = new Set(tempReservedName);
        universalReservedFileNames = (_b = profile === null || profile === void 0 ? void 0 : profile.mUniversalReservedFileNames) !== null && _b !== void 0 ? _b : [];
        return renameFileNameFactory;
        function renameFileNameFactory(context) {
            let projectInfo = ArkObfuscator_1.ArkObfuscator.mProjectInfo;
            if (projectInfo && projectInfo.localPackageSet) {
                localPackageSet = projectInfo.localPackageSet;
                useNormalized = projectInfo.useNormalized;
            }
            return renameFileNameTransformer;
            function renameFileNameTransformer(node) {
                if (secharmony.globalFileNameMangledTable === undefined) {
                    secharmony.globalFileNameMangledTable = new Map();
                }
                (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.FILENAME_OBFUSCATION, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                let ret = updateNodeInfo(node);
                if (!isInOhModules(projectInfo, ArkObfuscator_1.orignalFilePathForSearching) && (0, typescript_1.isSourceFile)(ret)) {
                    const orignalAbsPath = ret.fileName;
                    const mangledAbsPath = getMangleCompletePath(orignalAbsPath);
                    ret.fileName = mangledAbsPath;
                }
                let parentNodes = (0, typescript_1.setParentRecursive)(ret, true);
                (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.FILENAME_OBFUSCATION, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                return parentNodes;
            }
            function updateNodeInfo(node) {
                if ((0, typescript_1.isImportDeclaration)(node) || (0, typescript_1.isExportDeclaration)(node)) {
                    return updateImportOrExportDeclaration(node);
                }
                if (isImportCall(node)) {
                    return tryUpdateDynamicImport(node);
                }
                return (0, typescript_1.visitEachChild)(node, updateNodeInfo, context);
            }
        }
    };
    function isInOhModules(proInfo, originalPath) {
        let ohPackagePath = '';
        if (proInfo && proInfo.projectRootPath && proInfo.packageDir) {
            ohPackagePath = FileUtils_1.FileUtils.toUnixPath(path_1.default.resolve(proInfo.projectRootPath, proInfo.packageDir));
        }
        return ohPackagePath && FileUtils_1.FileUtils.toUnixPath(originalPath).indexOf(ohPackagePath) !== -1;
    }
    secharmony.isInOhModules = isInOhModules;
    function updateImportOrExportDeclaration(node) {
        if (!node.moduleSpecifier) {
            return node;
        }
        const mangledModuleSpecifier = renameStringLiteral(node.moduleSpecifier);
        if ((0, typescript_1.isImportDeclaration)(node)) {
            return typescript_1.factory.updateImportDeclaration(node, node.modifiers, node.importClause, mangledModuleSpecifier, node.assertClause);
        }
        else {
            return typescript_1.factory.updateExportDeclaration(node, node.modifiers, node.isTypeOnly, node.exportClause, mangledModuleSpecifier, node.assertClause);
        }
    }
    function updateImportOrExportDeclarationForTest(node) {
        return updateImportOrExportDeclaration(node);
    }
    secharmony.updateImportOrExportDeclarationForTest = updateImportOrExportDeclarationForTest;
    function isImportCall(n) {
        return n.kind === typescript_1.SyntaxKind.CallExpression && n.expression.kind === typescript_1.SyntaxKind.ImportKeyword;
    }
    function canBeObfuscatedFilePath(filePath) {
        return path_1.default.isAbsolute(filePath) || FileUtils_1.FileUtils.isRelativePath(filePath) || isLocalDependencyOhmUrl(filePath);
    }
    function isLocalDependencyOhmUrl(filePath) {
        // mOhmUrlStatus: for unit test in Arkguard
        if ((profile === null || profile === void 0 ? void 0 : profile.mOhmUrlStatus) === INameObfuscationOption_1.OhmUrlStatus.AT_BUNDLE ||
            (profile === null || profile === void 0 ? void 0 : profile.mOhmUrlStatus) === INameObfuscationOption_1.OhmUrlStatus.NORMALIZED) {
            return true;
        }
        let packageName;
        // Only hap and local har need be mangled.
        if (useNormalized) {
            if (!filePath.startsWith(FileUtils_1.NORMALIZE)) {
                return false;
            }
            packageName = handleNormalizedOhmUrl(filePath, true);
        }
        else {
            if (!filePath.startsWith(FileUtils_1.BUNDLE)) {
                return false;
            }
            packageName = getAtBundlePgkName(filePath);
        }
        return localPackageSet && localPackageSet.has(packageName);
    }
    function isLocalDependencyOhmUrlForTest(filePath) {
        return isLocalDependencyOhmUrl(filePath);
    }
    secharmony.isLocalDependencyOhmUrlForTest = isLocalDependencyOhmUrlForTest;
    function getAtBundlePgkName(ohmUrl) {
        /* Unnormalized OhmUrl Format:
        * hap/hsp: @bundle:${bundleName}/${moduleName}/
        * har: @bundle:${bundleName}/${moduleName}@${harName}/
        * package name is {moduleName} in hap/hsp or {harName} in har.
        */
        let moduleName = ohmUrl.split('/')[1]; // 1: the index of moduleName in array.
        const indexOfSign = moduleName.indexOf('@');
        if (indexOfSign !== -1) {
            moduleName = moduleName.slice(indexOfSign + 1); // 1: the index start from indexOfSign + 1.
        }
        return moduleName;
    }
    // dynamic import example: let module = import('./a')
    function tryUpdateDynamicImport(node) {
        if (node.expression && node.arguments.length === 1 && (0, typescript_1.isStringLiteral)(node.arguments[0])) {
            const obfuscatedArgument = [renameStringLiteral(node.arguments[0])];
            if (obfuscatedArgument[0] !== node.arguments[0]) {
                return typescript_1.factory.updateCallExpression(node, node.expression, node.typeArguments, obfuscatedArgument);
            }
        }
        return node;
    }
    function renameStringLiteral(node) {
        let expr = renameFileName(node);
        if (expr !== node) {
            return typescript_1.factory.createStringLiteral(expr.text);
        }
        return node;
    }
    function renameFileName(node) {
        let original = '';
        original = node.text;
        original = original.replace(/\\/g, '/');
        if (!canBeObfuscatedFilePath(original)) {
            return node;
        }
        let mangledFileName = getMangleIncompletePath(original);
        if (mangledFileName === original) {
            return node;
        }
        return typescript_1.factory.createStringLiteral(mangledFileName);
    }
    function getMangleCompletePath(originalCompletePath) {
        originalCompletePath = FileUtils_1.FileUtils.toUnixPath(originalCompletePath);
        const { path: filePathWithoutSuffix, ext: extension } = FileUtils_1.FileUtils.getFileSuffix(originalCompletePath);
        const mangleFilePath = mangleFileName(filePathWithoutSuffix);
        return mangleFilePath + extension;
    }
    secharmony.getMangleCompletePath = getMangleCompletePath;
    function getMangleIncompletePath(orignalPath) {
        // The ohmUrl format does not have file extension
        if (isLocalDependencyOhmUrl(orignalPath)) {
            const mangledOhmUrl = mangleOhmUrl(orignalPath);
            return mangledOhmUrl;
        }
        // Try to concat the extension for orignalPath.
        const pathAndExtension = tryValidateFileExisting(orignalPath);
        if (!pathAndExtension) {
            return orignalPath;
        }
        if (pathAndExtension.ext) {
            const mangleFilePath = mangleFileName(pathAndExtension.path);
            return mangleFilePath;
        }
        /**
         * import * from './filename1.js'. We just need to obfuscate 'filename1' and then concat the extension 'js'.
         * import * from './direcotry'. For the grammar of importing directory, TSC will look for index.ets/index.ts when parsing.
         * We obfuscate directory name and do not need to concat extension.
         */
        const { path: filePathWithoutSuffix, ext: extension } = FileUtils_1.FileUtils.getFileSuffix(pathAndExtension.path);
        const mangleFilePath = mangleFileName(filePathWithoutSuffix);
        return mangleFilePath + extension;
    }
    function getMangleIncompletePathForTest(orignalPath) {
        return getMangleIncompletePath(orignalPath);
    }
    secharmony.getMangleIncompletePathForTest = getMangleIncompletePathForTest;
    ;
    function mangleOhmUrl(ohmUrl) {
        let mangledOhmUrl;
        // mOhmUrlStatus: for unit test in Arkguard
        if (useNormalized || (profile === null || profile === void 0 ? void 0 : profile.mOhmUrlStatus) === INameObfuscationOption_1.OhmUrlStatus.NORMALIZED) {
            mangledOhmUrl = handleNormalizedOhmUrl(ohmUrl);
        }
        else {
            /**
             * OhmUrl Format:
             * fixed parts in hap/hsp: @bundle:${bundleName}/${moduleName}/
             * fixed parts in har: @bundle:${bundleName}/${moduleName}@${harName}/
             * hsp example: @bundle:com.example.myapplication/entry/index
             * har example: @bundle:com.example.myapplication/entry@library_test/index
             * we do not mangle fixed parts.
             */
            const originalOhmUrlSegments = FileUtils_1.FileUtils.splitFilePath(ohmUrl);
            const prefixSegments = originalOhmUrlSegments.slice(0, 2); // 2: length of fixed parts in array
            const urlSegments = originalOhmUrlSegments.slice(2); // 2: index of mangled parts in array
            const mangledOhmUrlSegments = urlSegments.map(originalSegment => mangleFileNamePart(originalSegment));
            mangledOhmUrl = prefixSegments.join('/') + '/' + mangledOhmUrlSegments.join('/');
        }
        return mangledOhmUrl;
    }
    secharmony.mangleOhmUrl = mangleOhmUrl;
    /**
     * Normalized OhmUrl Format:
     * hap/hsp: @normalized:N&<module name>&<bundle name>&<standard import path>&
     * har: @normalized:N&&<bundle name>&<standard import path>&<version>
     * we only mangle <standard import path>.
     */
    function handleNormalizedOhmUrl(ohmUrl, needPkgName) {
        let originalOhmUrlSegments = ohmUrl.split('&');
        const standardImportPath = originalOhmUrlSegments[3]; // 3: index of standard import path in array.
        let index = standardImportPath.indexOf('/');
        // The format of <module name>: @group/packagename or packagename,
        // and there should only be one '@' symbol and one path separator '/' if and only if the 'group' exists.
        if (standardImportPath.startsWith('@')) {
            index = standardImportPath.indexOf('/', index + 1);
        }
        const pakName = standardImportPath.substring(0, index);
        if (needPkgName) {
            return pakName;
        }
        const realImportPath = standardImportPath.substring(index + 1); // 1: index of real import path in array.
        const originalImportPathSegments = FileUtils_1.FileUtils.splitFilePath(realImportPath);
        const mangledImportPathSegments = originalImportPathSegments.map(originalSegment => mangleFileNamePart(originalSegment));
        const mangledImportPath = pakName + '/' + mangledImportPathSegments.join('/');
        originalOhmUrlSegments[3] = mangledImportPath; // 3: index of standard import path in array.
        return originalOhmUrlSegments.join('&');
    }
    secharmony.handleNormalizedOhmUrl = handleNormalizedOhmUrl;
    function mangleFileName(orignalPath) {
        const originalFileNameSegments = FileUtils_1.FileUtils.splitFilePath(orignalPath);
        const mangledSegments = originalFileNameSegments.map(originalSegment => mangleFileNamePart(originalSegment));
        let mangledFileName = mangledSegments.join('/');
        return mangledFileName;
    }
    function mangleFileNamePart(original) {
        if ((0, TransformUtil_1.needToBeReserved)(reservedFileNames, universalReservedFileNames, original)) {
            return original;
        }
        const historyName = secharmony.historyFileNameMangledTable === null || secharmony.historyFileNameMangledTable === void 0 ? void 0 : secharmony.historyFileNameMangledTable.get(original);
        let mangledName = historyName ? historyName : secharmony.globalFileNameMangledTable.get(original);
        while (!mangledName) {
            mangledName = generator.getName();
            if (mangledName === original || (0, TransformUtil_1.needToBeReserved)(reservedFileNames, universalReservedFileNames, mangledName)) {
                mangledName = null;
                continue;
            }
            let reserved = [...secharmony.globalFileNameMangledTable.values()];
            if (reserved.includes(mangledName)) {
                mangledName = null;
                continue;
            }
            if (secharmony.historyFileNameMangledTable && [...secharmony.historyFileNameMangledTable.values()].includes(mangledName)) {
                mangledName = null;
                continue;
            }
        }
        secharmony.globalFileNameMangledTable.set(original, mangledName);
        return mangledName;
    }
    secharmony.transformerPlugin = {
        'name': 'renamePropertiesPlugin',
        'order': TransformPlugin_1.TransformerOrder.RENAME_FILE_NAME_TRANSFORMER,
        'createTransformerFactory': createRenameFileNameFactory
    };
})(secharmony || (secharmony = {}));
// typescript doesn't add the json extension.
const extensionOrder = ['.ets', '.ts', '.d.ets', '.d.ts', '.js'];
function tryValidateFileExisting(importPath) {
    let fileAbsPath = '';
    if (path_1.default.isAbsolute(importPath)) {
        fileAbsPath = importPath;
    }
    else {
        fileAbsPath = path_1.default.join(path_1.default.dirname(ArkObfuscator_1.orignalFilePathForSearching), importPath);
    }
    const filePathExtensionLess = path_1.default.normalize(fileAbsPath);
    for (let ext of extensionOrder) {
        const targetPath = filePathExtensionLess + ext;
        if (fs_1.default.existsSync(targetPath)) {
            return { path: importPath, ext: ext };
        }
    }
    // all suffixes are not matched, search this file directly.
    if (fs_1.default.existsSync(filePathExtensionLess)) {
        return { path: importPath, ext: undefined };
    }
    return undefined;
}
module.exports = secharmony;
//# sourceMappingURL=RenameFileNameTransformer.js.map