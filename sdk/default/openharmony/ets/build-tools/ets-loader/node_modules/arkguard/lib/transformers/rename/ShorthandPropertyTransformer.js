"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const TransformPlugin_1 = require("../TransformPlugin");
const ArkObfuscator_1 = require("../../ArkObfuscator");
const PrinterUtils_1 = require("../../utils/PrinterUtils");
var secharmony;
(function (secharmony) {
    const createShorthandPropertyTransformerFactory = function (option) {
        let profile = option.mNameObfuscation;
        if (!profile || !profile.mEnable) {
            return null;
        }
        return shorthandPropertyTransformFactory;
        function shorthandPropertyTransformFactory(context) {
            return shorthandPropertyTransformer;
            function shorthandPropertyTransformer(node) {
                if ((0, typescript_1.isSourceFile)(node) && ArkObfuscator_1.ArkObfuscator.isKeptCurrentFile) {
                    return node;
                }
                (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.SHORT_HAND_OBFUSCATION, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                let ret = transformShortHandProperty(node);
                let parentNodes = (0, typescript_1.setParentRecursive)(ret, true);
                (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.SHORT_HAND_OBFUSCATION, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                return parentNodes;
            }
            function transformShortHandProperty(node) {
                /**
                 * example:
                 * `let name1 = 'hello';`
                 * `let info = {name1};`
                 * obfuscated example:
                 * `let name1 = 'hello';`;
                 * `let info = {name1: name1};`
                 */
                if ((0, typescript_1.isShorthandPropertyAssignment)((node))) {
                    let initializer = node.objectAssignmentInitializer;
                    let expression = node.name;
                    if (initializer) {
                        expression = typescript_1.factory.createBinaryExpression(node.name, node.equalsToken, initializer);
                    }
                    let identifier = typescript_1.factory.createIdentifier(node.name.text);
                    return typescript_1.factory.createPropertyAssignment(identifier, expression);
                }
                /**
                 * exclude grammar instance: let [name2, age2] = ['akira', 22];
                 *
                 * grammar: {name1, ...rest}= {'name1': 'akira', age : 22};
                 * an alias will be created for name1.
                 * no alias will be created for rest.
                 *
                 * include grammars:
                 * orinal ObjectBinding():
                 * const { name3, age3 } = foo3();
                 * const { name4, addr4: { contry, place} } = foo4();
                 * obfuscated ObjectBinding:
                 * `const { name3: name3, age3: age3 } = foo3();`
                 * `const { name4: name4, addr4: { contry: contry, place: place}  } = { name4: 4, addr4: { contry:5, place:6} };`
                 */
                if (isElementsInObjectBindingPattern(node) && !node.propertyName && !node.dotDotDotToken) {
                    return typescript_1.factory.createBindingElement(node.dotDotDotToken, typescript_1.factory.createIdentifier(node.name.text), node.name, node.initializer);
                }
                return (0, typescript_1.visitEachChild)(node, transformShortHandProperty, context);
            }
            function isElementsInObjectBindingPattern(node) {
                return node.parent && (0, typescript_1.isObjectBindingPattern)(node.parent) && (0, typescript_1.isBindingElement)(node);
            }
        }
    };
    secharmony.transformerPlugin = {
        'name': 'ShortHandPropertyTransformer',
        'order': TransformPlugin_1.TransformerOrder.SHORTHAND_PROPERTY_TRANSFORMER,
        'createTransformerFactory': createShorthandPropertyTransformerFactory,
    };
})(secharmony || (secharmony = {}));
module.exports = secharmony;
//# sourceMappingURL=ShorthandPropertyTransformer.js.map