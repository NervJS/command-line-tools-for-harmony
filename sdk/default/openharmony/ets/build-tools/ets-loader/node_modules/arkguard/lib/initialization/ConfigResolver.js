"use strict";
/*
 * Copyright (c) 2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelativeSourcePath = exports.enableObfuscateFileName = exports.handleObfuscatedFilePath = exports.enableObfuscatedFilePathConfig = exports.mangleFilePath = exports.generateConsumerObConfigFile = exports.printUnobfuscationReasons = exports.printWhitelist = exports.writeUnobfuscationContent = exports.writeObfuscationNameCache = exports.fillNameCache = exports.getArkguardNameCache = exports.handleUniversalPathInObf = exports.readNameCache = exports.collectResevedFileNameInIDEConfig = exports.ObConfigResolver = exports.MergedConfig = exports.ObOptionsForTest = exports.OptionTypeForTest = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const json5_1 = __importDefault(require("json5"));
const FileUtils_1 = require("../utils/FileUtils");
const ArkObfuscator_1 = require("../ArkObfuscator");
const utils_1 = require("./utils");
const CommonObject_1 = require("./CommonObject");
const Initializer_1 = require("./Initializer");
const CommonCollections_1 = require("../utils/CommonCollections");
const PrinterUtils_1 = require("../utils/PrinterUtils");
var OptionType;
(function (OptionType) {
    OptionType[OptionType["NONE"] = 0] = "NONE";
    OptionType[OptionType["KEEP"] = 1] = "KEEP";
    OptionType[OptionType["KEEP_DTS"] = 2] = "KEEP_DTS";
    OptionType[OptionType["KEEP_GLOBAL_NAME"] = 3] = "KEEP_GLOBAL_NAME";
    OptionType[OptionType["KEEP_PROPERTY_NAME"] = 4] = "KEEP_PROPERTY_NAME";
    OptionType[OptionType["KEEP_FILE_NAME"] = 5] = "KEEP_FILE_NAME";
    OptionType[OptionType["KEEP_COMMENTS"] = 6] = "KEEP_COMMENTS";
    OptionType[OptionType["DISABLE_OBFUSCATION"] = 7] = "DISABLE_OBFUSCATION";
    OptionType[OptionType["ENABLE_PROPERTY_OBFUSCATION"] = 8] = "ENABLE_PROPERTY_OBFUSCATION";
    OptionType[OptionType["ENABLE_STRING_PROPERTY_OBFUSCATION"] = 9] = "ENABLE_STRING_PROPERTY_OBFUSCATION";
    OptionType[OptionType["ENABLE_TOPLEVEL_OBFUSCATION"] = 10] = "ENABLE_TOPLEVEL_OBFUSCATION";
    OptionType[OptionType["ENABLE_FILENAME_OBFUSCATION"] = 11] = "ENABLE_FILENAME_OBFUSCATION";
    OptionType[OptionType["ENABLE_EXPORT_OBFUSCATION"] = 12] = "ENABLE_EXPORT_OBFUSCATION";
    OptionType[OptionType["COMPACT"] = 13] = "COMPACT";
    OptionType[OptionType["REMOVE_LOG"] = 14] = "REMOVE_LOG";
    OptionType[OptionType["REMOVE_COMMENTS"] = 15] = "REMOVE_COMMENTS";
    OptionType[OptionType["PRINT_NAMECACHE"] = 16] = "PRINT_NAMECACHE";
    OptionType[OptionType["PRINT_KEPT_NAMES"] = 17] = "PRINT_KEPT_NAMES";
    OptionType[OptionType["APPLY_NAMECACHE"] = 18] = "APPLY_NAMECACHE";
})(OptionType || (OptionType = {}));
exports.OptionTypeForTest = OptionType;
/* ObConfig's properties:
 *   ruleOptions: {
 *    enable: boolean
 *    rules: string[]
 *   }
 *   consumerRules: string[]
 *
 * ObfuscationConfig's properties:
 *   selfConfig: ObConfig
 *   dependencies: { libraries: ObConfig[], hars: string[] }
 *   sdkApis: string[]
 *   obfuscationCacheDir: string
 *   exportRulePath: string
 */
class ObOptions {
    constructor() {
        this.disableObfuscation = false;
        this.enablePropertyObfuscation = false;
        this.enableStringPropertyObfuscation = false;
        this.enableToplevelObfuscation = false;
        this.enableFileNameObfuscation = false;
        this.enableExportObfuscation = false;
        this.printKeptNames = false;
        this.removeComments = false;
        this.compact = false;
        this.removeLog = false;
        this.printNameCache = '';
        this.printKeptNamesPath = '';
        this.applyNameCache = '';
    }
    merge(other) {
        this.disableObfuscation = this.disableObfuscation || other.disableObfuscation;
        this.enablePropertyObfuscation = this.enablePropertyObfuscation || other.enablePropertyObfuscation;
        this.enableToplevelObfuscation = this.enableToplevelObfuscation || other.enableToplevelObfuscation;
        this.enableStringPropertyObfuscation =
            this.enableStringPropertyObfuscation || other.enableStringPropertyObfuscation;
        this.removeComments = this.removeComments || other.removeComments;
        this.compact = this.compact || other.compact;
        this.removeLog = this.removeLog || other.removeLog;
        this.enableFileNameObfuscation = this.enableFileNameObfuscation || other.enableFileNameObfuscation;
        this.enableExportObfuscation = this.enableExportObfuscation || other.enableExportObfuscation;
        if (other.printNameCache.length > 0) {
            this.printNameCache = other.printNameCache;
        }
        if (other.printKeptNamesPath.length > 0) {
            this.printKeptNamesPath = other.printKeptNamesPath;
        }
        if (other.applyNameCache.length > 0) {
            this.applyNameCache = other.applyNameCache;
        }
    }
}
exports.ObOptionsForTest = ObOptions;
class MergedConfig {
    constructor() {
        this.options = new ObOptions();
        this.reservedPropertyNames = [];
        this.reservedGlobalNames = [];
        this.reservedNames = [];
        this.reservedFileNames = [];
        this.keepComments = [];
        this.keepSourceOfPaths = []; // The file path or folder path configured by the developer.
        this.universalReservedPropertyNames = []; // Support reserved property names contain wildcards.
        this.universalReservedGlobalNames = []; // Support reserved global names contain wildcards.
        this.keepUniversalPaths = []; // Support reserved paths contain wildcards.
        this.excludeUniversalPaths = []; // Support excluded paths contain wildcards.
        this.excludePathSet = new Set();
    }
    merge(other) {
        this.options.merge(other.options);
        this.reservedPropertyNames.push(...other.reservedPropertyNames);
        this.reservedGlobalNames.push(...other.reservedGlobalNames);
        this.reservedFileNames.push(...other.reservedFileNames);
        this.keepComments.push(...other.keepComments);
        this.keepSourceOfPaths.push(...other.keepSourceOfPaths);
        this.keepUniversalPaths.push(...other.keepUniversalPaths);
        this.excludeUniversalPaths.push(...other.excludeUniversalPaths);
        other.excludePathSet.forEach((excludePath) => {
            this.excludePathSet.add(excludePath);
        });
    }
    sortAndDeduplicate() {
        this.reservedPropertyNames = (0, utils_1.sortAndDeduplicateStringArr)(this.reservedPropertyNames);
        this.reservedGlobalNames = (0, utils_1.sortAndDeduplicateStringArr)(this.reservedGlobalNames);
        this.reservedFileNames = (0, utils_1.sortAndDeduplicateStringArr)(this.reservedFileNames);
        this.keepComments = (0, utils_1.sortAndDeduplicateStringArr)(this.keepComments);
        this.keepSourceOfPaths = (0, utils_1.sortAndDeduplicateStringArr)(this.keepSourceOfPaths);
    }
    serializeMergedConfig() {
        let resultStr = '';
        const keys = Object.keys(this.options);
        for (const key of keys) {
            // skip the export of some switches.
            if (this.options[key] === true && ObConfigResolver.exportedSwitchMap.has(String(key))) {
                resultStr += ObConfigResolver.exportedSwitchMap.get(String(key)) + '\n';
            }
        }
        if (this.reservedGlobalNames.length > 0) {
            resultStr += ObConfigResolver.KEEP_GLOBAL_NAME + '\n';
            this.reservedGlobalNames.forEach((item) => {
                resultStr += item + '\n';
            });
        }
        if (this.reservedPropertyNames.length > 0) {
            resultStr += ObConfigResolver.KEEP_PROPERTY_NAME + '\n';
            this.reservedPropertyNames.forEach((item) => {
                resultStr += item + '\n';
            });
        }
        return resultStr;
    }
}
exports.MergedConfig = MergedConfig;
class ObConfigResolver {
    constructor(projectConfig, logger, isTerser) {
        this.sourceObConfig = projectConfig.obfuscationOptions;
        this.logger = logger;
        this.isHarCompiled = projectConfig.compileHar;
        this.isTerser = isTerser;
    }
    resolveObfuscationConfigs() {
        let sourceObConfig = this.sourceObConfig;
        if (!sourceObConfig) {
            return new MergedConfig();
        }
        let enableObfuscation = sourceObConfig.selfConfig.ruleOptions.enable;
        let selfConfig = new MergedConfig();
        if (enableObfuscation) {
            this.getSelfConfigs(selfConfig);
            enableObfuscation = !selfConfig.options.disableObfuscation;
        }
        else {
            selfConfig.options.disableObfuscation = true;
        }
        let needConsumerConfigs = this.isHarCompiled &&
            sourceObConfig.selfConfig.consumerRules &&
            sourceObConfig.selfConfig.consumerRules.length > 0;
        let needDependencyConfigs = enableObfuscation || needConsumerConfigs;
        let dependencyConfigs = new MergedConfig();
        const dependencyMaxLength = Math.max(sourceObConfig.dependencies.libraries.length, sourceObConfig.dependencies.hars.length);
        if (needDependencyConfigs && dependencyMaxLength > 0) {
            dependencyConfigs = new MergedConfig();
            this.getDependencyConfigs(sourceObConfig, dependencyConfigs);
            enableObfuscation = enableObfuscation && !dependencyConfigs.options.disableObfuscation;
        }
        const mergedConfigs = this.getMergedConfigs(selfConfig, dependencyConfigs);
        CommonCollections_1.UnobfuscationCollections.printKeptName = mergedConfigs.options.printKeptNames;
        this.handleReservedArray(mergedConfigs);
        let needKeepSystemApi = enableObfuscation &&
            (mergedConfigs.options.enablePropertyObfuscation ||
                (mergedConfigs.options.enableExportObfuscation && mergedConfigs.options.enableToplevelObfuscation));
        if (needKeepSystemApi && sourceObConfig.obfuscationCacheDir) {
            const systemApiCachePath = path_1.default.join(sourceObConfig.obfuscationCacheDir, 'systemApiCache.json');
            if ((0, utils_1.isFileExist)(systemApiCachePath)) {
                this.getSystemApiConfigsByCache(systemApiCachePath);
            }
            else {
                (0, PrinterUtils_1.startFilesEvent)(ArkObfuscator_1.EventList.SCAN_SYSTEMAPI, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                this.getSystemApiCache(mergedConfigs, systemApiCachePath);
                (0, PrinterUtils_1.endFilesEvent)(ArkObfuscator_1.EventList.SCAN_SYSTEMAPI, ArkObfuscator_1.performancePrinter.timeSumPrinter);
            }
        }
        if (needConsumerConfigs) {
            let selfConsumerConfig = new MergedConfig();
            this.getSelfConsumerConfig(selfConsumerConfig);
            this.genConsumerConfigFiles(sourceObConfig, selfConsumerConfig, dependencyConfigs);
        }
        return mergedConfigs;
    }
    getSelfConfigs(selfConfigs) {
        if (this.sourceObConfig.selfConfig.ruleOptions.rules) {
            const configPaths = this.sourceObConfig.selfConfig.ruleOptions.rules;
            for (const path of configPaths) {
                this.getConfigByPath(path, selfConfigs);
            }
        }
    }
    getSelfConfigsForTest(selfConfigs) {
        return this.getSelfConfigs(selfConfigs);
    }
    getConfigByPath(path, configs) {
        let fileContent = undefined;
        try {
            fileContent = fs_1.default.readFileSync(path, 'utf-8');
        }
        catch (err) {
            this.logger.error(`Failed to open ${path}. Error message: ${err}`);
            throw err;
        }
        this.handleConfigContent(fileContent, configs, path);
    }
    getConfigByPathForTest(path, configs) {
        return this.getConfigByPath(path, configs);
    }
    handleReservedArray(mergedConfigs) {
        if (mergedConfigs.options.enablePropertyObfuscation && mergedConfigs.reservedPropertyNames) {
            const propertyReservedInfo = (0, ArkObfuscator_1.separateUniversalReservedItem)(mergedConfigs.reservedPropertyNames);
            mergedConfigs.universalReservedPropertyNames = propertyReservedInfo.universalReservedArray;
            mergedConfigs.reservedPropertyNames = propertyReservedInfo.specificReservedArray;
        }
        if (mergedConfigs.options.enableToplevelObfuscation && mergedConfigs.reservedGlobalNames) {
            const globalReservedInfo = (0, ArkObfuscator_1.separateUniversalReservedItem)(mergedConfigs.reservedGlobalNames);
            mergedConfigs.universalReservedGlobalNames = globalReservedInfo.universalReservedArray;
            mergedConfigs.reservedGlobalNames = globalReservedInfo.specificReservedArray;
        }
    }
    handleReservedArrayForTest(mergedConfigs) {
        return this.handleReservedArray(mergedConfigs);
    }
    getTokenType(token) {
        switch (token) {
            case ObConfigResolver.KEEP_DTS:
                return OptionType.KEEP_DTS;
            case ObConfigResolver.KEEP_GLOBAL_NAME:
                return OptionType.KEEP_GLOBAL_NAME;
            case ObConfigResolver.KEEP_PROPERTY_NAME:
                return OptionType.KEEP_PROPERTY_NAME;
            case ObConfigResolver.KEEP_FILE_NAME:
                return OptionType.KEEP_FILE_NAME;
            case ObConfigResolver.KEEP_COMMENTS:
                return OptionType.KEEP_COMMENTS;
            case ObConfigResolver.DISABLE_OBFUSCATION:
                return OptionType.DISABLE_OBFUSCATION;
            case ObConfigResolver.ENABLE_PROPERTY_OBFUSCATION:
                return OptionType.ENABLE_PROPERTY_OBFUSCATION;
            case ObConfigResolver.ENABLE_STRING_PROPERTY_OBFUSCATION:
                return OptionType.ENABLE_STRING_PROPERTY_OBFUSCATION;
            case ObConfigResolver.ENABLE_TOPLEVEL_OBFUSCATION:
                return OptionType.ENABLE_TOPLEVEL_OBFUSCATION;
            case ObConfigResolver.ENABLE_FILENAME_OBFUSCATION:
                return OptionType.ENABLE_FILENAME_OBFUSCATION;
            case ObConfigResolver.ENABLE_EXPORT_OBFUSCATION:
                return OptionType.ENABLE_EXPORT_OBFUSCATION;
            case ObConfigResolver.REMOVE_COMMENTS:
                return OptionType.REMOVE_COMMENTS;
            case ObConfigResolver.COMPACT:
                return OptionType.COMPACT;
            case ObConfigResolver.REMOVE_LOG:
                return OptionType.REMOVE_LOG;
            case ObConfigResolver.PRINT_NAMECACHE:
                return OptionType.PRINT_NAMECACHE;
            case ObConfigResolver.PRINT_KEPT_NAMES:
                return OptionType.PRINT_KEPT_NAMES;
            case ObConfigResolver.APPLY_NAMECACHE:
                return OptionType.APPLY_NAMECACHE;
            case ObConfigResolver.KEEP:
                return OptionType.KEEP;
            default:
                return OptionType.NONE;
        }
    }
    getTokenTypeForTest(token) {
        return this.getTokenType(token);
    }
    handleConfigContent(data, configs, configPath) {
        data = this.removeComments(data);
        const tokens = data.split(/[',', '\t', ' ', '\n', '\r\n']/).filter((item) => item !== '');
        let type = OptionType.NONE;
        let tokenType;
        let dtsFilePaths = [];
        let keepConfigs = [];
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            tokenType = this.getTokenType(token);
            // handle switches cases
            switch (tokenType) {
                case OptionType.DISABLE_OBFUSCATION: {
                    configs.options.disableObfuscation = true;
                    continue;
                }
                case OptionType.ENABLE_PROPERTY_OBFUSCATION: {
                    configs.options.enablePropertyObfuscation = true;
                    continue;
                }
                case OptionType.ENABLE_STRING_PROPERTY_OBFUSCATION: {
                    configs.options.enableStringPropertyObfuscation = true;
                    continue;
                }
                case OptionType.ENABLE_TOPLEVEL_OBFUSCATION: {
                    configs.options.enableToplevelObfuscation = true;
                    continue;
                }
                case OptionType.REMOVE_COMMENTS: {
                    configs.options.removeComments = true;
                    continue;
                }
                case OptionType.ENABLE_FILENAME_OBFUSCATION: {
                    configs.options.enableFileNameObfuscation = true;
                    continue;
                }
                case OptionType.ENABLE_EXPORT_OBFUSCATION: {
                    configs.options.enableExportObfuscation = true;
                    continue;
                }
                case OptionType.COMPACT: {
                    configs.options.compact = true;
                    continue;
                }
                case OptionType.REMOVE_LOG: {
                    configs.options.removeLog = true;
                    continue;
                }
                case OptionType.PRINT_KEPT_NAMES: {
                    configs.options.printKeptNames = true;
                    type = tokenType;
                    continue;
                }
                case OptionType.KEEP:
                case OptionType.KEEP_DTS:
                case OptionType.KEEP_GLOBAL_NAME:
                case OptionType.KEEP_PROPERTY_NAME:
                case OptionType.KEEP_FILE_NAME:
                case OptionType.KEEP_COMMENTS:
                case OptionType.PRINT_NAMECACHE:
                case OptionType.APPLY_NAMECACHE:
                    type = tokenType;
                    continue;
                default: {
                    // fall-through
                }
            }
            // handle 'keep' options and 'namecache' options
            switch (type) {
                case OptionType.KEEP: {
                    keepConfigs.push(token);
                    continue;
                }
                case OptionType.KEEP_DTS: {
                    dtsFilePaths.push(token);
                    continue;
                }
                case OptionType.KEEP_GLOBAL_NAME: {
                    configs.reservedGlobalNames.push(token);
                    continue;
                }
                case OptionType.KEEP_PROPERTY_NAME: {
                    configs.reservedPropertyNames.push(token);
                    continue;
                }
                case OptionType.KEEP_FILE_NAME: {
                    configs.reservedFileNames.push(token);
                    continue;
                }
                case OptionType.KEEP_COMMENTS: {
                    configs.keepComments.push(token);
                    continue;
                }
                case OptionType.PRINT_NAMECACHE: {
                    configs.options.printNameCache = this.resolvePath(configPath, token);
                    type = OptionType.NONE;
                    continue;
                }
                case OptionType.PRINT_KEPT_NAMES: {
                    configs.options.printKeptNamesPath = this.resolvePath(configPath, token);
                    type = OptionType.NONE;
                    continue;
                }
                case OptionType.APPLY_NAMECACHE: {
                    const absNameCachePath = this.resolvePath(configPath, token);
                    this.determineNameCachePath(absNameCachePath, configPath);
                    configs.options.applyNameCache = absNameCachePath;
                    type = OptionType.NONE;
                    continue;
                }
                default:
                    continue;
            }
        }
        this.resolveDts(dtsFilePaths, configs);
        this.resolveKeepConfig(keepConfigs, configs, configPath);
    }
    handleConfigContentForTest(data, configs, configPath) {
        return this.handleConfigContent(data, configs, configPath);
    }
    // get absolute path
    resolvePath(configPath, token) {
        if (path_1.default.isAbsolute(token)) {
            return token;
        }
        const configDirectory = path_1.default.dirname(configPath);
        return path_1.default.resolve(configDirectory, token);
    }
    resolvePathForTest(configPath, token) {
        return this.resolvePath(configPath, token);
    }
    // get names in .d.ts files and add them into reserved list
    resolveDts(dtsFilePaths, configs) {
        ArkObfuscator_1.ApiExtractor.mPropertySet.clear();
        dtsFilePaths.forEach((token) => {
            ArkObfuscator_1.ApiExtractor.traverseApiFiles(token, ArkObfuscator_1.ApiExtractor.ApiType.KEEP_DTS);
        });
        configs.reservedNames = configs.reservedNames.concat([...ArkObfuscator_1.ApiExtractor.mPropertySet]);
        configs.reservedPropertyNames = configs.reservedPropertyNames.concat([...ArkObfuscator_1.ApiExtractor.mPropertySet]);
        configs.reservedGlobalNames = configs.reservedGlobalNames.concat([...ArkObfuscator_1.ApiExtractor.mPropertySet]);
        ArkObfuscator_1.ApiExtractor.mPropertySet.clear();
    }
    resolveKeepConfig(keepConfigs, configs, configPath) {
        for (let keepPath of keepConfigs) {
            let tempAbsPath;
            const isExclude = keepPath.startsWith('!');
            // 1: remove '!'
            tempAbsPath = FileUtils_1.FileUtils.getAbsPathBaseConfigPath(configPath, isExclude ? keepPath.substring(1) : keepPath);
            // contains '*', '?'
            if ((0, ArkObfuscator_1.containWildcards)(tempAbsPath)) {
                const regexPattern = (0, ArkObfuscator_1.wildcardTransformer)(tempAbsPath, true);
                const regexOperator = new RegExp(`^${regexPattern}$`);
                if (isExclude) {
                    // start with '!'
                    configs.excludeUniversalPaths.push(regexOperator);
                }
                else {
                    configs.keepUniversalPaths.push(regexOperator);
                }
                continue;
            }
            if (isExclude) {
                // exclude specific path
                configs.excludePathSet.add(tempAbsPath);
                continue;
            }
            if (!fs_1.default.existsSync(tempAbsPath)) {
                this.logger.warn(CommonObject_1.yellow + 'ArkTS: The path of obfuscation \'-keep\' configuration does not exist: ' + keepPath);
                continue;
            }
            tempAbsPath = fs_1.default.realpathSync(tempAbsPath);
            configs.keepSourceOfPaths.push(FileUtils_1.FileUtils.toUnixPath(tempAbsPath));
        }
    }
    // the content from '#' to '\n' are comments
    removeComments(data) {
        const commentStart = '#';
        const commentEnd = '\n';
        let tmpStr = '';
        let isInComments = false;
        for (let i = 0; i < data.length; i++) {
            if (isInComments) {
                isInComments = data[i] !== commentEnd;
            }
            else if (data[i] !== commentStart) {
                tmpStr += data[i];
            }
            else {
                isInComments = true;
            }
        }
        return tmpStr;
    }
    /**
     * systemConfigs includes the API directorys.
     * component directory and pre_define.js file path needs to be concatenated
     * @param systemConfigs
     */
    getSystemApiCache(systemConfigs, systemApiCachePath) {
        ArkObfuscator_1.ApiExtractor.mPropertySet.clear();
        ArkObfuscator_1.ApiExtractor.mSystemExportSet.clear();
        let arkUIWhitelist = { ReservedPropertyNames: [] };
        const sdkApis = (0, utils_1.sortAndDeduplicateStringArr)(this.sourceObConfig.sdkApis);
        for (let apiPath of sdkApis) {
            this.getSdkApiCache(apiPath);
            const UIPath = path_1.default.join(apiPath, '../build-tools/ets-loader/lib/pre_define.js');
            if (fs_1.default.existsSync(UIPath)) {
                this.getUIApiCache(UIPath);
            }
            const arkUIWhitelistPath = path_1.default.join(apiPath, '../build-tools/ets-loader/obfuscateWhiteList.json5');
            if (fs_1.default.existsSync(arkUIWhitelistPath)) {
                arkUIWhitelist = json5_1.default.parse(fs_1.default.readFileSync(arkUIWhitelistPath, 'utf-8'));
            }
        }
        let systemApiContent = {};
        if (systemConfigs.options.enablePropertyObfuscation) {
            const savedNameAndPropertySet = new Set([...ArkObfuscator_1.ApiExtractor.mPropertySet, ...arkUIWhitelist.ReservedPropertyNames]);
            CommonCollections_1.UnobfuscationCollections.reservedSdkApiForProp = savedNameAndPropertySet;
            CommonCollections_1.UnobfuscationCollections.reservedSdkApiForLocal = new Set(ArkObfuscator_1.ApiExtractor.mPropertySet);
            systemApiContent.ReservedPropertyNames = Array.from(savedNameAndPropertySet);
            systemApiContent.ReservedLocalNames = Array.from(ArkObfuscator_1.ApiExtractor.mPropertySet);
        }
        if (systemConfigs.options.enableToplevelObfuscation && systemConfigs.options.enableExportObfuscation) {
            const savedExportNamesSet = new Set(ArkObfuscator_1.ApiExtractor.mSystemExportSet);
            CommonCollections_1.UnobfuscationCollections.reservedSdkApiForGlobal = savedExportNamesSet;
            systemApiContent.ReservedGlobalNames = Array.from(savedExportNamesSet);
        }
        if (!fs_1.default.existsSync(path_1.default.dirname(systemApiCachePath))) {
            fs_1.default.mkdirSync(path_1.default.dirname(systemApiCachePath), { recursive: true });
        }
        fs_1.default.writeFileSync(systemApiCachePath, JSON.stringify(systemApiContent, null, 2));
        ArkObfuscator_1.ApiExtractor.mPropertySet.clear();
        ArkObfuscator_1.ApiExtractor.mSystemExportSet.clear();
    }
    getSystemApiCacheForTest(systemConfigs, systemApiCachePath) {
        return this.getSystemApiCache(systemConfigs, systemApiCachePath);
    }
    getSdkApiCache(sdkApiPath) {
        ArkObfuscator_1.ApiExtractor.traverseApiFiles(sdkApiPath, ArkObfuscator_1.ApiExtractor.ApiType.API);
        const componentPath = path_1.default.join(sdkApiPath, '../component');
        if (fs_1.default.existsSync(componentPath)) {
            ArkObfuscator_1.ApiExtractor.traverseApiFiles(componentPath, ArkObfuscator_1.ApiExtractor.ApiType.COMPONENT);
        }
    }
    getUIApiCache(uiApiPath) {
        ArkObfuscator_1.ApiExtractor.extractStringsFromFile(uiApiPath);
    }
    getDependencyConfigs(sourceObConfig, dependencyConfigs) {
        for (const lib of sourceObConfig.dependencies.libraries || []) {
            if (lib.consumerRules && lib.consumerRules.length > 0) {
                for (const path of lib.consumerRules) {
                    const thisLibConfigs = new MergedConfig();
                    this.getConfigByPath(path, dependencyConfigs);
                    dependencyConfigs.merge(thisLibConfigs);
                }
            }
        }
        if (sourceObConfig.dependencies &&
            sourceObConfig.dependencies.hars &&
            sourceObConfig.dependencies.hars.length > 0) {
            for (const path of sourceObConfig.dependencies.hars) {
                const thisHarConfigs = new MergedConfig();
                this.getConfigByPath(path, dependencyConfigs);
                dependencyConfigs.merge(thisHarConfigs);
            }
        }
    }
    getDependencyConfigsForTest(sourceObConfig, dependencyConfigs) {
        return this.getDependencyConfigs(sourceObConfig, dependencyConfigs);
    }
    getSystemApiConfigsByCache(systemApiCachePath) {
        let systemApiContent = JSON.parse(fs_1.default.readFileSync(systemApiCachePath, 'utf-8'));
        if (systemApiContent.ReservedPropertyNames) {
            CommonCollections_1.UnobfuscationCollections.reservedSdkApiForProp = new Set(systemApiContent.ReservedPropertyNames);
        }
        if (systemApiContent.ReservedGlobalNames) {
            CommonCollections_1.UnobfuscationCollections.reservedSdkApiForGlobal = new Set(systemApiContent.ReservedGlobalNames);
        }
        if (systemApiContent.ReservedLocalNames) {
            CommonCollections_1.UnobfuscationCollections.reservedSdkApiForLocal = new Set(systemApiContent.ReservedLocalNames);
        }
    }
    getSystemApiConfigsByCacheForTest(systemApiCachePath) {
        return this.getSystemApiConfigsByCache(systemApiCachePath);
    }
    getSelfConsumerConfig(selfConsumerConfig) {
        for (const path of this.sourceObConfig.selfConfig.consumerRules) {
            this.getConfigByPath(path, selfConsumerConfig);
        }
    }
    getSelfConsumerConfigForTest(selfConsumerConfig) {
        return this.getSelfConsumerConfig(selfConsumerConfig);
    }
    getMergedConfigs(selfConfigs, dependencyConfigs) {
        if (dependencyConfigs) {
            selfConfigs.merge(dependencyConfigs);
        }
        selfConfigs.sortAndDeduplicate();
        return selfConfigs;
    }
    getMergedConfigsForTest(selfConfigs, dependencyConfigs) {
        return this.getMergedConfigs(selfConfigs, dependencyConfigs);
    }
    genConsumerConfigFiles(sourceObConfig, selfConsumerConfig, dependencyConfigs) {
        selfConsumerConfig.merge(dependencyConfigs);
        selfConsumerConfig.sortAndDeduplicate();
        this.writeConsumerConfigFile(selfConsumerConfig, sourceObConfig.exportRulePath);
    }
    genConsumerConfigFilesForTest(sourceObConfig, selfConsumerConfig, dependencyConfigs) {
        return this.genConsumerConfigFiles(sourceObConfig, selfConsumerConfig, dependencyConfigs);
    }
    writeConsumerConfigFile(selfConsumerConfig, outpath) {
        const configContent = selfConsumerConfig.serializeMergedConfig();
        fs_1.default.writeFileSync(outpath, configContent);
    }
    determineNameCachePath(nameCachePath, configPath) {
        if (!fs_1.default.existsSync(nameCachePath)) {
            throw new Error(`The applied namecache file '${nameCachePath}' configured by '${configPath}' does not exist.`);
        }
    }
}
exports.ObConfigResolver = ObConfigResolver;
// obfuscation options
ObConfigResolver.KEEP = '-keep';
ObConfigResolver.KEEP_DTS = '-keep-dts';
ObConfigResolver.KEEP_GLOBAL_NAME = '-keep-global-name';
ObConfigResolver.KEEP_PROPERTY_NAME = '-keep-property-name';
ObConfigResolver.KEEP_FILE_NAME = '-keep-file-name';
ObConfigResolver.KEEP_COMMENTS = '-keep-comments';
ObConfigResolver.DISABLE_OBFUSCATION = '-disable-obfuscation';
ObConfigResolver.ENABLE_PROPERTY_OBFUSCATION = '-enable-property-obfuscation';
ObConfigResolver.ENABLE_STRING_PROPERTY_OBFUSCATION = '-enable-string-property-obfuscation';
ObConfigResolver.ENABLE_TOPLEVEL_OBFUSCATION = '-enable-toplevel-obfuscation';
ObConfigResolver.ENABLE_FILENAME_OBFUSCATION = '-enable-filename-obfuscation';
ObConfigResolver.ENABLE_EXPORT_OBFUSCATION = '-enable-export-obfuscation';
ObConfigResolver.REMOVE_COMMENTS = '-remove-comments';
ObConfigResolver.COMPACT = '-compact';
ObConfigResolver.REMOVE_LOG = '-remove-log';
ObConfigResolver.PRINT_NAMECACHE = '-print-namecache';
ObConfigResolver.PRINT_KEPT_NAMES = '-print-kept-names';
ObConfigResolver.APPLY_NAMECACHE = '-apply-namecache';
// renameFileName, printNameCache, applyNameCache, removeComments and keepComments won't be reserved in obfuscation.txt file.
ObConfigResolver.exportedSwitchMap = new Map([
    ['disableObfuscation', ObConfigResolver.KEEP_DTS],
    ['enablePropertyObfuscation', ObConfigResolver.ENABLE_PROPERTY_OBFUSCATION],
    ['enableStringPropertyObfuscation', ObConfigResolver.ENABLE_STRING_PROPERTY_OBFUSCATION],
    ['enableToplevelObfuscation', ObConfigResolver.ENABLE_TOPLEVEL_OBFUSCATION],
    ['compact', ObConfigResolver.COMPACT],
    ['removeLog', ObConfigResolver.REMOVE_LOG],
]);
/**
 * Collect reserved file name configured in oh-package.json5 and module.json5.
 * @param ohPackagePath The 'main' and 'types' fileds in oh-package.json5 need to be reserved.
 * @param projectConfig Several paths or file contents in projectconfig need to be reserved.
 *   1: module.json's 'srcEntry' field
 *   2: projectPath: /library/src/main/ets
 *   3: cachePath: /library/build/default/cache/default/default@HarCompileArkTs/esmodules/release
 *      target reserved path: /library/build/default/cache/default/default@HarCompileArkTs/esmodules/release/src/main/ets
 *   4: aceModuleBuild/etsFortgz directory: /library/build/default/intermediates/loader_out/etsFortgz
 *      If compile the hsp module, the declaration file will be written to the 'aceModuleBuild/etsFortgz' directory.
 * @param modulePathMap packageName of local har package should be reserved as it is a fixed part of ohmUrl.
 *   example: modulePathMap: { packageName: path }
 * @returns reservedFileNames
 */
function collectResevedFileNameInIDEConfig(ohPackagePath, projectConfig, modulePathMap, entryArray) {
    var _a, _b;
    const reservedFileNames = [];
    const moduleJsonPath = projectConfig.aceModuleJsonPath;
    const projectPath = projectConfig.projectPath;
    const cachePath = projectConfig.cachePath;
    if (entryArray) {
        entryArray.forEach((element) => {
            FileUtils_1.FileUtils.collectPathReservedString(element, reservedFileNames);
        });
    }
    if (modulePathMap) {
        const modulePaths = Object.values(modulePathMap);
        const moduleNames = Object.keys(modulePathMap);
        modulePaths.forEach((val) => {
            FileUtils_1.FileUtils.collectPathReservedString(val, reservedFileNames);
        });
        moduleNames.forEach((val) => {
            FileUtils_1.FileUtils.collectPathReservedString(val, reservedFileNames);
        });
    }
    if (fs_1.default.existsSync(ohPackagePath)) {
        const ohPackageContent = json5_1.default.parse(fs_1.default.readFileSync(ohPackagePath, 'utf-8'));
        ohPackageContent.main && FileUtils_1.FileUtils.collectPathReservedString(ohPackageContent.main, reservedFileNames);
        ohPackageContent.types && FileUtils_1.FileUtils.collectPathReservedString(ohPackageContent.types, reservedFileNames);
    }
    if (fs_1.default.existsSync(moduleJsonPath)) {
        const moduleJsonContent = json5_1.default.parse(fs_1.default.readFileSync(moduleJsonPath, 'utf-8'));
        ((_a = moduleJsonContent.module) === null || _a === void 0 ? void 0 : _a.srcEntry) &&
            FileUtils_1.FileUtils.collectPathReservedString((_b = moduleJsonContent.module) === null || _b === void 0 ? void 0 : _b.srcEntry, reservedFileNames);
    }
    if (projectConfig.compileShared || projectConfig.byteCodeHar) {
        FileUtils_1.FileUtils.collectPathReservedString(projectConfig.aceModuleBuild, reservedFileNames);
        reservedFileNames.push('etsFortgz');
    }
    FileUtils_1.FileUtils.collectPathReservedString(projectPath, reservedFileNames);
    FileUtils_1.FileUtils.collectPathReservedString(cachePath, reservedFileNames);
    return reservedFileNames;
}
exports.collectResevedFileNameInIDEConfig = collectResevedFileNameInIDEConfig;
function readNameCache(nameCachePath, logger) {
    try {
        const fileContent = fs_1.default.readFileSync(nameCachePath, 'utf-8');
        const nameCache = JSON.parse(fileContent);
        if (nameCache.PropertyCache) {
            ArkObfuscator_1.PropCollections.historyMangledTable = (0, ArkObfuscator_1.getMapFromJson)(nameCache.PropertyCache);
        }
        if (nameCache.FileNameCache) {
            ArkObfuscator_1.renameFileNameModule.historyFileNameMangledTable = (0, ArkObfuscator_1.getMapFromJson)(nameCache.FileNameCache);
        }
        const { compileSdkVersion, PropertyCache, FileNameCache } = nameCache, rest = __rest(nameCache, ["compileSdkVersion", "PropertyCache", "FileNameCache"]);
        Object.keys(rest).forEach((key) => {
            CommonObject_1.nameCacheMap.set(key, rest[key]);
        });
    }
    catch (err) {
        logger.error(`Failed to open ${nameCachePath}. Error message: ${err}`);
    }
}
exports.readNameCache = readNameCache;
/**
 * collect the reserved or excluded paths containing wildcards
 */
function handleUniversalPathInObf(mergedObConfig, allSourceFilePaths) {
    if (!mergedObConfig ||
        (mergedObConfig.keepUniversalPaths.length === 0 && mergedObConfig.excludeUniversalPaths.length === 0)) {
        return;
    }
    for (const realFilePath of allSourceFilePaths) {
        let isReserved = false;
        for (const universalPath of mergedObConfig.keepUniversalPaths) {
            if (universalPath.test(realFilePath)) {
                isReserved = true;
                break;
            }
        }
        for (const excludePath of mergedObConfig.excludeUniversalPaths) {
            if (excludePath.test(realFilePath)) {
                isReserved = false;
                mergedObConfig.excludePathSet.add(realFilePath);
                break;
            }
        }
        if (isReserved) {
            mergedObConfig.keepSourceOfPaths.push(realFilePath);
        }
    }
}
exports.handleUniversalPathInObf = handleUniversalPathInObf;
function getArkguardNameCache(enablePropertyObfuscation, enableFileNameObfuscation, enableExportObfuscation, sdkVersion, entryPackageInfo) {
    let writeContent = '';
    let nameCacheCollection = Object.fromEntries(CommonObject_1.nameCacheMap.entries());
    nameCacheCollection.compileSdkVersion = sdkVersion;
    nameCacheCollection.entryPackageInfo = entryPackageInfo;
    if (enablePropertyObfuscation || enableExportObfuscation) {
        const mergedPropertyNameCache = new Map();
        fillNameCache(ArkObfuscator_1.PropCollections.historyMangledTable, mergedPropertyNameCache);
        fillNameCache(ArkObfuscator_1.PropCollections.globalMangledTable, mergedPropertyNameCache);
        nameCacheCollection.PropertyCache = Object.fromEntries(mergedPropertyNameCache);
    }
    if (enableFileNameObfuscation) {
        const mergedFileNameCache = new Map();
        fillNameCache(ArkObfuscator_1.renameFileNameModule.historyFileNameMangledTable, mergedFileNameCache);
        fillNameCache(ArkObfuscator_1.renameFileNameModule.globalFileNameMangledTable, mergedFileNameCache);
        nameCacheCollection.FileNameCache = Object.fromEntries(mergedFileNameCache);
    }
    writeContent += JSON.stringify(nameCacheCollection, null, 2);
    return writeContent;
}
exports.getArkguardNameCache = getArkguardNameCache;
// export fillNameCache function
function fillNameCache(table, nameCache) {
    if (table) {
        for (const [key, value] of table.entries()) {
            nameCache.set(key, value);
        }
    }
    return;
}
exports.fillNameCache = fillNameCache;
function writeObfuscationNameCache(projectConfig, entryPackageInfo, obfuscationCacheDir, printNameCache) {
    if (!projectConfig.arkObfuscator) {
        return;
    }
    let options = projectConfig.obfuscationMergedObConfig.options;
    let writeContent = getArkguardNameCache(options.enablePropertyObfuscation, options.enableFileNameObfuscation, options.enableExportObfuscation, projectConfig.etsLoaderVersion, entryPackageInfo);
    if (obfuscationCacheDir && obfuscationCacheDir.length > 0) {
        const defaultNameCachePath = path_1.default.join(obfuscationCacheDir, 'nameCache.json');
        if (!fs_1.default.existsSync(path_1.default.dirname(defaultNameCachePath))) {
            fs_1.default.mkdirSync(path_1.default.dirname(defaultNameCachePath), { recursive: true });
        }
        fs_1.default.writeFileSync(defaultNameCachePath, writeContent);
    }
    if (printNameCache && printNameCache.length > 0) {
        fs_1.default.writeFileSync(printNameCache, writeContent);
    }
}
exports.writeObfuscationNameCache = writeObfuscationNameCache;
// Print unobfuscation names, reasons and whitelist, if -print-kept-names is enabled.
function writeUnobfuscationContent(projectConfig) {
    let obfuscationOptions = projectConfig.obfuscationMergedObConfig.options;
    let unobfuscationOptions = projectConfig.arkObfuscator.mCustomProfiles.mUnobfuscationOption;
    let nameOptions = projectConfig.arkObfuscator.mCustomProfiles.mNameObfuscation;
    if (!unobfuscationOptions.mPrintKeptNames) {
        return;
    }
    let configPath = unobfuscationOptions.mPrintPath;
    let printDir = projectConfig.obfuscationOptions.obfuscationCacheDir;
    let printUnobfPath = path_1.default.join(printDir, 'keptNames.json');
    printUnobfuscationReasons(configPath, printUnobfPath);
    let printWhitelistPath = path_1.default.join(printDir, 'whitelist.json');
    printWhitelist(obfuscationOptions, nameOptions, printWhitelistPath);
}
exports.writeUnobfuscationContent = writeUnobfuscationContent;
// Merge similar whitelists and output according to whether the corresponding options are enabled.
function printWhitelist(obfuscationOptions, nameOptions, defaultPath) {
    var _a, _b;
    const enableToplevel = obfuscationOptions.enableToplevelObfuscation;
    const enableProperty = obfuscationOptions.enablePropertyObfuscation;
    const enableStringProp = obfuscationOptions.enableStringPropertyObfuscation;
    const enableExport = obfuscationOptions.enableExportObfuscation;
    const reservedConfToplevelArrary = (_a = nameOptions.mReservedToplevelNames) !== null && _a !== void 0 ? _a : [];
    const reservedConfPropertyArray = (_b = nameOptions.mReservedProperties) !== null && _b !== void 0 ? _b : [];
    let whitelistObj = {
        lang: [],
        conf: [],
        struct: [],
        exported: [],
        strProp: [],
        enum: []
    };
    let languareSet;
    if (enableProperty) {
        languareSet = (0, utils_1.mergeSet)(CommonCollections_1.UnobfuscationCollections.reservedLangForProperty, CommonCollections_1.LocalVariableCollections.reservedLangForLocal);
    }
    else {
        languareSet = CommonCollections_1.LocalVariableCollections.reservedLangForLocal;
    }
    whitelistObj.lang = (0, utils_1.convertSetToArray)(languareSet);
    let structSet;
    if (enableProperty) {
        structSet = (0, utils_1.mergeSet)(CommonCollections_1.UnobfuscationCollections.reservedStruct, CommonCollections_1.LocalVariableCollections.reservedStruct);
    }
    else {
        structSet = CommonCollections_1.LocalVariableCollections.reservedStruct;
    }
    whitelistObj.struct = (0, utils_1.convertSetToArray)(structSet);
    let exportedSet;
    if (enableProperty) {
        exportedSet = CommonCollections_1.UnobfuscationCollections.reservedExportNameAndProp;
    }
    else if (enableExport) {
        exportedSet = CommonCollections_1.UnobfuscationCollections.reservedExportName;
    }
    whitelistObj.exported = (0, utils_1.convertSetToArray)(exportedSet);
    let stringSet;
    if (enableProperty && !enableStringProp) {
        stringSet = CommonCollections_1.UnobfuscationCollections.reservedStrProp;
    }
    whitelistObj.strProp = (0, utils_1.convertSetToArray)(stringSet);
    whitelistObj.conf = (0, utils_1.convertSetToArray)(CommonCollections_1.LocalVariableCollections.reservedConfig);
    const hasPropertyConfig = enableProperty && (reservedConfPropertyArray === null || reservedConfPropertyArray === void 0 ? void 0 : reservedConfPropertyArray.length) > 0;
    const hasTopLevelConfig = enableToplevel && (reservedConfToplevelArrary === null || reservedConfToplevelArrary === void 0 ? void 0 : reservedConfToplevelArrary.length) > 0;
    if (hasPropertyConfig) {
        whitelistObj.conf.push(...reservedConfPropertyArray);
        handleUniversalReservedList(nameOptions.mUniversalReservedProperties, whitelistObj.conf);
    }
    if (hasTopLevelConfig) {
        whitelistObj.conf.push(...reservedConfToplevelArrary);
        handleUniversalReservedList(nameOptions.mUniversalReservedToplevelNames, whitelistObj.conf);
    }
    let enumSet;
    if (enableProperty) {
        enumSet = CommonCollections_1.UnobfuscationCollections.reservedEnum;
    }
    whitelistObj.enum = (0, utils_1.convertSetToArray)(enumSet);
    let whitelistContent = JSON.stringify(whitelistObj, null, 2); // 2: indentation
    if (!fs_1.default.existsSync(path_1.default.dirname(defaultPath))) {
        fs_1.default.mkdirSync(path_1.default.dirname(defaultPath), { recursive: true });
    }
    fs_1.default.writeFileSync(defaultPath, whitelistContent);
}
exports.printWhitelist = printWhitelist;
function handleUniversalReservedList(universalList, configArray) {
    if ((universalList === null || universalList === void 0 ? void 0 : universalList.length) > 0) {
        universalList.forEach((value) => {
            const originalString = CommonCollections_1.UnobfuscationCollections.reservedWildcardMap.get(value);
            if (originalString) {
                configArray.push(originalString);
            }
        });
    }
}
// Merge KeptReasons and KeptNames and output
function printUnobfuscationReasons(configPath, defaultPath) {
    let property = {};
    let unobfuscationObj = { keptReasons: {}, keptNames: { property } };
    let keptReasons = {
        sdk: 'same as the system api names',
        lang: 'same as the language keywords',
        conf: 'same as the user-configured kept name',
        struct: 'same as the ArkUI struct property',
        strProp: 'same as the string property',
        exported: 'same as the exported names and properties',
        enum: 'same as the members in the enum'
    };
    unobfuscationObj.keptReasons = keptReasons;
    if (!Initializer_1.historyUnobfuscatedPropMap) {
        // Full build
        CommonCollections_1.UnobfuscationCollections.unobfuscatedPropMap.forEach((value, key) => {
            let array = Array.from(value);
            unobfuscationObj.keptNames.property[key] = array;
        });
    }
    else {
        // Incremental build
        CommonCollections_1.UnobfuscationCollections.unobfuscatedPropMap.forEach((value, key) => {
            let array = Array.from(value);
            Initializer_1.historyUnobfuscatedPropMap.set(key, array);
        });
        Initializer_1.historyUnobfuscatedPropMap.forEach((value, key) => {
            unobfuscationObj.keptNames.property[key] = value;
        });
    }
    Object.assign(unobfuscationObj.keptNames, CommonObject_1.unobfuscationNamesObj);
    let unobfuscationContent = JSON.stringify(unobfuscationObj, null, 2);
    if (!fs_1.default.existsSync(path_1.default.dirname(defaultPath))) {
        fs_1.default.mkdirSync(path_1.default.dirname(defaultPath), { recursive: true });
    }
    fs_1.default.writeFileSync(defaultPath, unobfuscationContent);
    if (!fs_1.default.existsSync(path_1.default.dirname(configPath))) {
        fs_1.default.mkdirSync(path_1.default.dirname(configPath), { recursive: true });
    }
    if (configPath) {
        fs_1.default.copyFileSync(defaultPath, configPath);
    }
}
exports.printUnobfuscationReasons = printUnobfuscationReasons;
function generateConsumerObConfigFile(obfuscationOptions, logger) {
    const projectConfig = { obfuscationOptions, compileHar: true };
    const obConfig = new ObConfigResolver(projectConfig, logger);
    obConfig.resolveObfuscationConfigs();
}
exports.generateConsumerObConfigFile = generateConsumerObConfigFile;
function mangleFilePath(originalPath) {
    const mangledFilePath = ArkObfuscator_1.renameFileNameModule.getMangleCompletePath(originalPath);
    return mangledFilePath;
}
exports.mangleFilePath = mangleFilePath;
function enableObfuscatedFilePathConfig(isPackageModules, projectConfig) {
    const isDebugMode = (0, utils_1.isDebug)(projectConfig);
    const hasObfuscationConfig = projectConfig.obfuscationMergedObConfig;
    if (isDebugMode || !hasObfuscationConfig) {
        return false;
    }
    const disableObfuscation = hasObfuscationConfig.options.disableObfuscation;
    const enableFileNameObfuscation = hasObfuscationConfig.options.enableFileNameObfuscation;
    if (disableObfuscation || !enableFileNameObfuscation) {
        return false;
    }
    return true;
}
exports.enableObfuscatedFilePathConfig = enableObfuscatedFilePathConfig;
function handleObfuscatedFilePath(filePath, isPackageModules, projectConfig) {
    if (!enableObfuscatedFilePathConfig(isPackageModules, projectConfig)) {
        return filePath;
    }
    // Do not obfuscate the file path in dir oh_modules.
    if (!isPackageModules) {
        return mangleFilePath(filePath);
    }
    // When open the config 'enableFileNameObfuscation', keeping all paths in unix format.
    return FileUtils_1.FileUtils.toUnixPath(filePath);
}
exports.handleObfuscatedFilePath = handleObfuscatedFilePath;
function enableObfuscateFileName(isPackageModules, projectConfig) {
    if (!enableObfuscatedFilePathConfig(isPackageModules, projectConfig)) {
        return false;
    }
    // Do not obfuscate the file path in dir oh_modules.
    if (!isPackageModules) {
        return true;
    }
    // When open the config 'enableFileNameObfuscation', keeping all paths in unix format.
    return false;
}
exports.enableObfuscateFileName = enableObfuscateFileName;
/**
 * Get the relative path relative to the project based on the file's associated project
 */
function getRelativeSourcePath(filePath, projectRootPath, belongProjectPath) {
    filePath = FileUtils_1.FileUtils.toUnixPath(filePath);
    if (projectRootPath) {
        projectRootPath = FileUtils_1.FileUtils.toUnixPath(projectRootPath);
    }
    if (belongProjectPath) {
        belongProjectPath = FileUtils_1.FileUtils.toUnixPath(belongProjectPath);
    }
    let relativeFilePath = filePath;
    if (projectRootPath && filePath.startsWith(projectRootPath)) {
        relativeFilePath = filePath.replace(projectRootPath + '/', '');
    }
    else if (belongProjectPath) {
        relativeFilePath = filePath.replace(belongProjectPath + '/', '');
    }
    return relativeFilePath;
}
exports.getRelativeSourcePath = getRelativeSourcePath;
//# sourceMappingURL=ConfigResolver.js.map