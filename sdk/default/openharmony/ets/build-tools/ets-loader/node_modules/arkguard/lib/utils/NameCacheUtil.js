"use strict";
/*
 * Copyright (c) 2023-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateMemberMethodName = exports.deleteLineInfoForNameString = exports.getMapFromJson = exports.readCache = exports.writeCache = exports.spaceOfNameCache = exports.MEM_METHOD_CACHE = exports.IDENTIFIER_CACHE = exports.PROPERTY_CACHE_FILE = exports.NAME_CACHE_SUFFIX = void 0;
const FileUtils_1 = require("./FileUtils");
exports.NAME_CACHE_SUFFIX = '.cache.json';
exports.PROPERTY_CACHE_FILE = 'property.cache.json';
exports.IDENTIFIER_CACHE = 'IdentifierCache';
exports.MEM_METHOD_CACHE = 'MemberMethodCache';
exports.spaceOfNameCache = 2;
function writeCache(cache, destFileName) {
    // convert map to json string
    if (!cache) {
        return;
    }
    const cacheString = JSON.stringify(Object.fromEntries(cache), null, exports.spaceOfNameCache);
    FileUtils_1.FileUtils.writeFile(destFileName, cacheString);
}
exports.writeCache = writeCache;
function readCache(filePath) {
    // read json string from file
    const cacheString = FileUtils_1.FileUtils.readFile(filePath);
    if (cacheString === undefined) {
        return undefined;
    }
    // get map from json string
    return JSON.parse(cacheString);
}
exports.readCache = readCache;
function getMapFromJson(jsonObj) {
    if (jsonObj === undefined) {
        return new Map();
    }
    return new Map(Object.entries(jsonObj));
}
exports.getMapFromJson = getMapFromJson;
function deleteLineInfoForNameString(historyNameCache, identifierCache) {
    if (identifierCache) {
        for (const [key, value] of Object.entries(identifierCache)) {
            let newKey = key.includes(':') ? key.split(':')[0] : key;
            historyNameCache.set(newKey, value);
        }
    }
}
exports.deleteLineInfoForNameString = deleteLineInfoForNameString;
// The original name of the member method is recorded during the identifier obfuscation.
// After the property obfuscation, it needs to be updated to the mangled name.
function UpdateMemberMethodName(nameCache, globalMangledTable, classInfoInMemberMethodCache) {
    let memberMethodCache = nameCache.get(exports.MEM_METHOD_CACHE);
    if (!memberMethodCache) {
        return;
    }
    // the valueName is the orignal name of member method.
    for (const [key, valueName] of memberMethodCache.entries()) {
        // It is used to prevent the class name from being updated incorrectly, since the obfuscated class name
        // is recorded during identifier obfuscation.
        if (classInfoInMemberMethodCache.has(key)) {
            continue;
        }
        const mangledName = globalMangledTable.get(valueName);
        if (mangledName) {
            memberMethodCache.set(key, mangledName);
        }
    }
}
exports.UpdateMemberMethodName = UpdateMemberMethodName;
//# sourceMappingURL=NameCacheUtil.js.map