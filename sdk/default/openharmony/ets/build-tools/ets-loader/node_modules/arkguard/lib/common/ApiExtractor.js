"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiExtractor = void 0;
const typescript_1 = require("typescript");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const json5_1 = __importDefault(require("json5"));
const OhsUtil_1 = require("../utils/OhsUtil");
const ApiReader_1 = require("./ApiReader");
const OhsUtil_2 = require("../utils/OhsUtil");
const FileUtils_1 = require("../utils/FileUtils");
const type_1 = require("./type");
var ApiExtractor;
(function (ApiExtractor) {
    let ApiType;
    (function (ApiType) {
        ApiType[ApiType["API"] = 0] = "API";
        ApiType[ApiType["COMPONENT"] = 1] = "COMPONENT";
        ApiType[ApiType["PROJECT"] = 2] = "PROJECT";
        ApiType[ApiType["CONSTRUCTOR_PROPERTY"] = 3] = "CONSTRUCTOR_PROPERTY";
        ApiType[ApiType["KEEP_DTS"] = 4] = "KEEP_DTS";
    })(ApiType = ApiExtractor.ApiType || (ApiExtractor.ApiType = {}));
    let mCurrentExportedPropertySet = new Set();
    let mCurrentExportNameSet = new Set();
    ApiExtractor.mPropertySet = new Set();
    ApiExtractor.mExportNames = new Set();
    ApiExtractor.mConstructorPropertySet = undefined;
    ApiExtractor.mEnumMemberSet = new Set();
    ApiExtractor.mSystemExportSet = new Set();
    /**
     * filter classes or interfaces with export, default, etc
     */
    const getKeyword = function (modifiers) {
        if (modifiers === undefined) {
            return { hasExport: false, hasDeclare: false };
        }
        let hasExport = false;
        let hasDeclare = false;
        for (const modifier of modifiers) {
            if (modifier.kind === typescript_1.SyntaxKind.ExportKeyword) {
                hasExport = true;
            }
            if (modifier.kind === typescript_1.SyntaxKind.DeclareKeyword) {
                hasDeclare = true;
            }
        }
        return { hasExport: hasExport, hasDeclare: hasDeclare };
    };
    /**
     * get export name list
     * @param astNode
     */
    const visitExport = function (astNode, isSystemApi) {
        /**
         * export = exportClass //collect exportClass
         *
         * function foo()
         * export default foo //collect foo
         */
        if ((0, typescript_1.isExportAssignment)(astNode)) {
            let nodeName = astNode.expression.getText();
            if (!mCurrentExportNameSet.has(nodeName)) {
                collectNodeName(nodeName);
            }
            return;
        }
        if ((0, typescript_1.isExportDeclaration)(astNode) && astNode.exportClause) {
            /**
             * export {name1, name2} //collect name1, name2
             * export {name1 as n1, name2} //collect n1, name2
             * export {name1 as default, name2, name3} //collect default, name2, name3
             */
            if ((0, typescript_1.isNamedExports)(astNode.exportClause)) {
                for (const element of astNode.exportClause.elements) {
                    const exportElementName = element.name.getText();
                    if (!mCurrentExportNameSet.has(exportElementName)) {
                        collectNodeName(exportElementName);
                    }
                }
            }
            /**
             * export * as name1 from 'file.ts' //collect name1
             */
            if ((0, typescript_1.isNamespaceExport)(astNode.exportClause)) {
                const exportElementName = astNode.exportClause.name.getText();
                if (!mCurrentExportNameSet.has(exportElementName)) {
                    collectNodeName(exportElementName);
                }
            }
            /**
            * Other export syntax, which does not contain a name. such as:
            * export * from 'file.ts'
            */
            return;
        }
        let { hasExport, hasDeclare } = getKeyword(astNode.modifiers);
        if (!hasExport) {
            addCommonJsExports(astNode, isSystemApi);
            return;
        }
        if (astNode.name) {
            let nodeName = astNode.name.getText();
            if (!mCurrentExportNameSet.has(nodeName)) {
                collectNodeName(nodeName);
            }
            return;
        }
        if (hasDeclare && astNode.declarationList) {
            astNode.declarationList.declarations.forEach((declaration) => {
                const declarationName = declaration.name.getText();
                if (!mCurrentExportNameSet.has(declarationName)) {
                    collectNodeName(declarationName);
                }
            });
        }
    };
    const isCollectedToplevelElements = function (astNode) {
        if (astNode.name && !mCurrentExportNameSet.has(astNode.name.getText())) {
            return false;
        }
        if (astNode.name === undefined) {
            let { hasDeclare } = getKeyword(astNode.modifiers);
            if (hasDeclare && astNode.declarationList &&
                !mCurrentExportNameSet.has(astNode.declarationList.declarations[0].name.getText())) {
                return false;
            }
        }
        return true;
    };
    /**
     * used only in oh sdk api extract or api of xxx.d.ts declaration file
     * @param astNode
     */
    const visitChildNode = function (astNode) {
        if (!astNode) {
            return;
        }
        if (astNode.name !== undefined && !mCurrentExportedPropertySet.has(astNode.name.getText())) {
            if ((0, typescript_1.isStringLiteral)(astNode.name)) {
                mCurrentExportedPropertySet.add(astNode.name.text);
            }
            else {
                mCurrentExportedPropertySet.add(astNode.name.getText());
            }
        }
        astNode.forEachChild((childNode) => {
            visitChildNode(childNode);
        });
    };
    // Collect constructor properties from all files.
    const visitNodeForConstructorProperty = function (astNode) {
        var _a;
        if (!astNode) {
            return;
        }
        if ((0, typescript_1.isConstructorDeclaration)(astNode)) {
            const visitParam = (param) => {
                const modifiers = (0, typescript_1.getModifiers)(param);
                if (!modifiers || modifiers.length <= 0) {
                    return;
                }
                const findRet = modifiers.find(modifier => (0, OhsUtil_1.isParameterPropertyModifier)(modifier));
                if (!(0, typescript_1.isIdentifier)(param.name) || findRet === undefined) {
                    return;
                }
                ApiExtractor.mConstructorPropertySet === null || ApiExtractor.mConstructorPropertySet === void 0 ? void 0 : ApiExtractor.mConstructorPropertySet.add(param.name.getText());
            };
            (_a = astNode === null || astNode === void 0 ? void 0 : astNode.parameters) === null || _a === void 0 ? void 0 : _a.forEach((param) => {
                visitParam(param);
            });
        }
        astNode.forEachChild((childNode) => {
            visitNodeForConstructorProperty(childNode);
        });
    };
    /**
     * visit ast of a file and collect api list
     * used only in oh sdk api extract
     * @param astNode node of ast
     */
    const visitPropertyAndName = function (astNode) {
        if (!isCollectedToplevelElements(astNode)) {
            /**
             * Collects property names of elements within top-level elements that haven't been collected yet.
             * @param astNode toplevel elements of sourcefile
             */
            collectPropertyNames(astNode);
            return;
        }
        visitChildNode(astNode);
    };
    /**
     * commonjs exports extract
     * examples:
     * - exports.A = 1;
     * - exports.B = hello; // hello can be variable or class ...
     * - exports.C = {};
     * - exports.D = class {};
     * - exports.E = function () {}
     * - class F {}
     * - exports.F = F;
     * - module.exports = {G: {}};
     */
    const addCommonJsExports = function (astNode, isRemoteHarOrSystemApi = false) {
        if (!(0, typescript_1.isExpressionStatement)(astNode) || !astNode.expression) {
            return;
        }
        const expression = astNode.expression;
        if (!(0, typescript_1.isBinaryExpression)(expression)) {
            return;
        }
        const left = expression.left;
        if (!(0, typescript_1.isElementAccessExpression)(left) && !(0, typescript_1.isPropertyAccessExpression)(left)) {
            return;
        }
        if (!isModuleExports(left) || expression.operatorToken.kind !== typescript_1.SyntaxKind.EqualsToken) {
            return;
        }
        if ((0, typescript_1.isElementAccessExpression)(left)) {
            if ((0, typescript_1.isStringLiteral)(left.argumentExpression)) {
                /**
                 * - module.exports['A'] = class {};
                 * - module.exports['a'] = {};
                 * - module.exports['a'] = A;
                 */
                mCurrentExportedPropertySet.add(left.argumentExpression.text);
                mCurrentExportNameSet.add(left.argumentExpression.text);
            }
        }
        if ((0, typescript_1.isPropertyAccessExpression)(left)) {
            if ((0, typescript_1.isIdentifier)(left.name)) {
                /**
                 * - module.exports.A = a;
                 * - module.exports.A = {};
                 * - module.exports.A = class {};
                 */
                mCurrentExportedPropertySet.add(left.name.getText());
                mCurrentExportNameSet.add(left.name.getText());
            }
        }
        if ((0, typescript_1.isIdentifier)(expression.right)) {
            /**
             * module.exports.A = a;
             * exports.A = a;
             * module.exports = a;
             */
            let originalName = expression.right.getText();
            if (isRemoteHarOrSystemApi) {
                // To achieve compatibility changes, originalName is still collected into mCurrentExportNameSet
                // for both remoteHar and system API files.
                // NOTE: This logic will be optimized later to avoid collecting originalName into mCurrentExportNameSet under any circumstances.
                mCurrentExportNameSet.add(originalName);
            }
            else {
                OhsUtil_1.exportOriginalNameSet.add(originalName);
            }
            return;
        }
        if ((0, typescript_1.isClassDeclaration)(expression.right) || (0, typescript_1.isClassExpression)(expression.right)) {
            /**
             * module.exports.A = class testClass {}
             * module.exports = class testClass {}
             * exports.A = class testClass {}
             * module.exports.A = class {}
             */
            (0, OhsUtil_1.getClassProperties)(expression.right, mCurrentExportedPropertySet);
            return;
        }
        if ((0, typescript_1.isObjectLiteralExpression)(expression.right)) {
            /**
             * module.exports = {a, b, c};
             * module.exports.A = {a, b, c};
             * exports.A = {a, b, c}
             */
            (0, OhsUtil_1.getObjectProperties)(expression.right, mCurrentExportedPropertySet);
            // module.exports = {a, b, c}, {a, b, c} as the export content of the module
            let defaultExport = left.expression.getText() === 'module';
            if (defaultExport) {
                (0, OhsUtil_1.getObjectExportNames)(expression.right, mCurrentExportNameSet);
            }
            return;
        }
        return;
    };
    function isModuleExports(leftExpression) {
        let leftExpressionText = leftExpression.expression.getText();
        if ((0, typescript_1.isPropertyAccessExpression)(leftExpression.expression)) {
            /**
             * For example:
             * module.exports.a = A;
             * module.exports['a'] = A;
             */
            return leftExpressionText === 'module.exports';
        }
        if ((0, typescript_1.isIdentifier)(leftExpression.expression)) {
            if (leftExpressionText === 'module') {
                // module.exports = {A}, A as the export content of the module
                if ((0, typescript_1.isPropertyAccessExpression)(leftExpression) && leftExpression.name.getText() === 'exports') {
                    return true;
                }
            }
            /**
             * For example:
             * exports.a = A;
             */
            return leftExpressionText === 'exports';
        }
        return false;
    }
    ;
    /**
     * extract project export name
     * - export {xxx, xxx};
     * - export {xxx as xx, xxx as xx};
     * - export default function/class/...{};
     * - export class xxx{}
     * - ...
     * @param astNode
     */
    const visitProjectExport = function (astNode, isRemoteHarFile) {
        if ((0, typescript_1.isExportAssignment)(astNode)) {
            handleExportAssignment(astNode);
            return;
        }
        if ((0, typescript_1.isExportDeclaration)(astNode)) {
            handleExportDeclaration(astNode, isRemoteHarFile);
            return;
        }
        let { hasExport } = getKeyword(astNode.modifiers);
        if (!hasExport) {
            addCommonJsExports(astNode, isRemoteHarFile);
            (0, typescript_1.forEachChild)(astNode, node => visitProjectExport(node, isRemoteHarFile));
            return;
        }
        if (astNode.name) {
            if (!mCurrentExportNameSet.has(astNode.name.getText())) {
                mCurrentExportNameSet.add(astNode.name.getText());
                mCurrentExportedPropertySet.add(astNode.name.getText());
            }
            (0, typescript_1.forEachChild)(astNode, node => visitProjectExport(node, isRemoteHarFile));
            return;
        }
        if ((0, typescript_1.isClassDeclaration)(astNode)) {
            (0, OhsUtil_1.getClassProperties)(astNode, mCurrentExportedPropertySet);
            return;
        }
        if ((0, typescript_1.isVariableStatement)(astNode)) {
            astNode.declarationList.forEachChild((child) => {
                if ((0, typescript_1.isVariableDeclaration)(child) && !mCurrentExportNameSet.has(child.name.getText())) {
                    mCurrentExportNameSet.add(child.name.getText());
                    mCurrentExportedPropertySet.add(child.name.getText());
                }
            });
            return;
        }
        (0, typescript_1.forEachChild)(astNode, node => visitProjectExport(node, isRemoteHarFile));
    };
    function handleExportAssignment(astNode) {
        // let xxx; export default xxx = a;
        if ((0, typescript_1.isBinaryExpression)(astNode.expression)) {
            if ((0, typescript_1.isObjectLiteralExpression)(astNode.expression.right)) {
                (0, OhsUtil_1.getObjectProperties)(astNode.expression.right, mCurrentExportedPropertySet);
                return;
            }
            if ((0, typescript_1.isClassExpression)(astNode.expression.right)) {
                (0, OhsUtil_1.getClassProperties)(astNode.expression.right, mCurrentExportedPropertySet);
            }
            return;
        }
        // export = xxx; The xxx here can't be obfuscated
        // export default yyy; The yyy here can be obfuscated
        if ((0, typescript_1.isIdentifier)(astNode.expression)) {
            if (!mCurrentExportNameSet.has(astNode.expression.getText())) {
                mCurrentExportNameSet.add(astNode.expression.getText());
                mCurrentExportedPropertySet.add(astNode.expression.getText());
            }
            return;
        }
        if ((0, typescript_1.isObjectLiteralExpression)(astNode.expression)) {
            (0, OhsUtil_1.getObjectProperties)(astNode.expression, mCurrentExportedPropertySet);
        }
    }
    function handleExportDeclaration(astNode, isRemoteHarFile) {
        if (astNode.exportClause) {
            if (astNode.exportClause.kind === typescript_1.SyntaxKind.NamedExports) {
                astNode.exportClause.forEachChild((child) => {
                    if (!(0, typescript_1.isExportSpecifier)(child)) {
                        return;
                    }
                    if (child.propertyName) {
                        let originalName = child.propertyName.getText();
                        if (isRemoteHarFile || astNode.moduleSpecifier) {
                            // For the first condition, this ensures that for remoteHar files,
                            // originalName is still collected into mCurrentExportNameSet to maintain compatibility.
                            // NOTE: This specification needs to be revised to determine whether to add originalName
                            // to mCurrentExportNameSet should be independent of whether it is in a remoteHar file.
                            // The second condition indicates that for `export {A as B} from './filePath'` statements,
                            // the original name (A) needs to be added to the export whitelist.
                            mCurrentExportNameSet.add(originalName);
                        }
                        else {
                            /**
                             * In project source code:
                             * class A {
                             *   prop1 = 1;
                             *   prop2 = 2;
                             * }
                             * export {A as B}; // collect A to ensure we can collect prop1 and prop2
                             */
                            OhsUtil_1.exportOriginalNameSet.add(originalName);
                        }
                    }
                    let exportName = child.name.getText();
                    mCurrentExportedPropertySet.add(exportName);
                    mCurrentExportNameSet.add(exportName);
                });
            }
            if (astNode.exportClause.kind === typescript_1.SyntaxKind.NamespaceExport) {
                mCurrentExportedPropertySet.add(astNode.exportClause.name.getText());
                return;
            }
        }
    }
    /**
     * extract the class, enum, and object properties of the export in the project before obfuscation
     * class A{};
     * export = A; need to be considered
     * export = namespace;
     * This statement also needs to determine whether there is an export in the namespace, and namespaces are also allowed in the namespace
     * @param astNode
     */
    const visitProjectNode = function (astNode) {
        var _a, _b;
        const currentPropsSet = new Set();
        let nodeName = (_a = astNode.name) === null || _a === void 0 ? void 0 : _a.text;
        if (((0, typescript_1.isClassDeclaration)(astNode) || (0, typescript_1.isStructDeclaration)(astNode))) {
            (0, OhsUtil_1.getClassProperties)(astNode, currentPropsSet);
        }
        else if ((0, typescript_1.isEnumDeclaration)(astNode)) { // collect export enum structure properties
            (0, OhsUtil_1.getEnumProperties)(astNode, currentPropsSet);
        }
        else if ((0, typescript_1.isVariableDeclaration)(astNode)) {
            if (astNode.initializer) {
                if ((0, typescript_1.isObjectLiteralExpression)(astNode.initializer)) {
                    (0, OhsUtil_1.getObjectProperties)(astNode.initializer, currentPropsSet);
                }
                else if ((0, typescript_1.isClassExpression)(astNode.initializer)) {
                    (0, OhsUtil_1.getClassProperties)(astNode.initializer, currentPropsSet);
                }
            }
            nodeName = (_b = astNode.name) === null || _b === void 0 ? void 0 : _b.getText();
        }
        else if ((0, typescript_1.isInterfaceDeclaration)(astNode)) {
            (0, OhsUtil_1.getInterfaceProperties)(astNode, currentPropsSet);
        }
        else if ((0, typescript_1.isTypeAliasDeclaration)(astNode)) {
            (0, OhsUtil_1.getTypeAliasProperties)(astNode, currentPropsSet);
        }
        else if ((0, typescript_1.isElementAccessExpression)(astNode)) {
            (0, OhsUtil_1.getElementAccessExpressionProperties)(astNode);
        }
        else if ((0, typescript_1.isIndexedAccessTypeNode)(astNode)) {
            (0, OhsUtil_1.getIndexedAccessTypeProperties)(astNode);
        }
        else if ((0, typescript_1.isObjectLiteralExpression)(astNode)) {
            (0, OhsUtil_1.getObjectProperties)(astNode, currentPropsSet);
        }
        else if ((0, typescript_1.isClassExpression)(astNode)) {
            (0, OhsUtil_1.getClassProperties)(astNode, currentPropsSet);
        }
        addPropWhiteList(nodeName, astNode, currentPropsSet);
        (0, typescript_1.forEachChild)(astNode, visitProjectNode);
    };
    function addPropWhiteList(nodeName, astNode, currentPropsSet) {
        if (nodeName && (mCurrentExportNameSet.has(nodeName) || OhsUtil_1.exportOriginalNameSet.has(nodeName))) {
            addElement(currentPropsSet);
        }
        if (ApiReader_1.scanProjectConfig.isHarCompiled && ApiReader_1.scanProjectConfig.mPropertyObfuscation && (0, typescript_1.isEnumDeclaration)(astNode)) {
            addEnumElement(currentPropsSet);
        }
    }
    function addElement(currentPropsSet) {
        currentPropsSet.forEach((element) => {
            mCurrentExportedPropertySet.add(element);
        });
    }
    function addEnumElement(currentPropsSet) {
        currentPropsSet.forEach((element) => {
            OhsUtil_2.enumPropsSet.add(element);
        });
    }
    /**
     * parse file to api list and save to json object
     * @param fileName file name of api file
     * @param apiType
     * @private
     */
    const parseFile = function (fileName, apiType) {
        if (!FileUtils_1.FileUtils.isReadableFile(fileName) || !isParsableFile(fileName)) {
            return;
        }
        const sourceFile = (0, typescript_1.createSourceFile)(fileName, fs_1.default.readFileSync(fileName).toString(), typescript_1.ScriptTarget.ES2015, true);
        mCurrentExportedPropertySet.clear();
        // get export name list
        switch (apiType) {
            case ApiType.COMPONENT:
            case ApiType.KEEP_DTS:
                (0, typescript_1.forEachChild)(sourceFile, visitChildNode);
                break;
            case ApiType.API:
                mCurrentExportNameSet.clear();
                (0, typescript_1.forEachChild)(sourceFile, node => visitExport(node, true));
                mCurrentExportNameSet.forEach(item => ApiExtractor.mSystemExportSet.add(item));
                (0, typescript_1.forEachChild)(sourceFile, visitPropertyAndName);
                mCurrentExportNameSet.clear();
                break;
            case ApiType.PROJECT:
                mCurrentExportNameSet.clear();
                if (fileName.endsWith('.d.ts') || fileName.endsWith('.d.ets')) {
                    (0, typescript_1.forEachChild)(sourceFile, visitChildNode);
                }
                let isRemoteHarFile = isRemoteHar(fileName);
                (0, typescript_1.forEachChild)(sourceFile, node => visitProjectExport(node, isRemoteHarFile));
                (0, typescript_1.forEachChild)(sourceFile, visitProjectNode);
                collectEnumMembersOfFile(sourceFile);
                mCurrentExportedPropertySet = handleWhiteListWhenExportObfs(fileName, mCurrentExportedPropertySet);
                mCurrentExportNameSet = handleWhiteListWhenExportObfs(fileName, mCurrentExportNameSet);
                break;
            case ApiType.CONSTRUCTOR_PROPERTY:
                (0, typescript_1.forEachChild)(sourceFile, visitNodeForConstructorProperty);
                collectEnumMembersOfFile(sourceFile);
                break;
            default:
                break;
        }
        // collect export names.
        mCurrentExportNameSet.forEach(item => ApiExtractor.mExportNames.add(item));
        mCurrentExportNameSet.clear();
        // collect export names and properties.
        mCurrentExportedPropertySet.forEach(item => ApiExtractor.mPropertySet.add(item));
        mCurrentExportedPropertySet.clear();
        OhsUtil_1.exportOriginalNameSet.clear();
    };
    function handleWhiteListWhenExportObfs(fileName, collectedExportNamesAndProperties) {
        var _a;
        // If mExportObfuscation is not enabled, collect the export names and their properties into the whitelist.
        if (!ApiReader_1.scanProjectConfig.mExportObfuscation) {
            return collectedExportNamesAndProperties;
        }
        // If the current file is a keep file or its dependent file, collect the export names and their properties into the whitelist.
        if ((_a = ApiReader_1.scanProjectConfig.mkeepFilesAndDependencies) === null || _a === void 0 ? void 0 : _a.has(fileName)) {
            return collectedExportNamesAndProperties;
        }
        // If it is a project source code file, the names and their properties of the export will not be collected.
        if (!isRemoteHar(fileName)) {
            collectedExportNamesAndProperties.clear();
            return collectedExportNamesAndProperties;
        }
        // If it is a third-party library file.
        return collectedExportNamesAndProperties;
    }
    const projectExtensions = ['.ets', '.ts', '.js'];
    const projectDependencyExtensions = ['.d.ets', '.d.ts', '.ets', '.ts', '.js'];
    const resolvedModules = new Set();
    function tryGetPackageID(filePath) {
        const ohPackageJsonPath = path_1.default.join(filePath, 'oh-package.json5');
        let packgeNameAndVersion = '';
        if (fs_1.default.existsSync(ohPackageJsonPath)) {
            const ohPackageContent = json5_1.default.parse(fs_1.default.readFileSync(ohPackageJsonPath, 'utf-8'));
            packgeNameAndVersion = ohPackageContent.name + ohPackageContent.version;
        }
        return packgeNameAndVersion;
    }
    function traverseFilesInDir(apiPath, apiType) {
        let fileNames = fs_1.default.readdirSync(apiPath);
        for (let fileName of fileNames) {
            let filePath = path_1.default.join(apiPath, fileName);
            try {
                fs_1.default.accessSync(filePath, fs_1.default.constants.R_OK);
            }
            catch (err) {
                continue;
            }
            if (fs_1.default.statSync(filePath).isDirectory()) {
                const packgeNameAndVersion = tryGetPackageID(filePath);
                if (resolvedModules.has(packgeNameAndVersion)) {
                    continue;
                }
                ApiExtractor.traverseApiFiles(filePath, apiType);
                packgeNameAndVersion.length > 0 && resolvedModules.add(packgeNameAndVersion);
                continue;
            }
            const suffix = path_1.default.extname(filePath);
            if ((apiType !== ApiType.PROJECT) && !projectDependencyExtensions.includes(suffix)) {
                continue;
            }
            if (apiType === ApiType.PROJECT && !projectExtensions.includes(suffix)) {
                continue;
            }
            parseFile(filePath, apiType);
        }
    }
    /**
     * traverse files of  api directory
     * @param apiPath api directory path
     * @param apiType
     * @private
     */
    ApiExtractor.traverseApiFiles = function (apiPath, apiType) {
        if (fs_1.default.statSync(apiPath).isDirectory()) {
            traverseFilesInDir(apiPath, apiType);
        }
        else {
            parseFile(apiPath, apiType);
        }
    };
    /**
     * desc: parse openHarmony sdk to get api list
     * @param version version of api, e.g. version 5.0.1.0 for api 9
     * @param sdkPath sdk real path of openHarmony
     * @param isEts true for ets, false for js
     * @param outputDir: sdk api output directory
     */
    function parseOhSdk(sdkPath, version, isEts, outputDir) {
        ApiExtractor.mPropertySet.clear();
        // visit api directory
        const apiPath = path_1.default.join(sdkPath, (isEts ? 'ets' : 'js'), version, 'api');
        ApiExtractor.traverseApiFiles(apiPath, ApiType.API);
        // visit component directory if ets
        if (isEts) {
            const componentPath = path_1.default.join(sdkPath, 'ets', version, 'component');
            ApiExtractor.traverseApiFiles(componentPath, ApiType.COMPONENT);
        }
        // visit the UI conversion API
        const uiConversionPath = path_1.default.join(sdkPath, (isEts ? 'ets' : 'js'), version, 'build-tools', 'ets-loader', 'lib', 'pre_define.js');
        extractStringsFromFile(uiConversionPath);
        const reservedProperties = [...ApiExtractor.mPropertySet.values()];
        ApiExtractor.mPropertySet.clear();
        writeToFile(reservedProperties, path_1.default.join(outputDir, 'propertiesReserved.json'));
    }
    ApiExtractor.parseOhSdk = parseOhSdk;
    function extractStringsFromFile(filePath) {
        let collections = [];
        const fileContent = fs_1.default.readFileSync(filePath, 'utf-8');
        const regex = /"([^"]*)"/g;
        const matches = fileContent.match(regex);
        if (matches) {
            collections = matches.map(match => match.slice(1, -1));
        }
        collections.forEach(name => ApiExtractor.mPropertySet.add(name));
    }
    ApiExtractor.extractStringsFromFile = extractStringsFromFile;
    /**
     * save api json object to file
     * @private
     */
    function writeToFile(reservedProperties, outputPath) {
        let str = JSON.stringify(reservedProperties, null, '\t');
        fs_1.default.writeFileSync(outputPath, str);
    }
    ApiExtractor.writeToFile = writeToFile;
    function isRemoteHar(filePath) {
        const realPath = typescript_1.sys.realpath(filePath);
        return isInOhModuleFile(realPath);
    }
    ApiExtractor.isRemoteHar = isRemoteHar;
    function isInOhModuleFile(filePath) {
        return filePath.indexOf('/oh_modules/') !== -1 || filePath.indexOf('\\oh_modules\\') !== -1;
    }
    ApiExtractor.isInOhModuleFile = isInOhModuleFile;
    function isParsableFile(path) {
        return type_1.supportedParsingExtension.some(extension => path.endsWith(extension));
    }
    ApiExtractor.isParsableFile = isParsableFile;
    /**
    * parse common project or file to extract exported api list
    * @return reserved api names
    */
    function parseFileByPaths(projectPaths, scanningApiType) {
        ApiExtractor.mPropertySet.clear();
        ApiExtractor.mExportNames.clear();
        projectPaths.forEach(path => {
            parseFile(path, scanningApiType);
        });
        let reservedExportPropertyAndName;
        let reservedExportNames;
        if (ApiReader_1.scanProjectConfig.mPropertyObfuscation) {
            reservedExportPropertyAndName = new Set(ApiExtractor.mPropertySet);
        }
        if (ApiReader_1.scanProjectConfig.mExportObfuscation) {
            reservedExportNames = new Set(ApiExtractor.mExportNames);
        }
        ApiExtractor.mPropertySet.clear();
        ApiExtractor.mExportNames.clear();
        return {
            reservedExportPropertyAndName: reservedExportPropertyAndName,
            reservedExportNames: reservedExportNames
        };
    }
    ApiExtractor.parseFileByPaths = parseFileByPaths;
    /**
     * Collect all property names in the AST.
     * @param astNode Nodes of the AST.
     */
    function collectPropertyNames(astNode) {
        visitElementsWithProperties(astNode);
    }
    /**
     * Visit elements that can contain properties.
     * @param node The current AST node.
     */
    function visitElementsWithProperties(node) {
        switch (node.kind) {
            case typescript_1.SyntaxKind.ClassDeclaration:
                (0, typescript_1.forEachChild)(node, visitClass);
                break;
            case typescript_1.SyntaxKind.InterfaceDeclaration:
            case typescript_1.SyntaxKind.TypeLiteral:
                (0, typescript_1.forEachChild)(node, visitInterfaceOrType);
                break;
            case typescript_1.SyntaxKind.EnumDeclaration:
                (0, typescript_1.forEachChild)(node, visitEnum);
                break;
            case typescript_1.SyntaxKind.ObjectLiteralExpression:
                (0, typescript_1.forEachChild)(node, visitObjectLiteral);
                break;
            case typescript_1.SyntaxKind.ModuleDeclaration:
                (0, typescript_1.forEachChild)(node, visitModule);
                break;
        }
        (0, typescript_1.forEachChild)(node, visitElementsWithProperties);
    }
    function visitClass(node) {
        if ((0, typescript_1.isPropertyDeclaration)(node) || (0, typescript_1.isMethodDeclaration)(node)) {
            if ((0, typescript_1.isIdentifier)(node.name)) {
                mCurrentExportedPropertySet.add(node.name.text);
            }
        }
        (0, typescript_1.forEachChild)(node, visitClass);
    }
    function visitInterfaceOrType(node) {
        if ((0, typescript_1.isPropertySignature)(node) || (0, typescript_1.isMethodSignature)(node)) {
            if ((0, typescript_1.isIdentifier)(node.name)) {
                mCurrentExportedPropertySet.add(node.name.text);
            }
        }
        (0, typescript_1.forEachChild)(node, visitInterfaceOrType);
    }
    function visitEnum(node) {
        if ((0, typescript_1.isEnumMember)(node) && (0, typescript_1.isIdentifier)(node.name)) {
            mCurrentExportedPropertySet.add(node.name.text);
        }
    }
    function visitObjectLiteral(node) {
        if ((0, typescript_1.isPropertyAssignment)(node)) {
            if ((0, typescript_1.isIdentifier)(node.name)) {
                mCurrentExportedPropertySet.add(node.name.text);
            }
        }
        (0, typescript_1.forEachChild)(node, visitObjectLiteral);
    }
    function visitModule(node) {
        (0, typescript_1.forEachChild)(node, visitElementsWithProperties);
    }
    function collectNodeName(name) {
        mCurrentExportNameSet.add(name);
        mCurrentExportedPropertySet.add(name);
    }
    function containsIdentifier(node, found) {
        if (found.value) {
            return;
        }
        if ((0, typescript_1.isIdentifier)(node)) {
            found.value = true;
            return;
        }
        (0, typescript_1.forEachChild)(node, childNode => {
            containsIdentifier(childNode, found);
        });
    }
    function shouldCollectEnum(node) {
        const members = node.members;
        for (const member of members) {
            if ((0, typescript_1.isEnumMember)(member) && member.initializer) {
                const initializer = member.initializer;
                const found = { value: false };
                containsIdentifier(initializer, found);
                if (found.value) {
                    return true;
                }
            }
        }
        return false;
    }
    function collectEnumMember(node) {
        if ((0, typescript_1.isEnumMember)(node) && (0, typescript_1.isIdentifier)(node.name)) {
            ApiExtractor.mEnumMemberSet.add(node.name.text);
        }
    }
    /**
     * Visit and collect enum members
     * @param node The current AST node.
     */
    function visitEnumMembers(node) {
        if ((0, typescript_1.isEnumDeclaration)(node)) {
            if (!shouldCollectEnum(node)) {
                return;
            }
            for (const member of node.members) {
                collectEnumMember(member);
            }
            return;
        }
        (0, typescript_1.forEachChild)(node, visitEnumMembers);
    }
    /**
     * Visit and collect enum members of non-js file
     * @param sourceFile The sourceFile to collect.
     */
    function collectEnumMembersOfFile(sourceFile) {
        if (sourceFile.fileName.endsWith(typescript_1.Extension.Js)) {
            return;
        }
        (0, typescript_1.forEachChild)(sourceFile, visitEnumMembers);
    }
})(ApiExtractor = exports.ApiExtractor || (exports.ApiExtractor = {}));
//# sourceMappingURL=ApiExtractor.js.map