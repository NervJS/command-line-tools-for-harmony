"use strict";
/*
 * Copyright (c) 2023-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const NameFactory_1 = require("../../generator/NameFactory");
const TransformPlugin_1 = require("../TransformPlugin");
const NodeUtils_1 = require("../../utils/NodeUtils");
const ArkObfuscator_1 = require("../../ArkObfuscator");
const PrinterUtils_1 = require("../../utils/PrinterUtils");
const TransformUtil_1 = require("../../utils/TransformUtil");
const RenameIdentifierTransformer_1 = require("./RenameIdentifierTransformer");
const NameCacheUtil_1 = require("../../utils/NameCacheUtil");
const CommonCollections_1 = require("../../utils/CommonCollections");
var secharmony;
(function (secharmony) {
    /**
     * Rename Properties Transformer
     *
     * @param option obfuscation options
     */
    const createRenamePropertiesFactory = function (option) {
        let profile = option === null || option === void 0 ? void 0 : option.mNameObfuscation;
        if (!profile || !profile.mEnable || !profile.mRenameProperties) {
            return null;
        }
        return renamePropertiesFactory;
        function renamePropertiesFactory(context) {
            let options = {};
            let generator = (0, NameFactory_1.getNameGenerator)(profile.mNameGeneratorType, options);
            return renamePropertiesTransformer;
            function renamePropertiesTransformer(node) {
                if ((0, typescript_1.isSourceFile)(node) && ArkObfuscator_1.ArkObfuscator.isKeptCurrentFile) {
                    return node;
                }
                (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.PROPERTY_OBFUSCATION, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                let ret = renameProperties(node);
                (0, NameCacheUtil_1.UpdateMemberMethodName)(RenameIdentifierTransformer_1.nameCache, CommonCollections_1.PropCollections.globalMangledTable, RenameIdentifierTransformer_1.classInfoInMemberMethodCache);
                let parentNodes = (0, typescript_1.setParentRecursive)(ret, true);
                (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.PROPERTY_OBFUSCATION, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                return parentNodes;
            }
            function renameProperties(node) {
                if (!NodeUtils_1.NodeUtils.isPropertyNode(node)) {
                    return (0, typescript_1.visitEachChild)(node, renameProperties, context);
                }
                if ((0, typescript_1.isElementAccessExpression)(node.parent)) {
                    return renameElementAccessProperty(node);
                }
                if ((0, typescript_1.isIndexedAccessTypeNode)(node.parent)) {
                    return renameIndexedAccessProperty(node);
                }
                if ((0, typescript_1.isComputedPropertyName)(node)) {
                    return renameComputedProperty(node);
                }
                return renameProperty(node, false);
            }
            function renameElementAccessProperty(node) {
                if ((0, typescript_1.isStringLiteralLike)(node)) {
                    return renameProperty(node, false);
                }
                return (0, typescript_1.visitEachChild)(node, renameProperties, context);
            }
            function renameIndexedAccessProperty(node) {
                if (NodeUtils_1.NodeUtils.isStringLiteralTypeNode(node)) {
                    let prop = renameProperty(node.literal, false);
                    if (prop !== node.literal) {
                        return typescript_1.factory.createLiteralTypeNode(prop);
                    }
                    return (0, typescript_1.visitEachChild)(node, renameProperties, context);
                }
                if (!(0, typescript_1.isUnionTypeNode)(node)) {
                    return (0, typescript_1.visitEachChild)(node, renameProperties, context);
                }
                let isChanged = false;
                const elemTypes = node.types.map((elemType) => {
                    if (!elemType || !NodeUtils_1.NodeUtils.isStringLiteralTypeNode(elemType)) {
                        return elemType;
                    }
                    const prop = renameProperty(elemType.literal, false);
                    if (prop !== elemType.literal) {
                        isChanged = true;
                        return typescript_1.factory.createLiteralTypeNode(prop);
                    }
                    return elemType;
                });
                if (isChanged) {
                    return typescript_1.factory.createUnionTypeNode(elemTypes);
                }
                return (0, typescript_1.visitEachChild)(node, renameProperties, context);
            }
            function renameComputedProperty(node) {
                if ((0, typescript_1.isStringLiteralLike)(node.expression) || (0, typescript_1.isNumericLiteral)(node.expression)) {
                    let prop = renameProperty(node.expression, true);
                    if (prop !== node.expression) {
                        return typescript_1.factory.createComputedPropertyName(prop);
                    }
                }
                if ((0, typescript_1.isIdentifier)(node.expression)) {
                    return node;
                }
                return (0, typescript_1.visitEachChild)(node, renameProperties, context);
            }
            function renameProperty(node, computeName) {
                if (!(0, typescript_1.isStringLiteralLike)(node) && !(0, typescript_1.isIdentifier)(node) && !(0, typescript_1.isPrivateIdentifier)(node) && !(0, typescript_1.isNumericLiteral)(node)) {
                    return (0, typescript_1.visitEachChild)(node, renameProperties, context);
                }
                if ((0, typescript_1.isStringLiteralLike)(node) && (profile === null || profile === void 0 ? void 0 : profile.mKeepStringProperty)) {
                    if (CommonCollections_1.UnobfuscationCollections.printKeptName) {
                        (0, TransformUtil_1.needToRecordProperty)(node.text, CommonCollections_1.UnobfuscationCollections.unobfuscatedPropMap);
                    }
                    return node;
                }
                let original = node.text;
                if ((0, TransformUtil_1.isInPropertyWhitelist)(original, CommonCollections_1.UnobfuscationCollections.unobfuscatedPropMap)) {
                    return node;
                }
                let mangledName = getPropertyName(original);
                if ((0, typescript_1.isStringLiteralLike)(node)) {
                    return typescript_1.factory.createStringLiteral(mangledName);
                }
                /**
                 * source demo:
                 * class A {
                 *   123 = 1; // it is NumericLiteral
                 *   [456] = 2; // it is NumericLiteral within ComputedPropertyName
                 * }
                 * obfuscation result:
                 * class A {
                 *   a = 1;
                 *   ['b'] = 2;
                 * }
                 */
                if ((0, typescript_1.isNumericLiteral)(node)) {
                    return computeName ? typescript_1.factory.createStringLiteral(mangledName) : typescript_1.factory.createIdentifier(mangledName);
                }
                if ((0, typescript_1.isIdentifier)(node) || (0, typescript_1.isNumericLiteral)(node)) {
                    return typescript_1.factory.createIdentifier(mangledName);
                }
                return typescript_1.factory.createPrivateIdentifier('#' + mangledName);
            }
            function getPropertyName(original) {
                var _a;
                const historyName = (_a = CommonCollections_1.PropCollections.historyMangledTable) === null || _a === void 0 ? void 0 : _a.get(original);
                let mangledName = historyName ? historyName : CommonCollections_1.PropCollections.globalMangledTable.get(original);
                while (!mangledName) {
                    let tmpName = generator.getName();
                    if ((0, TransformUtil_1.isReservedProperty)(tmpName) ||
                        tmpName === original) {
                        continue;
                    }
                    if (CommonCollections_1.PropCollections.newlyOccupiedMangledProps.has(tmpName) || CommonCollections_1.PropCollections.mangledPropsInNameCache.has(tmpName)) {
                        continue;
                    }
                    mangledName = tmpName;
                }
                CommonCollections_1.PropCollections.globalMangledTable.set(original, mangledName);
                CommonCollections_1.PropCollections.newlyOccupiedMangledProps.add(mangledName);
                return mangledName;
            }
        }
    };
    secharmony.transformerPlugin = {
        'name': 'renamePropertiesPlugin',
        'order': TransformPlugin_1.TransformerOrder.RENAME_PROPERTIES_TRANSFORMER,
        'createTransformerFactory': createRenamePropertiesFactory
    };
})(secharmony || (secharmony = {}));
module.exports = secharmony;
//# sourceMappingURL=RenamePropertiesTransformer.js.map