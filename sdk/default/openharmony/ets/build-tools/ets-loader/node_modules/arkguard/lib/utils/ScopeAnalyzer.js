"use strict";
/*
 * Copyright (c) 2023-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const NodeUtils_1 = require("./NodeUtils");
const OhsUtil_1 = require("./OhsUtil");
const TypeUtils_1 = require("./TypeUtils");
/**
 * kind of a scope
 */
var secharmony;
(function (secharmony) {
    /**
     * A map used to track whether identifiers without symbols are in the top-level scope.
     */
    secharmony.exportElementsWithoutSymbol = new Map();
    /**
     * Alias symbol for export elements with corresponding original symbol
     * key: symbols of export elements
     * value: original symbols of export elements
     */
    secharmony.exportSymbolAliasMap = new Map();
    /**
     * type of scope
     */
    let ScopeKind;
    (function (ScopeKind) {
        ScopeKind[ScopeKind["GLOBAL"] = 0] = "GLOBAL";
        ScopeKind[ScopeKind["MODULE"] = 1] = "MODULE";
        ScopeKind[ScopeKind["FUNCTION"] = 2] = "FUNCTION";
        ScopeKind[ScopeKind["CLASS"] = 3] = "CLASS";
        ScopeKind[ScopeKind["FOR"] = 4] = "FOR";
        ScopeKind[ScopeKind["SWITCH"] = 5] = "SWITCH";
        ScopeKind[ScopeKind["BLOCK"] = 6] = "BLOCK";
        ScopeKind[ScopeKind["INTERFACE"] = 7] = "INTERFACE";
        ScopeKind[ScopeKind["CATCH"] = 8] = "CATCH";
        ScopeKind[ScopeKind["ENUM"] = 9] = "ENUM";
        ScopeKind[ScopeKind["OBJECT_LITERAL"] = 10] = "OBJECT_LITERAL";
    })(ScopeKind = secharmony.ScopeKind || (secharmony.ScopeKind = {}));
    function isGlobalScope(scope) {
        return scope.kind === ScopeKind.GLOBAL;
    }
    secharmony.isGlobalScope = isGlobalScope;
    function isFunctionScope(scope) {
        return scope.kind === ScopeKind.FUNCTION;
    }
    secharmony.isFunctionScope = isFunctionScope;
    function isClassScope(scope) {
        return scope.kind === ScopeKind.CLASS;
    }
    secharmony.isClassScope = isClassScope;
    function isInterfaceScope(scope) {
        return scope.kind === ScopeKind.INTERFACE;
    }
    secharmony.isInterfaceScope = isInterfaceScope;
    function isEnumScope(scope) {
        return scope.kind === ScopeKind.ENUM;
    }
    secharmony.isEnumScope = isEnumScope;
    function isObjectLiteralScope(scope) {
        return scope.kind === ScopeKind.OBJECT_LITERAL;
    }
    secharmony.isObjectLiteralScope = isObjectLiteralScope;
    /**
     * get a new scope.
     * @param name - name of the scope.
     * @param node - node of a current scope in ast.
     * @param type - type of the scope.
     * @param lexicalScope - indicates if the scope is a lexical scope.
     * @param upper - parent scope of the current scope.
     */
    class Scope {
        constructor(name, node, type, lexicalScope = false, upper) {
            var _a, _b;
            this.name = name;
            this.kind = type;
            this.block = node;
            this.parent = upper;
            this.children = [];
            this.defs = new Set();
            this.labels = [];
            this.importNames = new Set();
            this.exportNames = new Set();
            this.mangledNames = new Set();
            this.loc = ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.loc) ? getNameWithScopeLoc(this.parent, this.name) : this.name;
            (_b = this.parent) === null || _b === void 0 ? void 0 : _b.addChild(this);
        }
        /**
         * add a sub scope to current scope
         *
         * @param child
         */
        addChild(child) {
            this.children.push(child);
        }
        /**
         * add definition symbol into current scope
         *
         * @param def definition symbol
         */
        addDefinition(def, obfuscateAsProperty = false) {
            if (this.kind === ScopeKind.GLOBAL || obfuscateAsProperty) {
                Reflect.set(def, 'obfuscateAsProperty', true);
            }
            this.defs.add(def);
        }
        /**
         * add label to current scope
         *
         * @param label label statement
         */
        addLabel(label) {
            this.labels.push(label);
        }
        /**
         * get symbol location
         *
         * @param sym symbol
         */
        getSymbolLocation(sym) {
            if (!this.defs.has(sym)) {
                return '';
            }
            return this.loc ? sym.name : getNameWithScopeLoc(this, sym.name);
        }
        /**
         * get label location
         *
         * @param label
         */
        getLabelLocation(label) {
            if (!this.labels.includes(label)) {
                return '';
            }
            let index = this.labels.findIndex((lb) => lb === label);
            return this.loc ? label.name : getNameWithScopeLoc(this, index + label.name);
        }
    }
    secharmony.Scope = Scope;
    function createLabel(node, scope, parent) {
        let labelName = '$' + scope.labels.length + '_' + node.label.text;
        let label = {
            'name': node.label.text,
            'locInfo': labelName,
            'refs': [node.label],
            'parent': parent,
            'children': [],
            'scope': scope,
        };
        scope.labels.push(label);
        parent === null || parent === void 0 ? void 0 : parent.children.push(label);
        return label;
    }
    secharmony.createLabel = createLabel;
    function createScopeManager() {
        let reservedNames = new Set();
        let root;
        let current;
        let scopes = [];
        let checker = null;
        let upperLabel = undefined;
        let exportObfuscation = false;
        return {
            getReservedNames,
            analyze,
            getRootScope,
            getScopeOfNode,
        };
        function analyze(ast, typeChecker, isEnabledExportObfuscation = false) {
            checker = typeChecker;
            exportObfuscation = isEnabledExportObfuscation;
            analyzeScope(ast);
        }
        function getReservedNames() {
            return reservedNames;
        }
        function getRootScope() {
            return root;
        }
        function addSymbolInScope(node) {
            let defSymbols = node === null || node === void 0 ? void 0 : node.locals;
            if (!defSymbols) {
                return;
            }
            defSymbols.forEach((def) => {
                // with export identification, special handling.
                if (def.exportSymbol) {
                    current.exportNames.add(def.name);
                    root.fileExportNames.add(def.name);
                    if (def.exportSymbol.name === def.name) {
                        /* For export declaration, `def` and its `exportSymbol` has same name,
                            eg. export class Ability {}
                              def.name: "Ability"
                              def.exportSymbol.name: "Ability"
                            Collect the `def.exportSymbol` since import symbol is asscociated with it.
                        */
                        current.addDefinition(def.exportSymbol, true);
                    }
                    else {
                        /* For default exports, `def` and its `exportSymbol` has different name,
                            eg. export default class Ability {}
                              def.name: "Ability"
                              def.exportSymbol.name: "default"
                          Collect the `def` symbol since we should obfuscate "Ability" instead of "default".
                        */
                        current.addDefinition(def);
                    }
                }
                else {
                    current.addDefinition(def);
                }
            });
        }
        function addExportSymbolInScope(node) {
            let defSymbol = node === null || node === void 0 ? void 0 : node.symbol;
            if (!defSymbol) {
                return;
            }
            let originalSymbol = TypeUtils_1.TypeUtils.getOriginalSymbol(defSymbol, checker);
            if (defSymbol !== originalSymbol) {
                secharmony.exportSymbolAliasMap.set(defSymbol, originalSymbol);
            }
            tryAddExportNamesIntoParentScope(originalSymbol, current);
            // Mark export symbol as 'obfucate as property'
            // to ensure the corresponding element can be kept by -keep-global-name
            current.addDefinition(originalSymbol, true);
        }
        /**
         * analyze chain of scopes
         * @param node
         */
        function analyzeScope(node) {
            switch (node.kind) {
                // global
                case typescript_1.SyntaxKind.SourceFile:
                    analyzeSourceFile(node);
                    break;
                // namespace or module
                case typescript_1.SyntaxKind.ModuleDeclaration:
                    analyzeModule(node);
                    break;
                // function like
                case typescript_1.SyntaxKind.FunctionDeclaration:
                case typescript_1.SyntaxKind.MethodDeclaration:
                case typescript_1.SyntaxKind.GetAccessor:
                case typescript_1.SyntaxKind.SetAccessor:
                case typescript_1.SyntaxKind.Constructor:
                case typescript_1.SyntaxKind.FunctionExpression:
                case typescript_1.SyntaxKind.ArrowFunction:
                    analyzeFunctionLike(node);
                    break;
                // class like
                case typescript_1.SyntaxKind.ClassExpression:
                case typescript_1.SyntaxKind.ClassDeclaration:
                case typescript_1.SyntaxKind.StructDeclaration:
                    analyzeClassLike(node);
                    break;
                // for like
                case typescript_1.SyntaxKind.ForStatement:
                case typescript_1.SyntaxKind.ForInStatement:
                case typescript_1.SyntaxKind.ForOfStatement:
                    analyzeForLike(node);
                    break;
                case typescript_1.SyntaxKind.CaseBlock:
                    // caseBlock property in switch statement
                    analyzeSwitch(node);
                    break;
                case typescript_1.SyntaxKind.Block:
                    // while, do ...while, block, if/else..
                    analyzeBlock(node);
                    break;
                case typescript_1.SyntaxKind.InterfaceDeclaration:
                    analyzeInterface(node);
                    break;
                case typescript_1.SyntaxKind.EnumDeclaration:
                    analyzeEnum(node);
                    break;
                case typescript_1.SyntaxKind.Identifier:
                    analyzeSymbol(node);
                    break;
                case typescript_1.SyntaxKind.TypeAliasDeclaration:
                    analyzeTypeAliasDeclaration(node);
                    break;
                case typescript_1.SyntaxKind.LabeledStatement:
                    analyzeLabel(node);
                    break;
                case typescript_1.SyntaxKind.BreakStatement:
                case typescript_1.SyntaxKind.ContinueStatement:
                    analyzeBreakOrContinue(node);
                    break;
                case typescript_1.SyntaxKind.ImportSpecifier:
                    analyzeImportNames(node);
                    break;
                case typescript_1.SyntaxKind.ObjectBindingPattern:
                    analyzeObjectBindingPatternRequire(node);
                    break;
                case typescript_1.SyntaxKind.ObjectLiteralExpression:
                    analyzeObjectLiteralExpression(node);
                    break;
                case typescript_1.SyntaxKind.ExportSpecifier:
                    analyzeExportNames(node);
                    break;
                case typescript_1.SyntaxKind.NamespaceExport:
                    analyzeNamespaceExport(node);
                    break;
                case typescript_1.SyntaxKind.CatchClause:
                    analyzeCatchClause(node);
                    break;
                case typescript_1.SyntaxKind.ImportEqualsDeclaration:
                    analyzeImportEqualsDeclaration(node);
                    break;
                default:
                    (0, typescript_1.forEachChild)(node, analyzeScope);
                    break;
            }
        }
        function analyzeImportNames(node) {
            try {
                const propertyNameNode = node.propertyName;
                if (exportObfuscation) {
                    // try to collect symbol for `A` in `import { A as B } from './file'; into current scope`
                    tryAddPropertyNameNodeSymbol(propertyNameNode);
                    const nameSymbol = checker.getSymbolAtLocation(node.name);
                    if (nameSymbol) {
                        // nameSymbol is the symbol of A in `import { A } from './file';` and propertyNameNode is undefined
                        // nameSymbol is the symbol of B in `import { A as B } from './file';` and propertyNameNode is A
                        let shouldObfuscateAsImportElement = propertyNameNode === undefined;
                        current.addDefinition(nameSymbol, shouldObfuscateAsImportElement);
                    }
                }
                else {
                    const nameText = propertyNameNode ? propertyNameNode.text : node.name.text;
                    current.importNames.add(nameText);
                    root.fileImportNames.add(nameText);
                }
                (0, typescript_1.forEachChild)(node, analyzeScope);
            }
            catch (e) {
                console.error(e);
            }
        }
        function tryAddPropertyNameNodeSymbol(propertyNameNode) {
            var _a, _b;
            if (!propertyNameNode) {
                return;
            }
            if (propertyNameNode.text === 'default') {
                return;
            }
            const propertySymbol = checker.getSymbolAtLocation(propertyNameNode);
            if (!propertySymbol) {
                secharmony.exportElementsWithoutSymbol.set(propertyNameNode, current.kind === ScopeKind.GLOBAL);
                return;
            }
            let parentNode = propertyNameNode.parent;
            let shouldObfuscateAsExportElement = false;
            if ((0, typescript_1.isImportSpecifier)(parentNode)) {
                // If it is part of an `import` statement, it always comes from another file:
                // Example: import { A as B } from 'module';
                // Here, `A` is an exported element from `module`.
                shouldObfuscateAsExportElement = true;
            }
            else if ((0, typescript_1.isExportSpecifier)(parentNode)) {
                // If it is part of an `export` statement with `from`, it comes from another file:
                // Example: export { A as B } from 'module';
                // Here, `A` is an exported element from `module`.
                //
                // If it is part of a bare `export` statement without `from`, it is declared locally:
                // Example: export { A as B };
                // Here, `A` is not an exported element from another file.
                shouldObfuscateAsExportElement = ((_b = (_a = parentNode.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.moduleSpecifier) !== undefined;
            }
            current.addDefinition(propertySymbol, shouldObfuscateAsExportElement);
        }
        /** example
         * const { x1, y: customY, z = 0 }: { x: number; y?: number; z?: number } = { x: 1, y: 2 };
         * bindingElement.name is x1 for the first element.
         * bindingElement.name is customY for the second element.
         */
        function analyzeObjectBindingPatternRequire(node) {
            if (!NodeUtils_1.NodeUtils.isObjectBindingPatternAssignment(node)) {
                (0, typescript_1.forEachChild)(node, analyzeScope);
                return;
            }
            if (!node.elements) {
                return;
            }
            node.elements.forEach((bindingElement) => {
                if (!bindingElement) {
                    return;
                }
                findNoSymbolIdentifiers(bindingElement);
                if (!bindingElement.name || !(0, typescript_1.isIdentifier)(bindingElement.name)) {
                    return;
                }
                if (bindingElement.propertyName) {
                    return;
                }
                current.importNames.add(bindingElement.name.text);
                root.fileImportNames.add(bindingElement.name.text);
            });
        }
        function analyzeObjectLiteralExpression(node) {
            let scopeName = '$' + current.children.length;
            current = new Scope(scopeName, node, ScopeKind.OBJECT_LITERAL, false, current);
            scopes.push(current);
            addSymbolInScope(node);
            (0, typescript_1.forEachChild)(node, analyzeScope);
            current = current.parent || current;
        }
        function analyzeExportNames(node) {
            // get export names.
            let curExportName = node.name.text;
            current.exportNames.add(curExportName);
            root.fileExportNames.add(curExportName);
            if (curExportName !== 'default') {
                addExportSymbolInScope(node);
            }
            const propetyNameNode = node.propertyName;
            if (exportObfuscation) {
                tryAddPropertyNameNodeSymbol(propetyNameNode);
            }
            (0, typescript_1.forEachChild)(node, analyzeScope);
        }
        function analyzeNamespaceExport(node) {
            if (!exportObfuscation) {
                return;
            }
            let symbol = checker.getSymbolAtLocation(node.name);
            if (symbol) {
                current.addDefinition(symbol, true);
            }
        }
        function analyzeBreakOrContinue(node) {
            var _a, _b;
            let labelName = (_b = (_a = node === null || node === void 0 ? void 0 : node.label) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : '';
            let label = findTargetLabel(labelName);
            if (!label) {
                return;
            }
            if (node.label) {
                label === null || label === void 0 ? void 0 : label.refs.push(node.label);
            }
            (0, typescript_1.forEachChild)(node, analyzeScope);
        }
        function findTargetLabel(labelName) {
            if (!labelName) {
                return null;
            }
            let label = upperLabel;
            // avoid loop
            while (label && (label === null || label === void 0 ? void 0 : label.name) !== labelName) {
                label = label === null || label === void 0 ? void 0 : label.parent;
            }
            return label;
        }
        function analyzeSourceFile(node) {
            let scopeName = '';
            root = new Scope(scopeName, node, ScopeKind.GLOBAL, true);
            root.fileExportNames = new Set();
            root.fileImportNames = new Set();
            current = root;
            scopes.push(current);
            // locals of a node(scope) is symbol that defines in current scope(node).
            addSymbolInScope(node);
            (0, typescript_1.forEachChild)(node, analyzeScope);
            current = current.parent || current;
            extractImportExports();
        }
        function analyzeCatchClause(node) {
            let scopeName = '$' + current.children.length;
            current = new Scope(scopeName, node, ScopeKind.CATCH, false, current);
            scopes.push(current);
            // add in catch declaration.
            addSymbolInScope(node);
            if (node.block) {
                // add in block declaration.
                addSymbolInScope(node.block);
            }
            (0, typescript_1.forEachChild)(node, analyzeScope);
            current = current.parent || current;
        }
        function extractImportExports() {
            for (const def of current.defs) {
                if (def.exportSymbol) {
                    if (!current.exportNames.has(def.name)) {
                        current.exportNames.add(def.name);
                        root.fileExportNames.add(def.name);
                    }
                    const name = def.exportSymbol.name;
                    if (!current.exportNames.has(name)) {
                        current.exportNames.add(name);
                        root.fileExportNames.add(def.name);
                    }
                }
            }
        }
        function analyzeTypeAliasDeclaration(node) {
            var _a;
            let scopeName = (_a = node.name.text) !== null && _a !== void 0 ? _a : '$' + current.children.length;
            current = new Scope(scopeName, node, ScopeKind.INTERFACE, true, current);
            scopes.push(current);
            addSymbolInScope(node);
            (0, typescript_1.forEachChild)(node, analyzeScope);
            current = current.parent || current;
        }
        /**
         * namespace ns {
         *     ...
         * }
         * @param node
         */
        function analyzeModule(node) {
            var _a;
            /**
             * if it is an anonymous scope, generate the scope name with a number,
             * which is based on the order of its child scopes in the upper scope
             */
            let scopeName = (_a = node.name.text) !== null && _a !== void 0 ? _a : '$' + current.children.length;
            current = new Scope(scopeName, node, ScopeKind.MODULE, true, current);
            scopes.push(current);
            addSymbolInScope(node);
            node.forEachChild((sub) => {
                if ((0, typescript_1.isIdentifier)(sub)) {
                    return;
                }
                analyzeScope(sub);
            });
            current = current.parent || current;
        }
        /**
         * exclude constructor's parameter witch should be treated as property, example:
         *  constructor(public name){}, name should be treated as property
         * @param node
         */
        function excludeConstructorParameter(node) {
            if (!(0, typescript_1.isConstructorDeclaration)(node)) {
                return;
            }
            const visitParam = (param) => {
                const modifiers = (0, typescript_1.getModifiers)(param);
                if (!modifiers || modifiers.length <= 0) {
                    return;
                }
                const findRet = modifiers.find(modifier => (0, OhsUtil_1.isParameterPropertyModifier)(modifier));
                if (!(0, typescript_1.isIdentifier)(param.name) || findRet === undefined) {
                    return;
                }
                current.defs.forEach((def) => {
                    if ((0, typescript_1.isIdentifier)(param.name) && (def.name === param.name.text)) {
                        current.defs.delete(def);
                        current.mangledNames.add(def.name);
                    }
                });
            };
            node.parameters.forEach((param) => {
                visitParam(param);
            });
        }
        /**
         * function func(param1...) {
         *     ...
         * }
         * @param node
         */
        function analyzeFunctionLike(node) {
            var _a, _b;
            // For example, the constructor of the StructDeclaration, inserted by arkui, will add a virtual attribute.
            // @ts-ignore
            if ((0, typescript_1.getOriginalNode)(node).virtual) {
                return;
            }
            let scopeName = (_b = (_a = node === null || node === void 0 ? void 0 : node.name) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : '$' + current.children.length;
            let loc = (current === null || current === void 0 ? void 0 : current.loc) ? getNameWithScopeLoc(current, scopeName) : scopeName;
            let overloading = false;
            for (const sub of current.children) {
                if (sub.loc === loc) {
                    overloading = true;
                    current = sub;
                    break;
                }
            }
            if (!overloading) {
                current = new Scope(scopeName, node, ScopeKind.FUNCTION, true, current);
                scopes.push(current);
            }
            let symbol;
            if (((0, typescript_1.isFunctionExpression)(node) || (0, typescript_1.isArrowFunction)(node)) && (0, typescript_1.isVariableDeclaration)(node.parent)) {
                symbol = checker.getSymbolAtLocation(node.name ? node.name : node.parent.name);
            }
            else {
                if ((0, typescript_1.isFunctionDeclaration)(node)) {
                    symbol = NodeUtils_1.NodeUtils.findSymbolOfIdentifier(checker, node.name);
                }
                else {
                    symbol = checker.getSymbolAtLocation(node.name);
                }
            }
            if (symbol) {
                Reflect.set(symbol, 'isFunction', true);
            }
            addSymbolInScope(node);
            /**
             * {
             *   get name(): "INT";
             *   set orignal(): 0;
             * }
             * // the above getaccessor and setaccessor were obfuscated as identifiers.
             */
            if (!((0, typescript_1.isGetAccessor)(node) || (0, typescript_1.isSetAccessor)(node)) && symbol && current.parent && !current.parent.defs.has(symbol)) {
                /*
                  Handle the case when `FunctionLikeDeclaration` node is as initializer of variable declaration.
                  eg. const foo = function bar() {};
                  The `current` scope is the function's scope, the `current.parent` scope is where the function is defined.
                  `foo` has already added in the parent scope, we need to add `bar` here too.
                 */
                current.parent.defs.add(symbol);
            }
            if ((0, typescript_1.isFunctionDeclaration)(node) || (0, typescript_1.isMethodDeclaration)(node)) {
                // function declaration requires skipping function names
                node.forEachChild((sub) => {
                    if ((0, typescript_1.isIdentifier)(sub)) {
                        tryAddNoSymbolIdentifiers(sub);
                        return;
                    }
                    analyzeScope(sub);
                });
            }
            else {
                (0, typescript_1.forEachChild)(node, analyzeScope);
            }
            excludeConstructorParameter(node);
            current = current.parent || current;
        }
        function analyzeSwitch(node) {
            let scopeName = '$' + current.children.length;
            current = new Scope(scopeName, node, ScopeKind.SWITCH, false, current);
            scopes.push(current);
            addSymbolInScope(node);
            (0, typescript_1.forEachChild)(node, analyzeScope);
            current = current.parent || current;
        }
        /**
         * ES6+ class like scope, The members of a class aren't not allow to rename in rename identifiers transformer, but
         * rename in rename properties transformer.
         *
         * @param node
         */
        function analyzeClassLike(node) {
            var _a, _b, _c;
            if ((0, typescript_1.isClassDeclaration)(node) && (0, OhsUtil_1.isViewPUBasedClass)(node)) {
                reservedNames.add(node.name.text);
            }
            try {
                let scopeName = (_b = (_a = node === null || node === void 0 ? void 0 : node.name) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : '$' + current.children.length;
                current = new Scope(scopeName, node, ScopeKind.CLASS, true, current);
                scopes.push(current);
                addSymbolInScope(node);
                // Class members are seen as attribute names, and the reference of external symbols can be renamed as the same
                (_c = node.symbol.members) === null || _c === void 0 ? void 0 : _c.forEach((symbol) => {
                    current.addDefinition(symbol);
                });
                (0, typescript_1.forEachChild)(node, analyzeScope);
            }
            catch (e) {
                console.error(e);
            }
            current = current.parent || current;
        }
        function analyzeForLike(node) {
            let scopeName = '$' + current.children.length;
            current = new Scope(scopeName, node, ScopeKind.FOR, false, current);
            scopes.push(current);
            addSymbolInScope(node);
            (0, typescript_1.forEachChild)(node, analyzeScope);
            current = current.parent || current;
        }
        function analyzeBlock(node) {
            // when block is body of a function
            if ((isFunctionScope(current) && (0, typescript_1.isFunctionLike)(node.parent)) || (0, typescript_1.isCatchClause)(node.parent)) {
                // skip direct block scope in function scope
                (0, typescript_1.forEachChild)(node, analyzeScope);
                return;
            }
            let scopeName = '$' + current.children.length;
            current = new Scope(scopeName, node, ScopeKind.BLOCK, false, current);
            scopes.push(current);
            addSymbolInScope(node);
            (0, typescript_1.forEachChild)(node, analyzeScope);
            current = current.parent || current;
        }
        function analyzeInterface(node) {
            var _a;
            let scopeName = node.name.text;
            current = new Scope(scopeName, node, ScopeKind.INTERFACE, true, current);
            scopes.push(current);
            try {
                addSymbolInScope(node);
            }
            catch (e) {
                console.error('');
            }
            (_a = node.members) === null || _a === void 0 ? void 0 : _a.forEach((elm) => {
                if (elm === null || elm === void 0 ? void 0 : elm.symbol) {
                    current.addDefinition(elm.symbol);
                }
            });
            (0, typescript_1.forEachChild)(node, analyzeScope);
            current = current.parent || current;
        }
        function analyzeEnum(node) {
            let scopeName = node.name.text;
            current = new Scope(scopeName, node, ScopeKind.ENUM, true, current);
            scopes.push(current);
            for (const member of node.members) {
                if (member.symbol) {
                    current.addDefinition(member.symbol);
                }
            }
            (0, typescript_1.forEachChild)(node, analyzeScope);
            current = current.parent || current;
        }
        function analyzeSymbol(node) {
            // ignore all identifiers that treat as property in property access
            if (NodeUtils_1.NodeUtils.isPropertyAccessNode(node)) {
                return;
            }
            let symbol = null;
            try {
                symbol = NodeUtils_1.NodeUtils.findSymbolOfIdentifier(checker, node);
            }
            catch (e) {
                console.error(e);
                return;
            }
            if (!symbol) {
                current.mangledNames.add(node.text);
                return;
            }
            // ignore all identifiers that treat as property in property declaration
            if (NodeUtils_1.NodeUtils.isPropertyDeclarationNode(node)) {
                return;
            }
            // add def symbol that don't found in current defs.
            addSymbolIntoDefsIfNeeded(node, symbol, current.defs);
        }
        function addSymbolIntoDefsIfNeeded(node, symbol, currentDefs) {
            // process a new def not in currentDefs
            let isSameName = false;
            for (const def of currentDefs) {
                if (def.name === node.text) {
                    isSameName = true;
                    break;
                }
            }
            if (isSameName) {
                // exclude the possibility of external symbols, as those with duplicate names have been added to currentDefs (this avoids the possibility of omissions)
                if (!currentDefs.has(symbol) && !checkOriginalSymbolExist(symbol, currentDefs)) {
                    currentDefs.add(symbol);
                }
                if (symbol.exportSymbol &&
                    !currentDefs.has(symbol.exportSymbol) &&
                    !checkOriginalSymbolExist(symbol, currentDefs)) {
                    Reflect.set(symbol, 'obfuscateAsProperty', true);
                    currentDefs.add(symbol);
                }
            }
            return isSameName;
        }
        function checkOriginalSymbolExist(symbol, currentDefs) {
            const originalSymbol = secharmony.exportSymbolAliasMap.get(symbol);
            if (originalSymbol && currentDefs.has(originalSymbol)) {
                return true;
            }
            return false;
        }
        function analyzeLabel(node) {
            // labels within the same scope are allowed to be duplicated, so label names need to have numbering information to distinguish them
            upperLabel = upperLabel ? createLabel(node, current, upperLabel) : createLabel(node, current);
            (0, typescript_1.forEachChild)(node, analyzeScope);
            upperLabel = upperLabel === null || upperLabel === void 0 ? void 0 : upperLabel.parent;
        }
        function getScopeOfNode(node) {
            if (!(0, typescript_1.isIdentifier)(node)) {
                return undefined;
            }
            let sym = checker.getSymbolAtLocation(node);
            if (!sym) {
                return undefined;
            }
            for (const scope of scopes) {
                if (scope === null || scope === void 0 ? void 0 : scope.defs.has(sym)) {
                    return scope;
                }
            }
            return undefined;
        }
        function analyzeImportEqualsDeclaration(node) {
            let hasExport = false;
            if (node.modifiers) {
                for (const modifier of node.modifiers) {
                    if (modifier.kind === typescript_1.SyntaxKind.ExportKeyword) {
                        hasExport = true;
                        break;
                    }
                }
            }
            if (hasExport) {
                current.exportNames.add(node.name.text);
                root.fileExportNames.add(node.name.text);
                let sym = checker.getSymbolAtLocation(node.name);
                if (sym) {
                    current.addDefinition(sym, true);
                }
            }
            (0, typescript_1.forEachChild)(node, analyzeScope);
        }
        function tryAddNoSymbolIdentifiers(node) {
            if (!(0, typescript_1.isIdentifier)(node)) {
                return;
            }
            // skip property in property access expression
            if (NodeUtils_1.NodeUtils.isPropertyAccessNode(node)) {
                return;
            }
            const sym = checker.getSymbolAtLocation(node);
            if (!sym) {
                current.mangledNames.add(node.text);
            }
        }
        function tryAddExportNamesIntoParentScope(originalSymbol, currentScope) {
            if (currentScope.kind === ScopeKind.GLOBAL) {
                return;
            }
            let parentScope = currentScope.parent;
            while (parentScope) {
                tryAddExportNamesIntoCurrentScope(originalSymbol, parentScope);
                parentScope = parentScope.parent;
            }
        }
        function tryAddExportNamesIntoCurrentScope(originalSymbol, currentScope) {
            if (currentScope.exportNames.has(originalSymbol.name)) {
                return;
            }
            let currentDefs = currentScope.defs;
            for (const curDef of currentDefs) {
                if (curDef === originalSymbol) {
                    currentScope.exportNames.add(originalSymbol.name);
                    return;
                }
            }
        }
        function findNoSymbolIdentifiers(node) {
            const noSymbolVisit = (targetNode) => {
                if (!(0, typescript_1.isIdentifier)(targetNode)) {
                    (0, typescript_1.forEachChild)(targetNode, noSymbolVisit);
                    return;
                }
                tryAddNoSymbolIdentifiers(targetNode);
            };
            noSymbolVisit(node);
        }
    }
    secharmony.createScopeManager = createScopeManager;
    function getNameWithScopeLoc(scope, name) {
        return scope.loc + '#' + name;
    }
    secharmony.getNameWithScopeLoc = getNameWithScopeLoc;
})(secharmony || (secharmony = {}));
module.exports = secharmony;
//# sourceMappingURL=ScopeAnalyzer.js.map