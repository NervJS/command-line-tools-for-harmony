"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readProjectPropertiesByCollectedPaths = exports.isEnabledPropertyObfuscation = exports.needReadApiInfo = exports.initPlugin = exports.scanProjectConfig = void 0;
const path_1 = __importDefault(require("path"));
const ApiExtractor_1 = require("./ApiExtractor");
const OhsUtil_1 = require("../utils/OhsUtil");
exports.scanProjectConfig = {};
/**
 * if rename property is not open, api read and extract can be skipped
 *
 * init plugin, read api info of openHarmony sdk and generate file of reserved name, property and string.
 * @param sdkDir absolute path like D:\\HuaweiApp\\ohsdk
 * @param outputDir
 */
function initPlugin(sdkDir, outputDir) {
    // create sdk api file if not exist
    const ohSdkPath = path_1.default.resolve(sdkDir);
    if (!ohSdkPath) {
        console.error('SDK path is not found.');
    }
    const apiVersions = [''];
    apiVersions.forEach((versionString) => {
        ApiExtractor_1.ApiExtractor.parseOhSdk(ohSdkPath, versionString, true, outputDir);
    });
}
exports.initPlugin = initPlugin;
/**
 * need read api info or not
 * @param customProfiles
 */
function needReadApiInfo(customProfiles) {
    return isEnabledPropertyObfuscation(customProfiles) || customProfiles.mExportObfuscation;
}
exports.needReadApiInfo = needReadApiInfo;
function isEnabledPropertyObfuscation(customProfiles) {
    return (customProfiles.mNameObfuscation &&
        customProfiles.mNameObfuscation.mEnable &&
        customProfiles.mNameObfuscation.mRenameProperties);
}
exports.isEnabledPropertyObfuscation = isEnabledPropertyObfuscation;
function initScanProjectConfig(customProfiles, isHarCompiled) {
    var _a, _b, _c;
    exports.scanProjectConfig.mPropertyObfuscation = (_a = customProfiles.mNameObfuscation) === null || _a === void 0 ? void 0 : _a.mRenameProperties;
    exports.scanProjectConfig.mKeepStringProperty = (_b = customProfiles.mNameObfuscation) === null || _b === void 0 ? void 0 : _b.mKeepStringProperty;
    exports.scanProjectConfig.mExportObfuscation = customProfiles.mExportObfuscation;
    exports.scanProjectConfig.mkeepFilesAndDependencies = (_c = customProfiles.mKeepFileSourceCode) === null || _c === void 0 ? void 0 : _c.mkeepFilesAndDependencies;
    exports.scanProjectConfig.isHarCompiled = isHarCompiled;
}
/**
 * read project reserved properties by collected paths
 * @param filesForCompilation set collection of files
 * @param customProfiles
 */
function readProjectPropertiesByCollectedPaths(filesForCompilation, customProfiles, isHarCompiled) {
    const apiType = ApiExtractor_1.ApiExtractor.ApiType;
    let scanningCommonType = undefined;
    if (needReadApiInfo(customProfiles)) {
        scanningCommonType = apiType.PROJECT;
    }
    else {
        scanningCommonType = apiType.CONSTRUCTOR_PROPERTY;
    }
    // The purpose of collecting constructor properties is to avoid generating the same name as the constructor property when obfuscating identifier names.
    ApiExtractor_1.ApiExtractor.mConstructorPropertySet = new Set();
    initScanProjectConfig(customProfiles, isHarCompiled);
    OhsUtil_1.stringPropsSet.clear();
    const exportWhiteList = ApiExtractor_1.ApiExtractor.parseFileByPaths(filesForCompilation, scanningCommonType);
    const exportNamesAndProperties = exportWhiteList.reservedExportPropertyAndName;
    const exportNames = exportWhiteList.reservedExportNames;
    // if -enable-property-obfuscation, collect structPropsSet, exportNamesAndProperties and
    // stringPropsSet(if -enable-string-property-obufscation is not enabled) as whitelists.
    let exportNameAndPropSet;
    let structPropertySet;
    let stringPropertySet;
    let enumPropertySet;
    if (isEnabledPropertyObfuscation(customProfiles)) {
        exportNameAndPropSet = new Set(exportNamesAndProperties);
        structPropertySet = new Set(OhsUtil_1.structPropsSet);
        enumPropertySet = new Set(OhsUtil_1.enumPropsSet);
        if (exports.scanProjectConfig.mKeepStringProperty) {
            stringPropertySet = new Set(OhsUtil_1.stringPropsSet);
        }
    }
    OhsUtil_1.structPropsSet.clear();
    OhsUtil_1.stringPropsSet.clear();
    OhsUtil_1.enumPropsSet.clear();
    let exportNameSet;
    if (exports.scanProjectConfig.mExportObfuscation) {
        exportNameSet = new Set(exportNames);
    }
    // scanProjectConfig needs to be cleared to prevent affecting incremental compilation
    exports.scanProjectConfig = {};
    return {
        structPropertySet: structPropertySet,
        stringPropertySet: stringPropertySet,
        exportNameAndPropSet: exportNameAndPropSet,
        exportNameSet: exportNameSet,
        enumPropertySet: enumPropertySet,
    };
}
exports.readProjectPropertiesByCollectedPaths = readProjectPropertiesByCollectedPaths;
//# sourceMappingURL=ApiReader.js.map