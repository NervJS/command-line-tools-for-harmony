import type { Identifier, Node, ObjectBindingPattern, SourceFile, TypeChecker, TransformerFactory } from 'typescript';
import { Symbol } from 'typescript';
import { MergedConfig } from '../initialization/ConfigResolver';
export declare class NodeUtils {
    static isPropertyDeclarationNode(node: Node): boolean;
    static isPropertyOrElementAccessNode(node: Node): boolean;
    static isPropertyAccessNode(node: Node): boolean;
    private static isInClassDeclaration;
    static isInClassDeclarationForTest(node: Node | undefined): boolean;
    private static isInExpression;
    static isInExpressionForTest(node: Node | undefined): boolean;
    private static isInOperator;
    static isInOperatorForTest(node: Node | undefined): boolean;
    static isElementAccessNode(node: Node): boolean;
    static isIndexedAccessNode(node: Node): boolean;
    static isStringLiteralTypeNode(node: Node): boolean;
    static isClassPropertyInConstructorParams(node: Node): boolean;
    static isClassPropertyInConstructorBody(node: Node, constructorParams: Set<string>): boolean;
    static isPropertyNode(node: Node): boolean;
    static isObjectBindingPatternAssignment(node: ObjectBindingPattern): boolean;
    static isDeclarationFile(node: SourceFile): boolean;
    static getSourceFileOfNode(node: Node): SourceFile;
    static isDETSFile(node: Node | undefined): boolean;
    static isNewTargetNode(node: Identifier): boolean;
    static findSymbolOfIdentifier(checker: TypeChecker, node: Identifier): Symbol | undefined;
}
/**
 * When enabling property obfuscation, collect the properties of struct.
 * When enabling property obfuscation and the compilation output is a TS file,
 * collect the Identifier names in the initialization expressions of enum members.
 */
export declare function collectReservedNameForObf(obfuscationConfig: MergedConfig | undefined, shouldTransformToJs: boolean): TransformerFactory<SourceFile>;
