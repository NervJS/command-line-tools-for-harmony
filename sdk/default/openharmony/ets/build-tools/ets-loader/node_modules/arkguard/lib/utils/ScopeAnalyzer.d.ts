import type { Identifier, LabeledStatement, Node, SourceFile, Symbol, TypeChecker } from 'typescript';
/**
 * kind of a scope
 */
declare namespace secharmony {
    /**
     * A map used to track whether identifiers without symbols are in the top-level scope.
     */
    const exportElementsWithoutSymbol: Map<Node, boolean>;
    /**
     * Alias symbol for export elements with corresponding original symbol
     * key: symbols of export elements
     * value: original symbols of export elements
     */
    const exportSymbolAliasMap: Map<Symbol, Symbol>;
    /**
     * type of scope
     */
    enum ScopeKind {
        GLOBAL = 0,
        MODULE = 1,
        FUNCTION = 2,
        CLASS = 3,
        FOR = 4,
        SWITCH = 5,
        BLOCK = 6,
        INTERFACE = 7,
        CATCH = 8,
        ENUM = 9,
        OBJECT_LITERAL = 10
    }
    function isGlobalScope(scope: Scope): boolean;
    function isFunctionScope(scope: Scope): boolean;
    function isClassScope(scope: Scope): boolean;
    function isInterfaceScope(scope: Scope): boolean;
    function isEnumScope(scope: Scope): boolean;
    function isObjectLiteralScope(scope: Scope): boolean;
    /**
     * get a new scope.
     * @param name - name of the scope.
     * @param node - node of a current scope in ast.
     * @param type - type of the scope.
     * @param lexicalScope - indicates if the scope is a lexical scope.
     * @param upper - parent scope of the current scope.
     */
    class Scope {
        name: string;
        kind: ScopeKind;
        block: Node;
        parent: Scope | undefined;
        children: Scope[];
        defs: Set<Symbol>;
        labels: Label[];
        importNames: Set<string>;
        exportNames: Set<string>;
        fileExportNames?: Set<string>;
        fileImportNames?: Set<string>;
        mangledNames: Set<string>;
        loc: string;
        constructor(name: string, node: Node, type: ScopeKind, lexicalScope?: boolean, upper?: Scope);
        /**
         * add a sub scope to current scope
         *
         * @param child
         */
        addChild(child: Scope): void;
        /**
         * add definition symbol into current scope
         *
         * @param def definition symbol
         */
        addDefinition(def: Symbol, obfuscateAsProperty?: boolean): void;
        /**
         * add label to current scope
         *
         * @param label label statement
         */
        addLabel(label: Label): void;
        /**
         * get symbol location
         *
         * @param sym symbol
         */
        getSymbolLocation(sym: Symbol): string;
        /**
         * get label location
         *
         * @param label
         */
        getLabelLocation(label: Label): string;
    }
    interface Label {
        name: string;
        locInfo: string;
        refs: Identifier[];
        parent: Label | undefined;
        children: Label[];
        scope: Scope;
    }
    function createLabel(node: LabeledStatement, scope: Scope, parent?: Label | undefined): Label;
    interface ScopeManager {
        /**
         * get reserved names like ViewPU component class name
         */
        getReservedNames(): Set<string>;
        /**
         * do scope analysis
         *
         * @param ast ast tree of a source file
         * @param checker
         */
        analyze(ast: SourceFile, checker: TypeChecker, isEnabledExportObfuscation: boolean): void;
        /**
         * get root scope of a file
         */
        getRootScope(): Scope;
        /**
         * find block Scope of a node
         * @param node
         */
        getScopeOfNode(node: Node): Scope | undefined;
    }
    function createScopeManager(): ScopeManager;
    function getNameWithScopeLoc(scope: Scope, name: string): string;
}
export = secharmony;
