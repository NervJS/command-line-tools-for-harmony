"use strict";
/*
 * Copyright (c) 2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initObfuscationConfig = exports.printerConfig = exports.historyAllUnobfuscatedNamesMap = exports.historyUnobfuscatedPropMap = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const ArkObfuscator_1 = require("../ArkObfuscator");
const ConfigResolver_1 = require("./ConfigResolver");
exports.historyAllUnobfuscatedNamesMap = new Map();
exports.printerConfig = {
    // Print obfuscation time&memory usage of all files and obfuscation processes
    mFilesPrinter: false,
    // Print time&memory usage of a single file obfuscation in transform processes
    mSingleFilePrinter: false,
    // Print sum up time of transform processes during obfuscation
    mSumPrinter: false,
    // Output path of printer
    mOutputPath: '',
};
function initObfuscationConfig(projectConfig, arkProjectConfig, logger) {
    var _a;
    const obConfig = new ConfigResolver_1.ObConfigResolver(projectConfig, logger, true);
    const mergedObConfig = obConfig.resolveObfuscationConfigs();
    const isHarCompiled = projectConfig.compileHar;
    if (mergedObConfig.options.disableObfuscation) {
        (0, ArkObfuscator_1.blockPrinter)();
        return;
    }
    if (mergedObConfig.options.enableFileNameObfuscation) {
        const ohPackagePath = path_1.default.join(projectConfig.modulePath, 'oh-package.json5');
        const entryArray = arkProjectConfig.entryArrayForObf;
        const reservedFileNamesInIDEconfig = (0, ConfigResolver_1.collectResevedFileNameInIDEConfig)(ohPackagePath, projectConfig, arkProjectConfig.modulePathMap, entryArray);
        mergedObConfig.reservedFileNames.push(...reservedFileNamesInIDEconfig);
    }
    arkProjectConfig.obfuscationMergedObConfig = mergedObConfig;
    arkProjectConfig.arkObfuscator = initArkGuardConfig((_a = projectConfig.obfuscationOptions) === null || _a === void 0 ? void 0 : _a.obfuscationCacheDir, logger, mergedObConfig, isHarCompiled);
}
exports.initObfuscationConfig = initObfuscationConfig;
function initArkGuardConfig(obfuscationCacheDir, logger, mergedObConfig, isHarCompiled) {
    const arkguardConfig = {
        mCompact: mergedObConfig.options.compact,
        mDisableConsole: mergedObConfig.options.removeLog,
        mSimplify: false,
        mRemoveComments: true,
        mNameObfuscation: {
            mEnable: true,
            mNameGeneratorType: 1,
            mReservedNames: mergedObConfig.reservedNames,
            mRenameProperties: mergedObConfig.options.enablePropertyObfuscation,
            mReservedProperties: mergedObConfig.reservedPropertyNames,
            mKeepStringProperty: !mergedObConfig.options.enableStringPropertyObfuscation,
            mTopLevel: mergedObConfig.options.enableToplevelObfuscation,
            mReservedToplevelNames: mergedObConfig.reservedGlobalNames,
            mUniversalReservedProperties: mergedObConfig.universalReservedPropertyNames,
            mUniversalReservedToplevelNames: mergedObConfig.universalReservedGlobalNames
        },
        mUnobfuscationOption: {
            mPrintKeptNames: mergedObConfig.options.printKeptNames,
            mPrintPath: mergedObConfig.options.printKeptNamesPath
        },
        mRemoveDeclarationComments: {
            mEnable: mergedObConfig.options.removeComments,
            mReservedComments: mergedObConfig.keepComments,
        },
        mEnableSourceMap: true,
        mEnableNameCache: true,
        mRenameFileName: {
            mEnable: mergedObConfig.options.enableFileNameObfuscation,
            mNameGeneratorType: 1,
            mReservedFileNames: mergedObConfig.reservedFileNames,
        },
        mExportObfuscation: mergedObConfig.options.enableExportObfuscation,
        mPerformancePrinter: exports.printerConfig,
        mKeepFileSourceCode: {
            mKeepSourceOfPaths: new Set(),
            mkeepFilesAndDependencies: new Set(),
        },
    };
    const arkObfuscator = new ArkObfuscator_1.ArkObfuscator();
    arkObfuscator.init(arkguardConfig);
    if (mergedObConfig.options.applyNameCache && mergedObConfig.options.applyNameCache.length > 0) {
        (0, ConfigResolver_1.readNameCache)(mergedObConfig.options.applyNameCache, logger);
    }
    else {
        if (obfuscationCacheDir) {
            const defaultNameCachePath = path_1.default.join(obfuscationCacheDir, 'nameCache.json');
            if (fs_1.default.existsSync(defaultNameCachePath)) {
                (0, ConfigResolver_1.readNameCache)(defaultNameCachePath, logger);
            }
        }
    }
    if (mergedObConfig.options.printKeptNames && obfuscationCacheDir) {
        const defaultUnobfuscationPath = path_1.default.join(obfuscationCacheDir, 'keptNames.json');
        if (fs_1.default.existsSync(defaultUnobfuscationPath)) {
            readUnobfuscationContent(defaultUnobfuscationPath, logger);
        }
    }
    return arkObfuscator;
}
function readUnobfuscationContent(defaultUnobfuscationPath, logger) {
    try {
        const unobfuscationContent = fs_1.default.readFileSync(defaultUnobfuscationPath, 'utf-8');
        const unobfuscationObj = JSON.parse(unobfuscationContent);
        if (Object.keys(unobfuscationObj.keptNames.property).length !== 0) {
            exports.historyUnobfuscatedPropMap = new Map(Object.entries(unobfuscationObj.keptNames.property));
        }
        const _a = unobfuscationObj.keptNames, { property } = _a, rest = __rest(_a, ["property"]);
        Object.keys(rest).forEach((key) => {
            exports.historyAllUnobfuscatedNamesMap.set(key, rest[key]);
        });
    }
    catch (err) {
        logger.error(`Failed to open ${defaultUnobfuscationPath}. Error message: ${err}`);
    }
}
//# sourceMappingURL=Initializer.js.map