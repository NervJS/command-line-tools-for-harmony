"use strict";
/*
 * Copyright (c) 2023-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArkObfuscator = exports.clearGlobalCaches = exports.performancePrinter = exports.cleanFileMangledNames = exports.orignalFilePathForSearching = exports.PropCollections = exports.ApiExtractor = exports.deleteLineInfoForNameString = exports.readProjectPropertiesByCollectedPaths = exports.getMapFromJson = exports.renameFileNameModule = exports.renameIdentifierModule = exports.collectReservedNameForObf = exports.writeUnobfuscationContent = exports.writeObfuscationNameCache = exports.readNameCache = exports.ObConfigResolver = exports.MergedConfig = exports.mangleFilePath = exports.handleUniversalPathInObf = exports.handleObfuscatedFilePath = exports.getRelativeSourcePath = exports.generateConsumerObConfigFile = exports.enableObfuscateFileName = exports.enableObfuscatedFilePathConfig = exports.collectResevedFileNameInIDEConfig = exports.unobfuscationNamesObj = exports.nameCacheMap = exports.initObfuscationConfig = exports.wildcardTransformer = exports.containWildcards = exports.separateUniversalReservedItem = exports.UnobfuscationCollections = exports.MemoryUtils = exports.FileUtils = exports.startSingleFileEvent = exports.startFilesEvent = exports.printTimeSumInfo = exports.printTimeSumData = exports.endSingleFileEvent = exports.endFilesEvent = exports.blockPrinter = exports.TimeSumPrinter = exports.EventList = void 0;
const typescript_1 = require("typescript");
const path_1 = __importDefault(require("path"));
const CommonCollections_1 = require("./utils/CommonCollections");
Object.defineProperty(exports, "PropCollections", { enumerable: true, get: function () { return CommonCollections_1.PropCollections; } });
const FileUtils_1 = require("./utils/FileUtils");
const TransformerManager_1 = require("./transformers/TransformerManager");
const SourceMapUtil_1 = require("./utils/SourceMapUtil");
const SourceMapMergingUtil_1 = require("./utils/SourceMapMergingUtil");
const NameCacheUtil_1 = require("./utils/NameCacheUtil");
Object.defineProperty(exports, "deleteLineInfoForNameString", { enumerable: true, get: function () { return NameCacheUtil_1.deleteLineInfoForNameString; } });
Object.defineProperty(exports, "getMapFromJson", { enumerable: true, get: function () { return NameCacheUtil_1.getMapFromJson; } });
const ApiReader_1 = require("./common/ApiReader");
Object.defineProperty(exports, "readProjectPropertiesByCollectedPaths", { enumerable: true, get: function () { return ApiReader_1.readProjectPropertiesByCollectedPaths; } });
const ApiExtractor_1 = require("./common/ApiExtractor");
Object.defineProperty(exports, "ApiExtractor", { enumerable: true, get: function () { return ApiExtractor_1.ApiExtractor; } });
const es_reserved_properties_json_1 = __importDefault(require("./configs/preset/es_reserved_properties.json"));
const PrinterUtils_1 = require("./utils/PrinterUtils");
var PrinterUtils_2 = require("./utils/PrinterUtils");
Object.defineProperty(exports, "EventList", { enumerable: true, get: function () { return PrinterUtils_2.EventList; } });
Object.defineProperty(exports, "TimeSumPrinter", { enumerable: true, get: function () { return PrinterUtils_2.TimeSumPrinter; } });
Object.defineProperty(exports, "blockPrinter", { enumerable: true, get: function () { return PrinterUtils_2.blockPrinter; } });
Object.defineProperty(exports, "endFilesEvent", { enumerable: true, get: function () { return PrinterUtils_2.endFilesEvent; } });
Object.defineProperty(exports, "endSingleFileEvent", { enumerable: true, get: function () { return PrinterUtils_2.endSingleFileEvent; } });
Object.defineProperty(exports, "printTimeSumData", { enumerable: true, get: function () { return PrinterUtils_2.printTimeSumData; } });
Object.defineProperty(exports, "printTimeSumInfo", { enumerable: true, get: function () { return PrinterUtils_2.printTimeSumInfo; } });
Object.defineProperty(exports, "startFilesEvent", { enumerable: true, get: function () { return PrinterUtils_2.startFilesEvent; } });
Object.defineProperty(exports, "startSingleFileEvent", { enumerable: true, get: function () { return PrinterUtils_2.startSingleFileEvent; } });
var FileUtils_2 = require("./utils/FileUtils");
Object.defineProperty(exports, "FileUtils", { enumerable: true, get: function () { return FileUtils_2.FileUtils; } });
var MemoryUtils_1 = require("./utils/MemoryUtils");
Object.defineProperty(exports, "MemoryUtils", { enumerable: true, get: function () { return MemoryUtils_1.MemoryUtils; } });
const TypeUtils_1 = require("./utils/TypeUtils");
const TransformUtil_1 = require("./utils/TransformUtil");
const CommonCollections_2 = require("./utils/CommonCollections");
const Initializer_1 = require("./initialization/Initializer");
var CommonCollections_3 = require("./utils/CommonCollections");
Object.defineProperty(exports, "UnobfuscationCollections", { enumerable: true, get: function () { return CommonCollections_3.UnobfuscationCollections; } });
var TransformUtil_2 = require("./utils/TransformUtil");
Object.defineProperty(exports, "separateUniversalReservedItem", { enumerable: true, get: function () { return TransformUtil_2.separateUniversalReservedItem; } });
Object.defineProperty(exports, "containWildcards", { enumerable: true, get: function () { return TransformUtil_2.containWildcards; } });
Object.defineProperty(exports, "wildcardTransformer", { enumerable: true, get: function () { return TransformUtil_2.wildcardTransformer; } });
var Initializer_2 = require("./initialization/Initializer");
Object.defineProperty(exports, "initObfuscationConfig", { enumerable: true, get: function () { return Initializer_2.initObfuscationConfig; } });
var CommonObject_1 = require("./initialization/CommonObject");
Object.defineProperty(exports, "nameCacheMap", { enumerable: true, get: function () { return CommonObject_1.nameCacheMap; } });
Object.defineProperty(exports, "unobfuscationNamesObj", { enumerable: true, get: function () { return CommonObject_1.unobfuscationNamesObj; } });
var ConfigResolver_1 = require("./initialization/ConfigResolver");
Object.defineProperty(exports, "collectResevedFileNameInIDEConfig", { enumerable: true, get: function () { return ConfigResolver_1.collectResevedFileNameInIDEConfig; } });
Object.defineProperty(exports, "enableObfuscatedFilePathConfig", { enumerable: true, get: function () { return ConfigResolver_1.enableObfuscatedFilePathConfig; } });
Object.defineProperty(exports, "enableObfuscateFileName", { enumerable: true, get: function () { return ConfigResolver_1.enableObfuscateFileName; } });
Object.defineProperty(exports, "generateConsumerObConfigFile", { enumerable: true, get: function () { return ConfigResolver_1.generateConsumerObConfigFile; } });
Object.defineProperty(exports, "getRelativeSourcePath", { enumerable: true, get: function () { return ConfigResolver_1.getRelativeSourcePath; } });
Object.defineProperty(exports, "handleObfuscatedFilePath", { enumerable: true, get: function () { return ConfigResolver_1.handleObfuscatedFilePath; } });
Object.defineProperty(exports, "handleUniversalPathInObf", { enumerable: true, get: function () { return ConfigResolver_1.handleUniversalPathInObf; } });
Object.defineProperty(exports, "mangleFilePath", { enumerable: true, get: function () { return ConfigResolver_1.mangleFilePath; } });
Object.defineProperty(exports, "MergedConfig", { enumerable: true, get: function () { return ConfigResolver_1.MergedConfig; } });
Object.defineProperty(exports, "ObConfigResolver", { enumerable: true, get: function () { return ConfigResolver_1.ObConfigResolver; } });
Object.defineProperty(exports, "readNameCache", { enumerable: true, get: function () { return ConfigResolver_1.readNameCache; } });
Object.defineProperty(exports, "writeObfuscationNameCache", { enumerable: true, get: function () { return ConfigResolver_1.writeObfuscationNameCache; } });
Object.defineProperty(exports, "writeUnobfuscationContent", { enumerable: true, get: function () { return ConfigResolver_1.writeUnobfuscationContent; } });
var NodeUtils_1 = require("./utils/NodeUtils");
Object.defineProperty(exports, "collectReservedNameForObf", { enumerable: true, get: function () { return NodeUtils_1.collectReservedNameForObf; } });
exports.renameIdentifierModule = require('./transformers/rename/RenameIdentifierTransformer');
exports.renameFileNameModule = require('./transformers/rename/RenameFileNameTransformer');
exports.cleanFileMangledNames = false;
exports.performancePrinter = {
    filesPrinter: new PrinterUtils_1.TimeTracker(),
    singleFilePrinter: new PrinterUtils_1.TimeTracker(),
    timeSumPrinter: new PrinterUtils_1.TimeSumPrinter(),
};
// When the module is compiled, call this function to clear global collections.
function clearGlobalCaches() {
    CommonCollections_1.PropCollections.clearPropsCollections();
    CommonCollections_2.UnobfuscationCollections.clear();
    CommonCollections_1.LocalVariableCollections.clear();
    exports.renameFileNameModule.clearCaches();
}
exports.clearGlobalCaches = clearGlobalCaches;
const JSON_TEXT_INDENT_LENGTH = 2;
class ArkObfuscator {
    constructor() {
        // Used only for testing
        this.mWriteOriginalFile = false;
        this.mCompilerOptions = {};
        this.mTransformers = [];
    }
    setWriteOriginalFile(flag) {
        this.mWriteOriginalFile = flag;
    }
    // Pass the collected whitelists related to property obfuscation to Arkguard.
    addReservedSetForPropertyObf(properties) {
        if (properties.structPropertySet && properties.structPropertySet.size > 0) {
            for (let reservedProperty of properties.structPropertySet) {
                CommonCollections_2.UnobfuscationCollections.reservedStruct.add(reservedProperty);
            }
        }
        if (properties.stringPropertySet && properties.stringPropertySet.size > 0) {
            CommonCollections_2.UnobfuscationCollections.reservedStrProp = properties.stringPropertySet;
        }
        if (properties.exportNameAndPropSet && properties.exportNameAndPropSet.size > 0) {
            CommonCollections_2.UnobfuscationCollections.reservedExportNameAndProp = properties.exportNameAndPropSet;
        }
        if (properties.enumPropertySet && properties.enumPropertySet.size > 0) {
            for (let reservedEnum of properties.enumPropertySet) {
                CommonCollections_2.UnobfuscationCollections.reservedEnum.add(reservedEnum);
            }
        }
    }
    addReservedSetForDefaultObf(properties) {
        if (properties.exportNameSet && properties.exportNameSet.size > 0) {
            CommonCollections_2.UnobfuscationCollections.reservedExportName = properties.exportNameSet;
        }
    }
    setKeepSourceOfPaths(mKeepSourceOfPaths) {
        this.mCustomProfiles.mKeepFileSourceCode.mKeepSourceOfPaths = mKeepSourceOfPaths;
    }
    handleTsHarComments(sourceFile, originalPath) {
        var _a;
        if (((_a = ArkObfuscator.projectInfo) === null || _a === void 0 ? void 0 : _a.useTsHar) && ((originalPath === null || originalPath === void 0 ? void 0 : originalPath.endsWith(".ets" /* Extension.ETS */)) && !(originalPath === null || originalPath === void 0 ? void 0 : originalPath.endsWith(".d.ets" /* Extension.DETS */)))) {
            // @ts-ignore
            sourceFile.writeTsHarComments = true;
        }
    }
    get customProfiles() {
        return this.mCustomProfiles;
    }
    static get isKeptCurrentFile() {
        return ArkObfuscator.mIsKeptCurrentFile;
    }
    static set isKeptCurrentFile(isKeptFile) {
        ArkObfuscator.mIsKeptCurrentFile = isKeptFile;
    }
    static get projectInfo() {
        return ArkObfuscator.mProjectInfo;
    }
    static set projectInfo(projectInfo) {
        ArkObfuscator.mProjectInfo = projectInfo;
    }
    isCurrentFileInKeepPaths(customProfiles, originalFilePath) {
        const keepFileSourceCode = customProfiles.mKeepFileSourceCode;
        if (keepFileSourceCode === undefined || keepFileSourceCode.mKeepSourceOfPaths.size === 0) {
            return false;
        }
        const keepPaths = keepFileSourceCode.mKeepSourceOfPaths;
        const originalPath = FileUtils_1.FileUtils.toUnixPath(originalFilePath);
        return keepPaths.has(originalPath);
    }
    /**
     * init ArkObfuscator according to user config
     * should be called after constructor
     */
    init(config) {
        var _a, _b;
        if (!config) {
            console.error('obfuscation config file is not found and no given config.');
            return false;
        }
        (0, TransformUtil_1.handleReservedConfig)(config, 'mRenameFileName', 'mReservedFileNames', 'mUniversalReservedFileNames');
        (0, TransformUtil_1.handleReservedConfig)(config, 'mRemoveDeclarationComments', 'mReservedComments', 'mUniversalReservedComments', 'mEnable');
        this.mCustomProfiles = config;
        if (this.mCustomProfiles.mCompact) {
            this.mTextWriter = (0, typescript_1.createObfTextSingleLineWriter)();
        }
        else {
            this.mTextWriter = (0, typescript_1.createTextWriter)('\n');
        }
        if (this.mCustomProfiles.mEnableSourceMap) {
            this.mCompilerOptions.sourceMap = true;
        }
        const enableTopLevel = (_a = this.mCustomProfiles.mNameObfuscation) === null || _a === void 0 ? void 0 : _a.mTopLevel;
        const exportObfuscation = this.mCustomProfiles.mExportObfuscation;
        const propertyObfuscation = (_b = this.mCustomProfiles.mNameObfuscation) === null || _b === void 0 ? void 0 : _b.mRenameProperties;
        /**
         * clean mangledNames in case skip name check when generating names
         */
        exports.cleanFileMangledNames = enableTopLevel && !exportObfuscation && !propertyObfuscation;
        // load transformers
        this.mTransformers = new TransformerManager_1.TransformerManager(this.mCustomProfiles).getTransformers();
        (0, PrinterUtils_1.initPerformancePrinter)(this.mCustomProfiles);
        if ((0, ApiReader_1.needReadApiInfo)(this.mCustomProfiles)) {
            // if -enable-property-obfuscation or -enable-export-obfuscation, collect language reserved keywords.
            let languageSet = new Set();
            for (const key of Object.keys(es_reserved_properties_json_1.default)) {
                const valueArray = es_reserved_properties_json_1.default[key];
                valueArray.forEach((element) => {
                    languageSet.add(element);
                });
            }
            CommonCollections_2.UnobfuscationCollections.reservedLangForProperty = languageSet;
        }
        return true;
    }
    /**
     * A Printer to output obfuscated codes.
     */
    createObfsPrinter(isDeclarationFile) {
        var _a, _b;
        // set print options
        let printerOptions = {};
        let removeOption = this.mCustomProfiles.mRemoveDeclarationComments;
        let hasReservedList = ((_a = removeOption === null || removeOption === void 0 ? void 0 : removeOption.mReservedComments) === null || _a === void 0 ? void 0 : _a.length) || ((_b = removeOption === null || removeOption === void 0 ? void 0 : removeOption.mUniversalReservedComments) === null || _b === void 0 ? void 0 : _b.length);
        let keepDeclarationComments = hasReservedList || !(removeOption === null || removeOption === void 0 ? void 0 : removeOption.mEnable);
        if (isDeclarationFile && keepDeclarationComments) {
            printerOptions.removeComments = false;
        }
        if ((!isDeclarationFile && this.mCustomProfiles.mRemoveComments) || (isDeclarationFile && !keepDeclarationComments)) {
            printerOptions.removeComments = true;
        }
        return (0, typescript_1.createPrinter)(printerOptions);
    }
    isObfsIgnoreFile(fileName) {
        let suffix = FileUtils_1.FileUtils.getFileExtension(fileName);
        return suffix !== 'js' && suffix !== 'ts' && suffix !== 'ets';
    }
    convertLineBasedOnSourceMap(targetCache, sourceMapLink) {
        let originalCache = exports.renameIdentifierModule.nameCache.get(targetCache);
        let updatedCache = new Map();
        for (const [key, value] of originalCache) {
            if (!key.includes(':')) {
                // No need to save line info for identifier which is not function-like, i.e. key without ':' here.
                updatedCache[key] = value;
                continue;
            }
            const [scopeName, oldStartLine, oldStartColumn, oldEndLine, oldEndColumn] = key.split(':');
            let newKey = key;
            if (!sourceMapLink) {
                // In Arkguard, we save line info of source code, so do not need to use sourcemap mapping.
                newKey = `${scopeName}:${oldStartLine}:${oldEndLine}`;
                updatedCache[newKey] = value;
                continue;
            }
            const startPosition = sourceMapLink.traceSegment(
            // 1: The line number in originalCache starts from 1 while in source map starts from 0.
            Number(oldStartLine) - 1, Number(oldStartColumn) - 1, ''); // Minus 1 to get the correct original position.
            if (!startPosition) {
                // Do not save methods that do not exist in the source code, e.g. 'build' in ArkUI.
                continue;
            }
            const endPosition = sourceMapLink.traceSegment(Number(oldEndLine) - 1, Number(oldEndColumn) - 1, ''); // 1: Same as above.
            if (!endPosition) {
                // Do not save methods that do not exist in the source code, e.g. 'build' in ArkUI.
                continue;
            }
            const startLine = startPosition.line + 1; // 1: The final line number in updatedCache should starts from 1.
            const endLine = endPosition.line + 1; // 1: Same as above.
            newKey = `${scopeName}:${startLine}:${endLine}`;
            updatedCache[newKey] = value;
        }
        return updatedCache;
    }
    /**
     * Obfuscate ast of a file.
     * @param content ast or source code of a source file
     * @param sourceFilePathObj
     * @param previousStageSourceMap
     * @param historyNameCache
     * @param originalFilePath When filename obfuscation is enabled, it is used as the source code path.
     */
    obfuscate(content, sourceFilePathObj, previousStageSourceMap, historyNameCache, originalFilePath, projectInfo) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            ArkObfuscator.projectInfo = projectInfo;
            let result = { content: undefined };
            if (this.isObfsIgnoreFile(sourceFilePathObj.buildFilePath)) {
                // need add return value
                return result;
            }
            let ast = this.createAst(content, sourceFilePathObj.buildFilePath);
            if (ast.statements.length === 0) {
                return result;
            }
            if (historyNameCache && historyNameCache.size > 0 && this.mCustomProfiles.mNameObfuscation) {
                exports.renameIdentifierModule.historyNameCache = historyNameCache;
            }
            if ((_a = this.mCustomProfiles.mUnobfuscationOption) === null || _a === void 0 ? void 0 : _a.mPrintKeptNames) {
                let historyUnobfuscatedNames = Initializer_1.historyAllUnobfuscatedNamesMap.get(sourceFilePathObj.relativeFilePath);
                if (historyUnobfuscatedNames) {
                    exports.renameIdentifierModule.historyUnobfuscatedNamesMap = new Map(Object.entries(historyUnobfuscatedNames));
                }
            }
            originalFilePath = originalFilePath !== null && originalFilePath !== void 0 ? originalFilePath : ast.fileName;
            if ((_b = this.mCustomProfiles.mRenameFileName) === null || _b === void 0 ? void 0 : _b.mEnable) {
                exports.orignalFilePathForSearching = originalFilePath;
            }
            ArkObfuscator.isKeptCurrentFile = this.isCurrentFileInKeepPaths(this.mCustomProfiles, originalFilePath);
            this.handleDeclarationFile(ast);
            ast = this.obfuscateAst(ast);
            this.writeObfuscationResult(ast, sourceFilePathObj.buildFilePath, result, previousStageSourceMap, originalFilePath);
            this.clearCaches();
            return result;
        });
    }
    createAst(content, sourceFilePath) {
        (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.CREATE_AST, exports.performancePrinter.timeSumPrinter);
        let ast;
        if (typeof content === 'string') {
            ast = TypeUtils_1.TypeUtils.createObfSourceFile(sourceFilePath, content);
        }
        else {
            ast = content;
        }
        (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.CREATE_AST, exports.performancePrinter.timeSumPrinter);
        return ast;
    }
    obfuscateAst(ast) {
        (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.OBFUSCATE_AST, exports.performancePrinter.timeSumPrinter);
        let transformedResult = (0, typescript_1.transform)(ast, this.mTransformers, this.mCompilerOptions);
        (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.OBFUSCATE_AST, exports.performancePrinter.timeSumPrinter);
        ast = transformedResult.transformed[0];
        return ast;
    }
    handleDeclarationFile(ast) {
        var _a, _b;
        if (ast.isDeclarationFile) {
            if (!this.mCustomProfiles.mRemoveDeclarationComments || !this.mCustomProfiles.mRemoveDeclarationComments.mEnable) {
                //@ts-ignore
                ast.reservedComments = undefined;
                //@ts-ignore
                ast.universalReservedComments = undefined;
            }
            else {
                //@ts-ignore
                (_a = ast.reservedComments) !== null && _a !== void 0 ? _a : (ast.reservedComments = this.mCustomProfiles.mRemoveDeclarationComments.mReservedComments ?
                    this.mCustomProfiles.mRemoveDeclarationComments.mReservedComments : []);
                //@ts-ignore
                ast.universalReservedComments = (_b = this.mCustomProfiles.mRemoveDeclarationComments.mUniversalReservedComments) !== null && _b !== void 0 ? _b : [];
            }
        }
        else {
            //@ts-ignore
            ast.reservedComments = this.mCustomProfiles.mRemoveComments ? [] : undefined;
            //@ts-ignore
            ast.universalReservedComments = this.mCustomProfiles.mRemoveComments ? [] : undefined;
        }
    }
    /**
     * write obfuscated code, sourcemap and namecache
     */
    writeObfuscationResult(ast, sourceFilePath, result, previousStageSourceMap, originalFilePath) {
        var _a;
        // convert ast to output source file and generate sourcemap if needed.
        let sourceMapGenerator = undefined;
        if (this.mCustomProfiles.mEnableSourceMap) {
            (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.GET_SOURCEMAP_GENERATOR, exports.performancePrinter.timeSumPrinter);
            sourceMapGenerator = (0, SourceMapUtil_1.getSourceMapGenerator)(sourceFilePath);
            (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.GET_SOURCEMAP_GENERATOR, exports.performancePrinter.timeSumPrinter);
        }
        (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.CREATE_PRINTER, exports.performancePrinter.timeSumPrinter);
        if (sourceFilePath.endsWith('.js')) {
            TypeUtils_1.TypeUtils.tsToJs(ast);
        }
        this.handleTsHarComments(ast, originalFilePath);
        this.createObfsPrinter(ast.isDeclarationFile).writeFile(ast, this.mTextWriter, sourceMapGenerator);
        (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.CREATE_PRINTER, exports.performancePrinter.timeSumPrinter);
        result.filePath = ast.fileName;
        result.content = this.mTextWriter.getText();
        if ((_a = this.mCustomProfiles.mUnobfuscationOption) === null || _a === void 0 ? void 0 : _a.mPrintKeptNames) {
            this.handleUnobfuscationNames(result);
        }
        if (this.mCustomProfiles.mEnableSourceMap && sourceMapGenerator) {
            this.handleSourceMapAndNameCache(sourceMapGenerator, sourceFilePath, result, previousStageSourceMap);
        }
    }
    handleUnobfuscationNames(result) {
        result.unobfuscationNameMap = new Map(CommonCollections_2.UnobfuscationCollections.unobfuscatedNamesMap);
    }
    handleSourceMapAndNameCache(sourceMapGenerator, sourceFilePath, result, previousStageSourceMap) {
        var _a;
        (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.SOURCEMAP_MERGE, exports.performancePrinter.timeSumPrinter);
        let sourceMapJson = sourceMapGenerator.toJSON();
        sourceMapJson.sourceRoot = '';
        sourceMapJson.file = path_1.default.basename(sourceFilePath);
        if (previousStageSourceMap) {
            sourceMapJson = (0, SourceMapMergingUtil_1.mergeSourceMap)(previousStageSourceMap, sourceMapJson);
        }
        result.sourceMap = sourceMapJson;
        (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.SOURCEMAP_MERGE, exports.performancePrinter.timeSumPrinter);
        (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.CREATE_NAMECACHE, exports.performancePrinter.timeSumPrinter);
        let nameCache = exports.renameIdentifierModule.nameCache;
        if (this.mCustomProfiles.mEnableNameCache) {
            let newIdentifierCache;
            let newMemberMethodCache;
            if (previousStageSourceMap) {
                // The process in sdk, need to use sourcemap mapping.
                // 1: Only one file in the source map; 0: The first and the only one.
                const sourceFileName = ((_a = previousStageSourceMap.sources) === null || _a === void 0 ? void 0 : _a.length) === 1 ? previousStageSourceMap.sources[0] : '';
                const source = new SourceMapMergingUtil_1.Source(sourceFileName, null);
                const decodedSourceMap = (0, SourceMapMergingUtil_1.decodeSourcemap)(previousStageSourceMap);
                let sourceMapLink = new SourceMapMergingUtil_1.SourceMapLink(decodedSourceMap, [source]);
                newIdentifierCache = this.convertLineBasedOnSourceMap(NameCacheUtil_1.IDENTIFIER_CACHE, sourceMapLink);
                newMemberMethodCache = this.convertLineBasedOnSourceMap(NameCacheUtil_1.MEM_METHOD_CACHE, sourceMapLink);
            }
            else {
                // The process in Arkguard.
                newIdentifierCache = this.convertLineBasedOnSourceMap(NameCacheUtil_1.IDENTIFIER_CACHE);
                newMemberMethodCache = this.convertLineBasedOnSourceMap(NameCacheUtil_1.MEM_METHOD_CACHE);
            }
            nameCache.set(NameCacheUtil_1.IDENTIFIER_CACHE, newIdentifierCache);
            nameCache.set(NameCacheUtil_1.MEM_METHOD_CACHE, newMemberMethodCache);
            result.nameCache = { [NameCacheUtil_1.IDENTIFIER_CACHE]: newIdentifierCache, [NameCacheUtil_1.MEM_METHOD_CACHE]: newMemberMethodCache };
        }
        (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.CREATE_NAMECACHE, exports.performancePrinter.timeSumPrinter);
    }
    clearCaches() {
        // clear cache of text writer
        this.mTextWriter.clear();
        exports.renameIdentifierModule.clearCaches();
        if (exports.cleanFileMangledNames) {
            CommonCollections_1.PropCollections.globalMangledTable.clear();
            CommonCollections_1.PropCollections.newlyOccupiedMangledProps.clear();
        }
        CommonCollections_2.UnobfuscationCollections.unobfuscatedNamesMap.clear();
    }
}
exports.ArkObfuscator = ArkObfuscator;
// If isKeptCurrentFile is true, both identifier and property obfuscation are skipped.
ArkObfuscator.mIsKeptCurrentFile = false;
//# sourceMappingURL=ArkObfuscator.js.map