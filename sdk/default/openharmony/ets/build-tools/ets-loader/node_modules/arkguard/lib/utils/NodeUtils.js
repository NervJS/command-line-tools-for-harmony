"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectReservedNameForObf = exports.NodeUtils = void 0;
const typescript_1 = require("typescript");
const OhsUtil_1 = require("./OhsUtil");
class NodeUtils {
    static isPropertyDeclarationNode(node) {
        let parent = node.parent;
        if (!parent) {
            return false;
        }
        /** eg: { 'name'' : 'akira' }, pass */
        if ((0, typescript_1.isPropertyAssignment)(parent)) {
            return parent.name === node;
        }
        if ((0, typescript_1.isComputedPropertyName)(parent) && parent.expression === node) {
            return true;
        }
        /** object binding pattern */
        if ((0, typescript_1.isBindingElement)(parent) && parent.propertyName === node) {
            return true;
        }
        /** eg: interface/type inf { 'name' : string}, pass */
        if ((0, typescript_1.isPropertySignature)(parent) && parent.name === node) {
            return true;
        }
        /** eg: interface/type T1 { func(arg: string): number;} */
        if ((0, typescript_1.isMethodSignature)(parent) && parent.name === node) {
            return true;
        }
        /** eg: enum { xxx = 1}; */
        if ((0, typescript_1.isEnumMember)(parent) && parent.name === node) {
            return true;
        }
        /** class { private name= 1}; */
        if ((0, typescript_1.isPropertyDeclaration)(parent) && parent.name === node) {
            return true;
        }
        /** class {'getName': function() {}} let _ = { getName() [}} */
        if ((0, typescript_1.isMethodDeclaration)(parent) && parent.name === node) {
            return true;
        }
        if ((0, typescript_1.isSetAccessor)(parent) && parent.name === node) {
            return true;
        }
        return (0, typescript_1.isGetAccessor)(parent) && parent.name === node;
    }
    static isPropertyOrElementAccessNode(node) {
        return this.isPropertyAccessNode(node) || this.isElementAccessNode(node) || false;
    }
    static isPropertyAccessNode(node) {
        let parent = node.parent;
        if (!parent) {
            return false;
        }
        /** eg: a.b = 1 */
        if ((0, typescript_1.isPropertyAccessExpression)(parent) && parent.name === node) {
            return true;
        }
        if ((0, typescript_1.isPrivateIdentifier)(node) && NodeUtils.isInClassDeclaration(parent)) {
            return NodeUtils.isInExpression(parent);
        }
        return (0, typescript_1.isQualifiedName)(parent) && parent.right === node;
    }
    static isInClassDeclaration(node) {
        if (!node) {
            return false;
        }
        if ((0, typescript_1.isClassDeclaration)(node) || (0, typescript_1.isClassExpression)(node)) {
            return true;
        }
        return NodeUtils.isInClassDeclaration(node.parent);
    }
    static isInClassDeclarationForTest(node) {
        return NodeUtils.isInClassDeclaration(node);
    }
    static isInExpression(node) {
        return !!node && NodeUtils.isInOperator(node);
    }
    static isInExpressionForTest(node) {
        return NodeUtils.isInExpression(node);
    }
    static isInOperator(node) {
        return (0, typescript_1.isBinaryExpression)(node) && node.operatorToken.kind === typescript_1.SyntaxKind.InKeyword;
    }
    static isInOperatorForTest(node) {
        return NodeUtils.isInOperator(node);
    }
    static isElementAccessNode(node) {
        let parent = node.parent;
        if (!parent) {
            return false;
        }
        return (0, typescript_1.isElementAccessExpression)(parent) && parent.argumentExpression === node;
    }
    static isIndexedAccessNode(node) {
        let parent = node.parent;
        if (!parent) {
            return false;
        }
        return (0, typescript_1.isIndexedAccessTypeNode)(parent) && parent.indexType === node;
    }
    static isStringLiteralTypeNode(node) {
        return (0, typescript_1.isLiteralTypeNode)(node) && (0, typescript_1.isStringLiteralLike)(node.literal);
    }
    static isClassPropertyInConstructorParams(node) {
        if (!(0, typescript_1.isIdentifier)(node)) {
            return false;
        }
        if (!node.parent || !(0, typescript_1.isParameter)(node.parent)) {
            return false;
        }
        const modifiers = (0, typescript_1.getModifiers)(node.parent);
        if (!modifiers || modifiers.length === 0 || !modifiers.find(modifier => (0, OhsUtil_1.isParameterPropertyModifier)(modifier))) {
            return false;
        }
        return node.parent.parent && (0, typescript_1.isConstructorDeclaration)(node.parent.parent);
    }
    static isClassPropertyInConstructorBody(node, constructorParams) {
        if (!(0, typescript_1.isIdentifier)(node)) {
            return false;
        }
        const id = node.escapedText.toString();
        let curNode = node.parent;
        while (curNode) {
            if ((0, typescript_1.isConstructorDeclaration)(curNode) && constructorParams.has(id)) {
                return true;
            }
            curNode = curNode.parent;
        }
        return false;
    }
    static isPropertyNode(node) {
        if (this.isPropertyOrElementAccessNode(node)) {
            return true;
        }
        if (this.isIndexedAccessNode(node)) {
            return true;
        }
        return this.isPropertyDeclarationNode(node);
    }
    static isObjectBindingPatternAssignment(node) {
        if (!node || !node.parent || !(0, typescript_1.isVariableDeclaration)(node.parent)) {
            return false;
        }
        const initializer = node.parent.initializer;
        return initializer && (0, typescript_1.isCallExpression)(initializer);
    }
    static isDeclarationFile(node) {
        return node.isDeclarationFile;
    }
    static getSourceFileOfNode(node) {
        while (node && node.kind !== typescript_1.SyntaxKind.SourceFile) {
            node = node.parent;
        }
        return node;
    }
    static isDETSFile(node) {
        return !!node && NodeUtils.getSourceFileOfNode(node).fileName.endsWith(".d.ets" /* Extension.DETS */);
    }
    static isNewTargetNode(node) {
        if ((0, typescript_1.isMetaProperty)(node.parent) && node.parent.keywordToken === typescript_1.SyntaxKind.NewKeyword && node.escapedText === 'target') {
            return true;
        }
        return false;
    }
    static findSymbolOfIdentifier(checker, node) {
        let sym = checker.getSymbolAtLocation(node);
        if (!sym || (sym && sym.name !== 'default')) {
            return sym;
        }
        /* Handle default exports, eg. export default class Ability {};
           The expected symbol we want to find to obfuscate is named "Ability",
           but `getSymbolAtLocation` will return the symbol named "default", so we need to continue to search.
        */
        let localSyms = checker.getSymbolsInScope(node, sym.flags);
        for (let i = 0; i < localSyms.length; i++) {
            const localSym = localSyms[i];
            // `localSym` named "Ability" has property `exportSymbol` named "default" that we find by `getSymbolAtLocation`,
            // So the `localSym` is what we want to obfuscate.
            if (localSym && localSym.name === node.text && localSym.exportSymbol === sym) {
                sym = localSym;
                break;
            }
        }
        return sym;
    }
}
exports.NodeUtils = NodeUtils;
/**
 * When enabling property obfuscation, collect the properties of struct.
 * When enabling property obfuscation and the compilation output is a TS file,
 * collect the Identifier names in the initialization expressions of enum members.
 */
function collectReservedNameForObf(obfuscationConfig, shouldTransformToJs) {
    const disableObf = (obfuscationConfig === null || obfuscationConfig === void 0 ? void 0 : obfuscationConfig.options) === undefined || obfuscationConfig.options.disableObfuscation;
    const enablePropertyObf = obfuscationConfig === null || obfuscationConfig === void 0 ? void 0 : obfuscationConfig.options.enablePropertyObfuscation;
    // process.env.compiler === 'on': indicates that during the Webpack packaging process,
    // the code is executed here for the first time.
    // During the Webpack packaging process, this step will be executed twice,
    // but only the first time will it perform subsequent operations to prevent repetition.
    const shouldCollect = (process.env.compiler === 'on' || process.env.compileTool === 'rollup') &&
        !disableObf && enablePropertyObf;
    return (context) => {
        return (node) => {
            if (shouldCollect) {
                node = (0, typescript_1.visitEachChild)(node, collectReservedNames, context);
            }
            return node;
        };
        function collectReservedNames(node) {
            // collect properties of struct
            if ((0, typescript_1.isClassDeclaration)(node) && (0, OhsUtil_1.isViewPUBasedClass)(node)) {
                (0, OhsUtil_1.getViewPUClassProperties)(node);
            }
            // collect enum properties
            if (!shouldTransformToJs && (0, typescript_1.isEnumMember)(node) && node.initializer) {
                node.initializer.forEachChild(OhsUtil_1.visitEnumInitializer);
                return node;
            }
            return (0, typescript_1.visitEachChild)(node, collectReservedNames, context);
        }
    };
}
exports.collectReservedNameForObf = collectReservedNameForObf;
//# sourceMappingURL=NodeUtils.js.map