"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileUtils = exports.NORMALIZE = exports.BUNDLE = void 0;
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const type_1 = require("../common/type");
const fs_2 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
exports.BUNDLE = '@bundle:';
exports.NORMALIZE = '@normalized:';
class FileUtils {
    /**
     * Read file and return content
     *
     * @param filePath file path
     */
    static readFile(filePath) {
        if (!(0, fs_1.existsSync)(filePath)) {
            console.error(`File <${this.getFileName(filePath)}> is not found.`);
            return undefined;
        }
        return (0, fs_1.readFileSync)(filePath, 'utf-8');
    }
    /**
     * Read file and convert to json object.
     *
     * @param filePath file path
     */
    static readFileAsJson(filePath) {
        if (!(0, fs_1.existsSync)(filePath)) {
            console.error(`File <${this.getFileName(filePath)}> is not found.`);
            return undefined;
        }
        try {
            return (0, fs_extra_1.readJsonSync)(filePath);
        }
        catch (e) {
            console.error('json file read error: ' + filePath);
            return undefined;
        }
    }
    /**
     * Get File Name
     *
     * @param filePath file path
     */
    static getFileName(filePath) {
        if (!filePath) {
            return undefined;
        }
        const lastSepIndex = filePath.lastIndexOf('/');
        if (lastSepIndex >= 0) {
            return filePath.slice(lastSepIndex + 1);
        }
        return filePath.slice(filePath.lastIndexOf('\\') + 1);
    }
    /**
     * Get suffix of a file.
     *
     * @param filePath file path
     */
    static getFileExtension(filePath) {
        if (!filePath || !filePath.includes('.')) {
            return undefined;
        }
        // get file name
        let fileName = this.getFileName(filePath);
        if (!fileName.includes('.')) {
            return undefined;
        }
        return fileName.slice(fileName.lastIndexOf('.') + 1);
    }
    static writeFile(filePath, content) {
        (0, fs_1.writeFileSync)(filePath, content);
    }
    /**
     * get prefix of directory
     * @param dirPath
     */
    static getPrefix(dirPath) {
        if (!dirPath || (!dirPath.includes('/') && !dirPath.includes('\\'))) {
            return undefined;
        }
        const sepIndex = dirPath.lastIndexOf('/');
        if (sepIndex >= 0) {
            return dirPath.slice(0, sepIndex + 1);
        }
        return dirPath.slice(0, dirPath.lastIndexOf('\\') + 1);
    }
    static getPathWithoutPrefix(filePath, prefix) {
        if (!filePath.startsWith(prefix)) {
            return filePath;
        }
        return filePath.slice(prefix.length);
    }
    static splitFilePath(filePath) {
        if (!filePath.includes('\\') && !filePath.includes('\/')) {
            return [filePath];
        }
        const directories = filePath.split(/[\/\\]/);
        return directories;
    }
    /**
     * split the file path and collect the results into the reserved array
     */
    static collectPathReservedString(filePath, reservedArray) {
        const directories = this.splitFilePath(filePath);
        directories.forEach(reservedStr => {
            reservedArray.push(reservedStr);
        });
    }
    static isRelativePath(filePath) {
        for (const bebin of this.relativePathBegins) {
            if (filePath.startsWith(bebin)) {
                return true;
            }
        }
        return false;
    }
    static getFileSuffix(filePath) {
        for (let ext of type_1.fileExtensions) {
            if (filePath.endsWith(ext)) {
                const filePathWithoutSuffix = filePath.replace(new RegExp(`${ext}$`), '');
                return { path: filePathWithoutSuffix, ext: ext };
            }
        }
        return { path: filePath, ext: '' };
    }
    static isReadableFile(filePath) {
        try {
            fs_2.default.accessSync(filePath, fs_2.default.constants.R_OK);
        }
        catch (err) {
            return false;
        }
        return true;
    }
    static toUnixPath(data) {
        if (/^win/.test(require('os').platform())) {
            const fileTmps = data.split(path_1.default.sep);
            const newData = path_1.default.posix.join(...fileTmps);
            return newData;
        }
        return data;
    }
    static getAbsPathBaseConfigPath(configPath, relativePath) {
        const absPath = path_1.default.join(path_1.default.dirname(configPath), relativePath);
        return this.toUnixPath(absPath);
    }
    static deleteFile(filePath) {
        if (fs_2.default.existsSync(filePath)) {
            fs_2.default.unlinkSync(filePath);
        }
    }
}
exports.FileUtils = FileUtils;
FileUtils.relativePathBegins = ['./', '../', '.\\', '..\\'];
//# sourceMappingURL=FileUtils.js.map