"use strict";
/*
 * Copyright (c) 2023-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const ScopeAnalyzer_1 = require("../../utils/ScopeAnalyzer");
const NameCacheUtil_1 = require("../../utils/NameCacheUtil");
const TransformPlugin_1 = require("../TransformPlugin");
const NameFactory_1 = require("../../generator/NameFactory");
const TypeUtils_1 = require("../../utils/TypeUtils");
const TransformUtil_1 = require("../../utils/TransformUtil");
const NodeUtils_1 = require("../../utils/NodeUtils");
const ApiExtractor_1 = require("../../common/ApiExtractor");
const ArkObfuscator_1 = require("../../ArkObfuscator");
const PrinterUtils_1 = require("../../utils/PrinterUtils");
const OhsUtil_1 = require("../../utils/OhsUtil");
const CommonCollections_1 = require("../../utils/CommonCollections");
var secharmony;
(function (secharmony) {
    /**
     * Rename Identifiers, including:
     * 1. variable name
     * 2. function name
     * 3. label name
     * 4. class name/interface name/ label name
     * we need implement some features:
     * 1. rename identifiers
     * 2. store/restore name to/from nameCache file.
     * 3. do scope analysis for identifier obfuscations
     *
     * @param option
     */
    const createRenameIdentifierFactory = function (option) {
        var _a;
        const profile = option === null || option === void 0 ? void 0 : option.mNameObfuscation;
        const unobfuscationOption = option === null || option === void 0 ? void 0 : option.mUnobfuscationOption;
        if (!profile || !profile.mEnable) {
            return null;
        }
        let options = {};
        let generator = (0, NameFactory_1.getNameGenerator)(profile.mNameGeneratorType, options);
        const enableToplevel = (_a = option === null || option === void 0 ? void 0 : option.mNameObfuscation) === null || _a === void 0 ? void 0 : _a.mTopLevel;
        const exportObfuscation = option === null || option === void 0 ? void 0 : option.mExportObfuscation;
        let isInitializedReservedList = false;
        return renameIdentifierFactory;
        function renameIdentifierFactory(context) {
            initWhitelist();
            let mangledSymbolNames = new Map();
            let mangledPropertyParameterSymbolNames = new Map();
            let mangledLabelNames = new Map();
            let fileExportNames = undefined;
            let fileImportNames = undefined;
            ScopeAnalyzer_1.exportElementsWithoutSymbol.clear();
            ScopeAnalyzer_1.exportSymbolAliasMap.clear();
            let historyMangledNames = undefined;
            if (secharmony.historyNameCache && secharmony.historyNameCache.size > 0) {
                historyMangledNames = new Set(Array.from(secharmony.historyNameCache.values()));
            }
            let checker = undefined;
            let manager = (0, ScopeAnalyzer_1.createScopeManager)();
            return renameTransformer;
            /**
             * Transformer to rename identifiers
             *
             * @param node ast node of a file.
             */
            function renameTransformer(node) {
                if (secharmony.nameCache.size === 0) {
                    secharmony.nameCache.set(NameCacheUtil_1.IDENTIFIER_CACHE, new Map());
                    secharmony.nameCache.set(NameCacheUtil_1.MEM_METHOD_CACHE, new Map());
                }
                if (!(0, typescript_1.isSourceFile)(node) || ArkObfuscator_1.ArkObfuscator.isKeptCurrentFile) {
                    return node;
                }
                (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.CREATE_CHECKER, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                checker = TypeUtils_1.TypeUtils.createChecker(node);
                (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.CREATE_CHECKER, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.SCOPE_ANALYZE, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                manager.analyze(node, checker, exportObfuscation);
                (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.SCOPE_ANALYZE, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                let rootScope = manager.getRootScope();
                fileExportNames = rootScope.fileExportNames;
                fileImportNames = rootScope.fileImportNames;
                let renameProcessors = [renameLabelsInScope, renameNamesInScope];
                if (profile.mRenameProperties) {
                    renameProcessors.push(renamePropertyParametersInScope);
                }
                (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.CREATE_OBFUSCATED_NAMES, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                getMangledNamesInScope(rootScope, renameProcessors);
                (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.CREATE_OBFUSCATED_NAMES, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                rootScope = undefined;
                (0, PrinterUtils_1.startSingleFileEvent)(PrinterUtils_1.EventList.OBFUSCATE_NODES, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                let updatedNode = renameIdentifiers(node);
                // obfuscate property parameter declaration
                if (profile.mRenameProperties) {
                    updatedNode = visitPropertyParameter(updatedNode);
                }
                let parentNodes = (0, typescript_1.setParentRecursive)(updatedNode, true);
                (0, PrinterUtils_1.endSingleFileEvent)(PrinterUtils_1.EventList.OBFUSCATE_NODES, ArkObfuscator_1.performancePrinter.timeSumPrinter);
                return parentNodes;
            }
            /**
             * get mangled names of symbols stored in scopes.
             *
             * @param scope scope, such as global, module, function, block
             * @param processors processors to get mangled names
             */
            function getMangledNamesInScope(scope, processors) {
                for (const process of processors) {
                    process(scope);
                }
                let subScope = undefined;
                while (scope.children.length > 0) {
                    subScope = scope.children.pop();
                    getMangledNamesInScope(subScope, processors);
                    subScope = undefined;
                }
            }
            // process symbols in scope, exclude property name.
            function renameNamesInScope(scope) {
                if (isExcludeScope(scope)) {
                    return;
                }
                if (!exportObfuscation) {
                    scope.defs.forEach((def) => {
                        let parentScope = scope;
                        while (parentScope) {
                            if (parentScope.importNames && parentScope.importNames.has(def.name)) {
                                scope.defs.delete(def);
                                scope.mangledNames.add(def.name);
                            }
                            parentScope = parentScope.parent;
                        }
                    });
                }
                renames(scope, scope.defs, generator);
            }
            // process property parameters symbols in class scope
            function renamePropertyParametersInScope(scope) {
                if (!(0, ScopeAnalyzer_1.isClassScope)(scope)) {
                    return;
                }
                renamePropertyParameters(scope, scope.defs, generator);
            }
            function renames(scope, defs, generator) {
                defs.forEach((def) => {
                    const original = def.name;
                    let mangled = original;
                    const path = (0, ScopeAnalyzer_1.getNameWithScopeLoc)(scope, original);
                    // No allow to rename reserved names.
                    if (!Reflect.has(def, 'obfuscateAsProperty') &&
                        (0, TransformUtil_1.isInLocalWhitelist)(original, CommonCollections_1.UnobfuscationCollections.unobfuscatedNamesMap, path) ||
                        (!exportObfuscation && scope.exportNames.has(def.name)) ||
                        isSkippedGlobal(enableToplevel, scope)) {
                        scope.mangledNames.add(mangled);
                        mangledSymbolNames.set(def, { mangledName: mangled, originalNameWithScope: path });
                        return;
                    }
                    if (mangledSymbolNames.has(def)) {
                        return;
                    }
                    const historyName = secharmony.historyNameCache === null || secharmony.historyNameCache === void 0 ? void 0 : secharmony.historyNameCache.get(path);
                    if (historyName) {
                        (0, TransformUtil_1.recordHistoryUnobfuscatedNames)(path); // For incremental build
                        mangled = historyName;
                    }
                    else if (Reflect.has(def, 'obfuscateAsProperty')) {
                        // obfuscate toplevel, export
                        mangled = getPropertyMangledName(original, path);
                    }
                    else {
                        // obfuscate local variable
                        mangled = getMangled(scope, generator);
                    }
                    // add new names to name cache
                    let identifierCache = secharmony.nameCache === null || secharmony.nameCache === void 0 ? void 0 : secharmony.nameCache.get(NameCacheUtil_1.IDENTIFIER_CACHE);
                    identifierCache.set(path, mangled);
                    let symbolInfo = {
                        mangledName: mangled,
                        originalNameWithScope: path
                    };
                    scope.mangledNames.add(mangled);
                    mangledSymbolNames.set(def, symbolInfo);
                });
            }
            function renamePropertyParameters(scope, defs, generator) {
                defs.forEach((def) => {
                    //only rename property parameters
                    if (!def.valueDeclaration || !(0, typescript_1.isParameter)(def.valueDeclaration)) {
                        return;
                    }
                    const originalName = def.name;
                    const path = (0, ScopeAnalyzer_1.getNameWithScopeLoc)(scope, originalName);
                    let mangledName;
                    if ((0, TransformUtil_1.isInPropertyWhitelist)(originalName, CommonCollections_1.UnobfuscationCollections.unobfuscatedPropMap)) {
                        mangledName = originalName;
                    }
                    else {
                        mangledName = getMangledPropertyParameters(scope, generator, originalName);
                    }
                    scope.mangledNames.add(mangledName);
                    let symbolInfo = {
                        mangledName: mangledName,
                        originalNameWithScope: path
                    };
                    mangledPropertyParameterSymbolNames.set(def.valueDeclaration, symbolInfo);
                });
            }
            function getMangledPropertyParameters(scope, localGenerator, originalName) {
                var _a;
                const historyName = (_a = CommonCollections_1.PropCollections.historyMangledTable) === null || _a === void 0 ? void 0 : _a.get(originalName);
                let mangledName = historyName ? historyName : CommonCollections_1.PropCollections.globalMangledTable.get(originalName);
                while (!mangledName) {
                    let tmpName = localGenerator.getName();
                    if ((0, TransformUtil_1.isReservedLocalVariable)(tmpName)) {
                        continue;
                    }
                    if ((0, TransformUtil_1.isReservedProperty)(tmpName) || tmpName === originalName) {
                        continue;
                    }
                    if (historyMangledNames && historyMangledNames.has(tmpName)) {
                        continue;
                    }
                    if (CommonCollections_1.PropCollections.newlyOccupiedMangledProps.has(tmpName) || CommonCollections_1.PropCollections.mangledPropsInNameCache.has(tmpName)) {
                        continue;
                    }
                    if (searchMangledInParent(scope, tmpName)) {
                        continue;
                    }
                    mangledName = tmpName;
                }
                CommonCollections_1.PropCollections.globalMangledTable.set(originalName, mangledName);
                CommonCollections_1.PropCollections.newlyOccupiedMangledProps.add(mangledName);
                return mangledName;
            }
            function getPropertyMangledName(original, nameWithScope) {
                var _a, _b, _c;
                if ((0, TransformUtil_1.isInTopLevelWhitelist)(original, CommonCollections_1.UnobfuscationCollections.unobfuscatedNamesMap, nameWithScope)) {
                    return original;
                }
                const historyName = (_a = CommonCollections_1.PropCollections.historyMangledTable) === null || _a === void 0 ? void 0 : _a.get(original);
                let mangledName = historyName ? historyName : CommonCollections_1.PropCollections.globalMangledTable.get(original);
                while (!mangledName) {
                    let tmpName = generator.getName();
                    if ((0, TransformUtil_1.isReservedTopLevel)(tmpName) ||
                        tmpName === original) {
                        continue;
                    }
                    /**
                     * In case b is obfuscated as a when only enable toplevel obfuscation:
                     * let b = 1;
                     * export let a = 1;
                     */
                    if (ArkObfuscator_1.cleanFileMangledNames && fileExportNames && fileExportNames.has(tmpName)) {
                        continue;
                    }
                    /**
                     * In case b is obfuscated as a when only enable toplevel obfuscation:
                     * import {a} from 'filePath';
                     * let b = 1;
                     */
                    if (ArkObfuscator_1.cleanFileMangledNames && fileImportNames.has(tmpName)) {
                        continue;
                    }
                    /**
                     * In case a newly added variable get an obfuscated name that is already in history namecache
                     */
                    if (historyMangledNames && historyMangledNames.has(tmpName)) {
                        continue;
                    }
                    if (CommonCollections_1.PropCollections.newlyOccupiedMangledProps.has(tmpName) || CommonCollections_1.PropCollections.mangledPropsInNameCache.has(tmpName)) {
                        continue;
                    }
                    if ((_b = ApiExtractor_1.ApiExtractor.mConstructorPropertySet) === null || _b === void 0 ? void 0 : _b.has(tmpName)) {
                        continue;
                    }
                    if ((_c = ApiExtractor_1.ApiExtractor.mEnumMemberSet) === null || _c === void 0 ? void 0 : _c.has(tmpName)) {
                        continue;
                    }
                    mangledName = tmpName;
                }
                CommonCollections_1.PropCollections.globalMangledTable.set(original, mangledName);
                CommonCollections_1.PropCollections.newlyOccupiedMangledProps.add(mangledName);
                return mangledName;
            }
            function isExcludeScope(scope) {
                if ((0, ScopeAnalyzer_1.isClassScope)(scope)) {
                    return true;
                }
                if ((0, ScopeAnalyzer_1.isInterfaceScope)(scope)) {
                    return true;
                }
                if ((0, ScopeAnalyzer_1.isEnumScope)(scope)) {
                    return true;
                }
                return (0, ScopeAnalyzer_1.isObjectLiteralScope)(scope);
            }
            function searchMangledInParent(scope, name) {
                let found = false;
                let parentScope = scope;
                while (parentScope) {
                    if (parentScope.mangledNames.has(name)) {
                        found = true;
                        break;
                    }
                    parentScope = parentScope.parent;
                }
                return found;
            }
            function getMangled(scope, localGenerator) {
                var _a, _b;
                let mangled = '';
                do {
                    mangled = localGenerator.getName();
                    // if it is a globally reserved name, it needs to be regenerated
                    if ((0, TransformUtil_1.isReservedLocalVariable)(mangled)) {
                        mangled = '';
                        continue;
                    }
                    if (fileExportNames && fileExportNames.has(mangled)) {
                        mangled = '';
                        continue;
                    }
                    if (historyMangledNames && historyMangledNames.has(mangled)) {
                        mangled = '';
                        continue;
                    }
                    if (searchMangledInParent(scope, mangled)) {
                        mangled = '';
                        continue;
                    }
                    if ((_a = ApiExtractor_1.ApiExtractor.mConstructorPropertySet) === null || _a === void 0 ? void 0 : _a.has(mangled)) {
                        mangled = '';
                    }
                    if ((_b = ApiExtractor_1.ApiExtractor.mEnumMemberSet) === null || _b === void 0 ? void 0 : _b.has(mangled)) {
                        mangled = '';
                    }
                } while (mangled === '');
                return mangled;
            }
            // process labels in scope, the label can't rename as the name of top labels.
            function renameLabelsInScope(scope) {
                const labels = scope.labels;
                if (labels.length > 0) {
                    let upperMangledLabels = getUpperMangledLabelNames(labels[0]);
                    for (const label of labels) {
                        let mangledLabel = getMangledLabel(label, upperMangledLabels);
                        mangledLabelNames.set(label, mangledLabel);
                    }
                }
            }
            function getMangledLabel(label, mangledLabels) {
                let mangledLabel = '';
                do {
                    mangledLabel = generator.getName();
                    if (mangledLabel === label.name) {
                        mangledLabel = '';
                    }
                    if (mangledLabels.includes(mangledLabel)) {
                        mangledLabel = '';
                    }
                } while (mangledLabel === '');
                return mangledLabel;
            }
            function getUpperMangledLabelNames(label) {
                const results = [];
                let parent = label.parent;
                while (parent) {
                    let mangledLabelName = mangledLabelNames.get(parent);
                    if (mangledLabelName) {
                        results.push(mangledLabelName);
                    }
                    parent = parent.parent;
                }
                return results;
            }
            function isFunctionLike(node) {
                switch (node.kind) {
                    case typescript_1.SyntaxKind.FunctionDeclaration:
                    case typescript_1.SyntaxKind.MethodDeclaration:
                    case typescript_1.SyntaxKind.GetAccessor:
                    case typescript_1.SyntaxKind.SetAccessor:
                    case typescript_1.SyntaxKind.Constructor:
                    case typescript_1.SyntaxKind.FunctionExpression:
                    case typescript_1.SyntaxKind.ArrowFunction:
                        return true;
                }
                return false;
            }
            function nodeHasFunctionLikeChild(node) {
                let hasFunctionLikeChild = false;
                let childVisitor = (child) => {
                    if (!hasFunctionLikeChild && child && isFunctionLike(child)) {
                        hasFunctionLikeChild = true;
                    }
                    return child;
                };
                (0, typescript_1.visitEachChild)(node, childVisitor, context);
                return hasFunctionLikeChild;
            }
            /**
             * visit each node to change identifier name to mangled name
             *  - calculate shadow name index to find shadow node
             * @param node
             */
            function renameIdentifiers(node) {
                let needHandlePositionInfo = isFunctionLike(node) || nodeHasFunctionLikeChild(node);
                if (needHandlePositionInfo) {
                    // Obtain line info for nameCache.
                    handlePositionInfo(node);
                }
                if (!(0, typescript_1.isIdentifier)(node) || !node.parent) {
                    return (0, typescript_1.visitEachChild)(node, renameIdentifiers, context);
                }
                if ((0, typescript_1.isLabeledStatement)(node.parent) || (0, typescript_1.isBreakOrContinueStatement)(node.parent)) {
                    return updateLabelNode(node);
                }
                return updateNameNode(node);
            }
            /**
             * visit each property parameter to change identifier name to mangled name
             *  - calculate shadow name index to find shadow node
             * @param node
             */
            function visitPropertyParameter(node) {
                if ((0, typescript_1.isConstructorDeclaration)(node)) {
                    return visitPropertyParameterInConstructor(node);
                }
                return (0, typescript_1.visitEachChild)(node, visitPropertyParameter, context);
                function visitPropertyParameterInConstructor(node) {
                    if (!(0, typescript_1.isIdentifier)(node) || !node.parent) {
                        return (0, typescript_1.visitEachChild)(node, visitPropertyParameterInConstructor, context);
                    }
                    // we do not obfuscate the identifier of property access expression, like "a" in "this.a",
                    // since it will be obfuscated in renamePropertiesTransformer
                    if (NodeUtils_1.NodeUtils.isPropertyNode(node)) {
                        return node;
                    }
                    return updatePropertyParameterNameNode(node);
                }
            }
            function handlePositionInfo(node) {
                var _a;
                const sourceFile = NodeUtils_1.NodeUtils.getSourceFileOfNode(node);
                if (node && node.pos < 0 && node.end < 0) {
                    // Node must have a real position for following operations.
                    // Adapting to the situation that the node does not have a real postion.
                    return;
                }
                const startPosition = sourceFile.getLineAndCharacterOfPosition(node.getStart());
                const endPosition = sourceFile.getLineAndCharacterOfPosition(node.getEnd());
                // 1: The line number in sourceFile starts from 0 while in IDE starts from 1.
                const startLine = startPosition.line + 1;
                const startCharacter = startPosition.character + 1; // 1: Same as above.
                const endLine = endPosition.line + 1; // 1: Same as above.
                const endCharacter = endPosition.character + 1; // 1: Same as above.
                const lineAndColum = ':' + startLine + ':' + startCharacter + ':' + endLine + ':' + endCharacter;
                let isProperty = (0, typescript_1.isMethodDeclaration)(node) || (0, typescript_1.isGetAccessor)(node) ||
                    (0, typescript_1.isSetAccessor)(node) || ((0, typescript_1.isConstructorDeclaration)(node) &&
                    !((0, typescript_1.isClassDeclaration)(node.parent) && (0, OhsUtil_1.isViewPUBasedClass)(node.parent)));
                // Arrow functions are anoymous, only function expressions are considered.
                let isPropertyParent = (0, typescript_1.isFunctionExpression)(node) &&
                    ((0, typescript_1.isPropertyDeclaration)(node.parent) || (0, typescript_1.isPropertyAssignment)(node.parent));
                let isMemberMethod = isProperty || isPropertyParent;
                if (isMemberMethod) {
                    writeMemberMethodCache(node, lineAndColum);
                    return;
                }
                let name = Reflect.get(node, 'name');
                if ((name === null || name === void 0 ? void 0 : name.kind) === typescript_1.SyntaxKind.Identifier) {
                    secharmony.identifierLineMap.set(name, lineAndColum);
                }
                else if (((0, typescript_1.isFunctionExpression)(node) || (0, typescript_1.isArrowFunction)(node)) && (0, typescript_1.isVariableDeclaration)(node.parent) &&
                    ((_a = node.parent.name) === null || _a === void 0 ? void 0 : _a.kind) === typescript_1.SyntaxKind.Identifier) {
                    // The node is anonymous, and we need to find its parent node.
                    // e.g.: let foo = function() {};
                    secharmony.identifierLineMap.set(node.parent.name, lineAndColum);
                }
            }
            function writeMemberMethodCache(node, lineAndColum) {
                var _a;
                let gotNode;
                if (node.kind === typescript_1.SyntaxKind.Constructor) {
                    gotNode = node.parent;
                }
                else if ((node.kind === typescript_1.SyntaxKind.FunctionExpression &&
                    ((0, typescript_1.isPropertyDeclaration)(node.parent) || (0, typescript_1.isPropertyAssignment)(node.parent)))) {
                    gotNode = (_a = node.parent.initializer) !== null && _a !== void 0 ? _a : node.parent;
                }
                else {
                    gotNode = node;
                }
                let isIdentifierNode = gotNode.name && ((0, typescript_1.isIdentifier)(gotNode.name) || (0, typescript_1.isPrivateIdentifier)(gotNode.name));
                let valueName = '';
                if (isIdentifierNode) {
                    // The original method for retrieving method names used gotNode.name.escapedText. This approach limited the collection
                    // of method records in MemberMethodCache to cases where gotNode.name was an Identifier or PrivateIdentifier.
                    // To address the issue where method names starting with double underscores were transformed to start with triple underscores,
                    // we changed the retrieval method to use gotNode.name.text instead of escapedText. However, this change introduced the possibility
                    // of collecting method records when gotNode.name is a NumericLiteral or StringLiteral, which is not desired.
                    // To avoid altering the collection specifications of MemberMethodCache, we restricted the collection scenarios
                    // to match the original cases where only identifiers and private identifiers are collected.
                    valueName = gotNode.name.text;
                }
                if (valueName === '') {
                    return;
                }
                let originalName = valueName;
                let keyName = originalName + lineAndColum;
                if (node.kind === typescript_1.SyntaxKind.Constructor && secharmony.classMangledName.has(gotNode.name)) {
                    valueName = secharmony.classMangledName.get(gotNode.name);
                    secharmony.classInfoInMemberMethodCache.add(keyName);
                }
                let memberMethodCache = secharmony.nameCache === null || secharmony.nameCache === void 0 ? void 0 : secharmony.nameCache.get(NameCacheUtil_1.MEM_METHOD_CACHE);
                if (memberMethodCache) {
                    memberMethodCache.set(keyName, valueName);
                }
            }
            function updateNameNode(node) {
                var _a;
                // skip property in property access expression
                if (NodeUtils_1.NodeUtils.isPropertyAccessNode(node)) {
                    return node;
                }
                if (NodeUtils_1.NodeUtils.isNewTargetNode(node)) {
                    return node;
                }
                let sym = NodeUtils_1.NodeUtils.findSymbolOfIdentifier(checker, node);
                let mangledPropertyNameOfNoSymbolImportExport = '';
                if (!sym) {
                    if (shouldObfuscateNodeWithoutSymbol(node)) {
                        mangledPropertyNameOfNoSymbolImportExport = mangleNoSymbolImportExportPropertyName(node.text);
                    }
                    else {
                        return node;
                    }
                }
                if (ScopeAnalyzer_1.exportSymbolAliasMap.has(sym)) {
                    sym = ScopeAnalyzer_1.exportSymbolAliasMap.get(sym);
                }
                // Add new names to name cache
                const symbolInfo = mangledSymbolNames.get(sym);
                const identifierCache = secharmony.nameCache === null || secharmony.nameCache === void 0 ? void 0 : secharmony.nameCache.get(NameCacheUtil_1.IDENTIFIER_CACHE);
                const lineAndColumn = secharmony.identifierLineMap === null || secharmony.identifierLineMap === void 0 ? void 0 : secharmony.identifierLineMap.get(node);
                // We only save the line info of FunctionLike.
                const isFunction = sym ? Reflect.has(sym, 'isFunction') : false;
                if (isFunction && symbolInfo && lineAndColumn) {
                    const originalName = symbolInfo.originalNameWithScope;
                    const pathWithLine = originalName + lineAndColumn;
                    identifierCache.set(pathWithLine, symbolInfo.mangledName);
                    identifierCache.delete(originalName);
                }
                let mangledName = (_a = mangledSymbolNames.get(sym)) === null || _a === void 0 ? void 0 : _a.mangledName;
                if ((node === null || node === void 0 ? void 0 : node.parent.kind) === typescript_1.SyntaxKind.ClassDeclaration) {
                    secharmony.classMangledName.set(node, mangledName);
                }
                if (!mangledName && mangledPropertyNameOfNoSymbolImportExport !== '') {
                    mangledName = mangledPropertyNameOfNoSymbolImportExport;
                }
                if (!mangledName || mangledName === (sym === null || sym === void 0 ? void 0 : sym.name)) {
                    return node;
                }
                return typescript_1.factory.createIdentifier(mangledName);
            }
            function updatePropertyParameterNameNode(node) {
                var _a, _b;
                let sym = NodeUtils_1.NodeUtils.findSymbolOfIdentifier(checker, node);
                if (!sym || ((_a = sym.valueDeclaration) === null || _a === void 0 ? void 0 : _a.kind) !== typescript_1.SyntaxKind.Parameter) {
                    return node;
                }
                let mangledName = (_b = mangledPropertyParameterSymbolNames.get(sym.valueDeclaration)) === null || _b === void 0 ? void 0 : _b.mangledName;
                if (!mangledName || mangledName === (sym === null || sym === void 0 ? void 0 : sym.name)) {
                    return node;
                }
                return typescript_1.factory.createIdentifier(mangledName);
            }
            function updateLabelNode(node) {
                let label;
                let labelName = '';
                mangledLabelNames.forEach((value, key) => {
                    if (key.refs.includes(node)) {
                        label = key;
                        labelName = value;
                    }
                });
                return label ? typescript_1.factory.createIdentifier(labelName) : node;
            }
            /**
             * import {A as B} from 'modulename';
             * import {C as D} from 'modulename';
             * above Aã€C have no symbol, so deal with them specially.
             */
            function mangleNoSymbolImportExportPropertyName(original) {
                const path = '#' + original;
                const historyName = secharmony.historyNameCache === null || secharmony.historyNameCache === void 0 ? void 0 : secharmony.historyNameCache.get(path);
                let mangled = historyName !== null && historyName !== void 0 ? historyName : getPropertyMangledName(original, path);
                if (secharmony.nameCache && secharmony.nameCache.get(NameCacheUtil_1.IDENTIFIER_CACHE)) {
                    secharmony.nameCache.get(NameCacheUtil_1.IDENTIFIER_CACHE).set(path, mangled);
                }
                return mangled;
            }
            function trySearchImportExportSpecifier(node) {
                while (node.parent) {
                    node = node.parent;
                    if (((0, typescript_1.isImportSpecifier)(node) || (0, typescript_1.isExportSpecifier)(node)) && node.propertyName && (0, typescript_1.isIdentifier)(node.propertyName)) {
                        return true;
                    }
                }
                return false;
            }
            function shouldObfuscateNodeWithoutSymbol(node) {
                if (exportObfuscation && ScopeAnalyzer_1.exportElementsWithoutSymbol.has(node) && trySearchImportExportSpecifier(node)) {
                    let isGlobalNode = ScopeAnalyzer_1.exportElementsWithoutSymbol.get(node);
                    if ((isGlobalNode && enableToplevel) || !isGlobalNode) {
                        return true;
                    }
                }
                return false;
            }
        }
        function initWhitelist() {
            var _a, _b, _c, _d, _e;
            if (isInitializedReservedList) {
                return;
            }
            if (profile === null || profile === void 0 ? void 0 : profile.mRenameProperties) {
                CommonCollections_1.PropCollections.enablePropertyObfuscation = true;
                const tmpReservedProps = (_a = profile === null || profile === void 0 ? void 0 : profile.mReservedProperties) !== null && _a !== void 0 ? _a : [];
                tmpReservedProps.forEach(item => {
                    CommonCollections_1.PropCollections.reservedProperties.add(item);
                });
                CommonCollections_1.PropCollections.mangledPropsInNameCache = new Set((_b = CommonCollections_1.PropCollections.historyMangledTable) === null || _b === void 0 ? void 0 : _b.values());
                if (profile === null || profile === void 0 ? void 0 : profile.mUniversalReservedProperties) {
                    CommonCollections_1.PropCollections.universalReservedProperties = [...profile.mUniversalReservedProperties];
                }
                CommonCollections_1.UnobfuscationCollections.reservedLangForTopLevel.forEach(element => {
                    CommonCollections_1.UnobfuscationCollections.reservedLangForProperty.add(element);
                });
                CommonCollections_1.UnobfuscationCollections.reservedExportName.forEach(element => {
                    CommonCollections_1.UnobfuscationCollections.reservedExportNameAndProp.add(element);
                });
                CommonCollections_1.UnobfuscationCollections.reservedSdkApiForGlobal.forEach(element => {
                    CommonCollections_1.UnobfuscationCollections.reservedSdkApiForProp.add(element);
                });
            }
            CommonCollections_1.LocalVariableCollections.reservedConfig = new Set((_c = profile === null || profile === void 0 ? void 0 : profile.mReservedNames) !== null && _c !== void 0 ? _c : []);
            CommonCollections_1.LocalVariableCollections.reservedStruct = new Set();
            (_d = profile === null || profile === void 0 ? void 0 : profile.mReservedToplevelNames) === null || _d === void 0 ? void 0 : _d.forEach(item => CommonCollections_1.PropCollections.reservedProperties.add(item));
            (_e = profile === null || profile === void 0 ? void 0 : profile.mUniversalReservedToplevelNames) === null || _e === void 0 ? void 0 : _e.forEach(item => CommonCollections_1.PropCollections.universalReservedProperties.push(item));
            isInitializedReservedList = true;
        }
    };
    function isSkippedGlobal(enableTopLevel, scope) {
        return !enableTopLevel && (0, ScopeAnalyzer_1.isGlobalScope)(scope);
    }
    secharmony.transformerPlugin = {
        'name': 'renameIdentifierPlugin',
        'order': TransformPlugin_1.TransformerOrder.RENAME_IDENTIFIER_TRANSFORMER,
        'createTransformerFactory': createRenameIdentifierFactory
    };
    secharmony.nameCache = new Map();
    secharmony.historyNameCache = undefined;
    secharmony.historyUnobfuscatedNamesMap = undefined;
    secharmony.identifierLineMap = new Map();
    secharmony.classMangledName = new Map();
    // Record the original class name and line number range to distinguish between class names and member method names.
    secharmony.classInfoInMemberMethodCache = new Set();
    function clearCaches() {
        secharmony.nameCache.clear();
        secharmony.historyNameCache = undefined;
        secharmony.historyUnobfuscatedNamesMap = undefined;
        secharmony.identifierLineMap.clear();
        secharmony.classMangledName.clear();
        secharmony.classInfoInMemberMethodCache.clear();
        CommonCollections_1.UnobfuscationCollections.unobfuscatedNamesMap.clear();
    }
    secharmony.clearCaches = clearCaches;
})(secharmony || (secharmony = {}));
module.exports = secharmony;
//# sourceMappingURL=RenameIdentifierTransformer.js.map