"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeUtils = void 0;
const typescript_1 = require("typescript");
const FileUtils_1 = require("./FileUtils");
const ArkObfuscator_1 = require("../ArkObfuscator");
const PrinterUtils_1 = require("./PrinterUtils");
const ScopeAnalyzer_1 = require("./ScopeAnalyzer");
class TypeUtils {
    /**
     * Create .d.ets, .d.ts, .ts ast from .d.ets, .d.ts, .ts content.
     * Create .ts ast from .ets, .js content
     * @param {string} sourceFilePath
     * @param {string} content - The content in sourceFilePath
     */
    static createObfSourceFile(sourceFilePath, content) {
        const pathOrExtension = FileUtils_1.FileUtils.getFileSuffix(sourceFilePath);
        const fileSuffix = pathOrExtension.ext;
        if (fileSuffix === ".js" /* Extension.JS */) {
            sourceFilePath = pathOrExtension.path + ".ts" /* Extension.TS */;
        }
        return (0, typescript_1.createSourceFile)(sourceFilePath, content, typescript_1.ScriptTarget.ES2015, true);
    }
    static tsToJs(ast) {
        const pathOrExtension = FileUtils_1.FileUtils.getFileSuffix(ast.fileName);
        const fileSuffix = ".js" /* Extension.JS */;
        const targetName = pathOrExtension.path + fileSuffix;
        ast.fileName = targetName;
    }
    static createChecker(ast) {
        const host = (0, typescript_1.createCompilerHost)({});
        const customHost = {
            getSourceFile(name, languageVersion) {
                if (name === ast.fileName) {
                    return ast;
                }
                else {
                    return host.getSourceFile(name, languageVersion);
                }
            },
            // optional
            getDefaultLibLocation: () => '',
            getDefaultLibFileName: () => '',
            writeFile: (filename, data) => {
            },
            getCurrentDirectory: () => '',
            useCaseSensitiveFileNames: host.useCaseSensitiveFileNames,
            getCanonicalFileName: host.getCanonicalFileName,
            getNewLine: host.getNewLine,
            fileExists: () => true,
            readFile: (name) => {
                return name === ast.fileName ? ast.text : host.readFile(name);
            },
            // must, read program.ts => createCompilerHost
            directoryExists: undefined,
            getEnvironmentVariable: undefined,
            getDirectories: undefined,
        };
        let option = {};
        if (ast.fileName.endsWith('.js')) {
            option.allowJs = true;
        }
        (0, PrinterUtils_1.startSingleFileEvent)(ArkObfuscator_1.EventList.CREATE_PROGRAM, ArkObfuscator_1.performancePrinter.timeSumPrinter);
        let program = (0, typescript_1.createProgram)([ast.fileName], option, customHost);
        (0, PrinterUtils_1.endSingleFileEvent)(ArkObfuscator_1.EventList.CREATE_PROGRAM, ArkObfuscator_1.performancePrinter.timeSumPrinter);
        (0, PrinterUtils_1.startSingleFileEvent)(ArkObfuscator_1.EventList.GET_CHECKER, ArkObfuscator_1.performancePrinter.timeSumPrinter);
        let typeChecker = program.getTypeChecker();
        (0, PrinterUtils_1.endSingleFileEvent)(ArkObfuscator_1.EventList.GET_CHECKER, ArkObfuscator_1.performancePrinter.timeSumPrinter);
        return typeChecker;
    }
    /**
     * Retrieves the symbol associated with the declaration site of the given symbol.
     *
     * This method resolves the symbol to its declaration site to ensure consistency
     * in obfuscated naming. Obfuscation names are bound to the symbol at the declaration
     * site. If the symbol at the declaration site differs from the symbol at the usage
     * site, discrepancies in obfuscated names may occur. By using this method, the
     * obfuscation name can be consistently retrieved from the declaration site symbol,
     * ensuring uniformity between the declaration and usage sites.
     */
    static getOriginalSymbol(symbol, checker) {
        if (!(symbol.getFlags() & typescript_1.SymbolFlags.Alias)) {
            return symbol;
        }
        if (ScopeAnalyzer_1.exportSymbolAliasMap.has(symbol)) {
            return ScopeAnalyzer_1.exportSymbolAliasMap.get(symbol);
        }
        // This method helps determine if the original symbol obtained for a given symbol is valid and usable.
        // Sometimes the original symbol's name may differ from the current symbol's name due to aliasing.
        // For example:
        // `let A = 1; export { A as B };`
        // The `originalSymbol` for `B` refers to the symbol for `A`, but the names are different.
        // However, for obfuscation purposes, we want to ensure that the symbol used in the declaration (i.e., `A` in this case)
        // aligns with the current symbol (i.e., `B`), because this allows us to apply the declaration's obfuscation name to `B`.
        // If the names don't match, we should avoid applying the declaration's obfuscation name to the current symbol.
        const isValidOriginalSymbol = (originalSymbol) => originalSymbol !== undefined && originalSymbol.name === symbol.name;
        const originalSymbol = checker.getAliasedSymbol(symbol);
        if (isValidOriginalSymbol(originalSymbol)) {
            return originalSymbol;
        }
        const immediateSymbol = checker.getImmediateAliasedSymbol(symbol);
        if (isValidOriginalSymbol(immediateSymbol)) {
            return immediateSymbol;
        }
        return symbol;
    }
}
exports.TypeUtils = TypeUtils;
//# sourceMappingURL=TypeUtils.js.map