"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getViewPUClassProperties = exports.visitEnumInitializer = exports.addExportPropertyName = exports.getObjectExportNames = exports.getStructProperties = exports.getObjectProperties = exports.getEnumProperties = exports.getClassProperties = exports.isParameterPropertyModifier = exports.getInterfaceProperties = exports.getTypeAliasProperties = exports.getIndexedAccessTypeProperties = exports.getElementAccessExpressionProperties = exports.collectPropertyNamesAndStrings = exports.isViewPUBasedClass = exports.exportOriginalNameSet = exports.enumPropsSet = exports.structPropsSet = exports.stringPropsSet = void 0;
const typescript_1 = require("typescript");
const ApiExtractor_1 = require("../common/ApiExtractor");
const CommonCollections_1 = require("./CommonCollections");
const NodeUtils_1 = require("./NodeUtils");
exports.stringPropsSet = new Set();
/**
 * The struct properties may be initialized in other files, but the properties in the struct definition are not obfuscated.
 * So the whitelist of struct properties is collected during the project scanning process.
 */
exports.structPropsSet = new Set();
/**
 * Add enum elements into whitelist when compiling har module to avoid obfuscating enum elements
 * since enum elements in js file cannot be obfuscated properly.
 */
exports.enumPropsSet = new Set();
/**
 * Collect the original name of export elements to ensure we can collect their properties
 */
exports.exportOriginalNameSet = new Set();
function containViewPU(heritageClauses) {
    if (!heritageClauses) {
        return false;
    }
    let hasViewPU = false;
    heritageClauses.forEach((heritageClause) => {
        if (!heritageClause || !heritageClause.types) {
            return;
        }
        const types = heritageClause.types;
        types.forEach((typeExpression) => {
            if (!typeExpression || !typeExpression.expression) {
                return;
            }
            const expression = typeExpression.expression;
            if ((0, typescript_1.isIdentifier)(expression) && expression.text === 'ViewPU') {
                hasViewPU = true;
            }
        });
    });
    return hasViewPU;
}
/**
 * used to ignore user defined ui component class property name
 * @param classNode
 */
function isViewPUBasedClass(classNode) {
    if (!classNode) {
        return false;
    }
    if (!(0, typescript_1.isClassDeclaration)(classNode)) {
        return false;
    }
    const heritageClause = classNode.heritageClauses;
    return containViewPU(heritageClause);
}
exports.isViewPUBasedClass = isViewPUBasedClass;
function collectPropertyNamesAndStrings(memberName, propertySet) {
    if ((0, typescript_1.isIdentifier)(memberName)) {
        propertySet.add(memberName.text);
    }
    if ((0, typescript_1.isStringLiteral)(memberName)) {
        propertySet.add(memberName.text);
        exports.stringPropsSet.add(memberName.text);
    }
    if ((0, typescript_1.isComputedPropertyName)(memberName) && (0, typescript_1.isStringLiteral)(memberName.expression)) {
        propertySet.add(memberName.expression.text);
        exports.stringPropsSet.add(memberName.expression.text);
    }
}
exports.collectPropertyNamesAndStrings = collectPropertyNamesAndStrings;
function getElementAccessExpressionProperties(elementAccessExpressionNode) {
    if (!elementAccessExpressionNode || !elementAccessExpressionNode.argumentExpression) {
        return;
    }
    if ((0, typescript_1.isStringLiteral)(elementAccessExpressionNode.argumentExpression)) {
        exports.stringPropsSet.add(elementAccessExpressionNode.argumentExpression.text);
    }
}
exports.getElementAccessExpressionProperties = getElementAccessExpressionProperties;
function addStringLiteralToSet(node, stringSet) {
    if (NodeUtils_1.NodeUtils.isStringLiteralTypeNode(node)) {
        const indexType = node;
        const stringLiteral = indexType.literal;
        stringSet.add(stringLiteral.text);
    }
}
/**
 * Process the IndexedAccessTypeNode and add the stringLiteral in its indexType to the stringPropsSet
 * @param indexedAccessTypeNode
 */
function getIndexedAccessTypeProperties(indexedAccessTypeNode) {
    if (!indexedAccessTypeNode || !indexedAccessTypeNode.indexType) {
        return;
    }
    addStringLiteralToSet(indexedAccessTypeNode.indexType, exports.stringPropsSet);
    if ((0, typescript_1.isUnionTypeNode)(indexedAccessTypeNode.indexType)) {
        indexedAccessTypeNode.indexType.types.forEach((elemType) => {
            if (!elemType) {
                return;
            }
            addStringLiteralToSet(elemType, exports.stringPropsSet);
        });
    }
}
exports.getIndexedAccessTypeProperties = getIndexedAccessTypeProperties;
function getTypeAliasProperties(typeAliasNode, propertySet) {
    if (!typeAliasNode || !typeAliasNode.type || !(0, typescript_1.isTypeLiteralNode)(typeAliasNode.type)) {
        return;
    }
    typeAliasNode.type.members.forEach((member) => {
        if (!member || !member.name) {
            return;
        }
        let memberName = member.name;
        collectPropertyNamesAndStrings(memberName, propertySet);
    });
}
exports.getTypeAliasProperties = getTypeAliasProperties;
/**
 * export interface interfaceName {
 *  a1: number;
 *  "a2": number;
 *  ["a3"]: number;
 * }
 */
function getInterfaceProperties(interfaceNode, propertySet) {
    if (!interfaceNode || !interfaceNode.members) {
        return;
    }
    interfaceNode.members.forEach((member) => {
        if (!member || !member.name) {
            return;
        }
        let memberName = member.name;
        collectPropertyNamesAndStrings(memberName, propertySet);
    });
}
exports.getInterfaceProperties = getInterfaceProperties;
function isParameterPropertyModifier(modifier) {
    if (modifier.kind === typescript_1.SyntaxKind.PublicKeyword ||
        modifier.kind === typescript_1.SyntaxKind.PrivateKeyword ||
        modifier.kind === typescript_1.SyntaxKind.ProtectedKeyword ||
        modifier.kind === typescript_1.SyntaxKind.ReadonlyKeyword) {
        return true;
    }
    return false;
}
exports.isParameterPropertyModifier = isParameterPropertyModifier;
function getClassProperties(classNode, propertySet) {
    if (!classNode || !classNode.members) {
        return;
    }
    if ((0, typescript_1.isStructDeclaration)(classNode)) {
        getStructProperties(classNode, exports.structPropsSet);
    }
    traverseMembersOfClass(classNode, propertySet);
    return;
}
exports.getClassProperties = getClassProperties;
function traverseMembersOfClass(classNode, propertySet) {
    classNode.members.forEach((member) => {
        if (!member) {
            return;
        }
        const memberName = member.name;
        if (memberName) {
            collectPropertyNamesAndStrings(memberName, propertySet);
        }
        if ((0, typescript_1.isConstructorDeclaration)(member) && member.parameters) {
            member.parameters.forEach((parameter) => {
                var _a;
                const modifiers = (0, typescript_1.getModifiers)(parameter);
                if ((0, typescript_1.isParameter)(parameter) && modifiers && modifiers.length > 0) {
                    if (parameter.name && (0, typescript_1.isIdentifier)(parameter.name)) {
                        let hasParameterPropertyModifier = modifiers.find(modifier => isParameterPropertyModifier(modifier)) !== undefined;
                        if (hasParameterPropertyModifier) {
                            propertySet.add(parameter.name.text);
                            (_a = ApiExtractor_1.ApiExtractor.mConstructorPropertySet) === null || _a === void 0 ? void 0 : _a.add(parameter.name.text);
                        }
                    }
                    processMemberInitializer(parameter.initializer, propertySet);
                }
            });
            if (member.body) {
                member.body.statements.forEach((statement) => {
                    if ((0, typescript_1.isExpressionStatement)(statement) && (0, typescript_1.isBinaryExpression)(statement.expression) &&
                        statement.expression.operatorToken.kind === typescript_1.SyntaxKind.EqualsToken) {
                        processMemberInitializer(statement.expression.right, propertySet);
                    }
                });
            }
        }
        if (!(0, typescript_1.isPropertyDeclaration)(member) || !member.initializer) {
            return;
        }
        processMemberInitializer(member.initializer, propertySet);
    });
    return;
}
function processMemberInitializer(memberInitializer, propertySet) {
    if (!memberInitializer) {
        return;
    }
    if ((0, typescript_1.isObjectLiteralExpression)(memberInitializer)) {
        getObjectProperties(memberInitializer, propertySet);
        return;
    }
    if ((0, typescript_1.isClassDeclaration)(memberInitializer) || (0, typescript_1.isClassExpression)(memberInitializer) || (0, typescript_1.isStructDeclaration)(memberInitializer)) {
        getClassProperties(memberInitializer, propertySet);
        return;
    }
    if ((0, typescript_1.isEnumDeclaration)(memberInitializer)) {
        getEnumProperties(memberInitializer, propertySet);
        return;
    }
}
function getEnumProperties(enumNode, propertySet) {
    if (!enumNode || !enumNode.members) {
        return;
    }
    enumNode.members.forEach((member) => {
        if (!member || !member.name) {
            return;
        }
        const memberName = member.name;
        collectPropertyNamesAndStrings(memberName, propertySet);
        //other kind ignore
    });
    return;
}
exports.getEnumProperties = getEnumProperties;
function getObjectProperties(objNode, propertySet) {
    if (!objNode || !objNode.properties) {
        return;
    }
    objNode.properties.forEach((propertyElement) => {
        if (!propertyElement || !propertyElement.name) {
            return;
        }
        const propertyName = propertyElement.name;
        collectPropertyNamesAndStrings(propertyName, propertySet);
        //extract class element's property, example: export const hello = {info={read: {}}}
        if (!(0, typescript_1.isPropertyAssignment)(propertyElement) || !propertyElement.initializer) {
            return;
        }
        if ((0, typescript_1.isObjectLiteralExpression)(propertyElement.initializer)) {
            getObjectProperties(propertyElement.initializer, propertySet);
            return;
        }
        if ((0, typescript_1.isClassDeclaration)(propertyElement.initializer)) {
            getClassProperties(propertyElement.initializer, propertySet);
            return;
        }
        if ((0, typescript_1.isEnumDeclaration)(propertyElement.initializer)) {
            getEnumProperties(propertyElement.initializer, propertySet);
            return;
        }
    });
    return;
}
exports.getObjectProperties = getObjectProperties;
function getStructProperties(structNode, propertySet) {
    var _a;
    (_a = structNode === null || structNode === void 0 ? void 0 : structNode.members) === null || _a === void 0 ? void 0 : _a.forEach((member) => {
        const memberName = member === null || member === void 0 ? void 0 : member.name;
        if (!memberName) {
            return;
        }
        collectPropertyNamesAndStrings(memberName, propertySet);
    });
}
exports.getStructProperties = getStructProperties;
/**
 * collect elements into export whitelist for module.exports = {A, B, C, D}
 * since these elements can be import by `const {A, B, C, D} = require("./filePath");`
 */
function getObjectExportNames(objNode, exportNames) {
    if (!objNode || !objNode.properties) {
        return;
    }
    objNode.properties.forEach((propertyElement) => {
        if ((0, typescript_1.isPropertyAssignment)(propertyElement)) {
            /**
             * { prop1: 123 } // collect prop1
             * { 'prop2': 123 } // collect prop2
             * { ['prop3']: 123 } // collect prop3
             */
            addExportPropertyName(propertyElement, exportNames);
            let initializer = propertyElement.initializer;
            if ((0, typescript_1.isIdentifier)(initializer)) {
                /**
                 * { prop: testObj } // collect testObj into exportOriginalNameSet so that its properties can be collected
                 */
                exports.exportOriginalNameSet.add(initializer.text);
            }
            return;
        }
        if ((0, typescript_1.isShorthandPropertyAssignment)(propertyElement)) {
            /**
             * let shorthandNode = {prop1: 123};
             * module.exports = { shorthandNode } // collect shorthandNode
             */
            exportNames.add(propertyElement.name.text);
            return;
        }
        if ((0, typescript_1.isMethodDeclaration)(propertyElement) || (0, typescript_1.isGetAccessor)(propertyElement) || (0, typescript_1.isSetAccessor)(propertyElement)) {
            /**
             * { method() {} } // collect method
             * { 'method'() {} } // collect method
             * { ['method']() {} } // collect method
             * { get getProp() {} } // collect getProp
             * { get 'getProp'() {} } // collect getProp
             * { get ['getProp']() {}} // collect getProp
             */
            addExportPropertyName(propertyElement, exportNames);
            return;
        }
    });
    return;
}
exports.getObjectExportNames = getObjectExportNames;
/**
 * Collect property names in ObjectLiteralExpression
 */
function addExportPropertyName(propertyElement, exportNames) {
    let nameNode = propertyElement.name;
    if ((0, typescript_1.isIdentifier)(nameNode) || (0, typescript_1.isStringLiteral)(nameNode)) {
        exportNames.add(nameNode.text);
    }
    if ((0, typescript_1.isComputedPropertyName)(nameNode) && (0, typescript_1.isStringLiteral)(nameNode.expression)) {
        exportNames.add(nameNode.expression.text);
    }
}
exports.addExportPropertyName = addExportPropertyName;
/**
 * Collect reserved names in enum
 * e.g.
 * enum H {
 *   A,
 *   B = A + 1
 * }
 * A is reserved
 */
function visitEnumInitializer(childNode) {
    if (NodeUtils_1.NodeUtils.isPropertyNode(childNode)) {
        return;
    }
    if ((0, typescript_1.isTypeNode)(childNode)) {
        return;
    }
    if (!(0, typescript_1.isIdentifier)(childNode)) {
        (0, typescript_1.forEachChild)(childNode, visitEnumInitializer);
        return;
    }
    CommonCollections_1.UnobfuscationCollections.reservedEnum.add(childNode.text);
}
exports.visitEnumInitializer = visitEnumInitializer;
/**
 * collect properties of ViewPU class as reserved names
 */
function getViewPUClassProperties(classNode) {
    if (!classNode || !classNode.members) {
        return;
    }
    classNode.members.forEach((member) => {
        const memberName = member.name;
        if (!memberName) {
            return;
        }
        collectPropertyNamesAndStrings(memberName, CommonCollections_1.UnobfuscationCollections.reservedStruct);
    });
}
exports.getViewPUClassProperties = getViewPUClassProperties;
//# sourceMappingURL=OhsUtil.js.map