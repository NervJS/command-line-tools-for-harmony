import type { Identifier, Node, SourceFile, StructDeclaration, TransformationContext } from 'typescript';
import type { IOptions } from '../configs/IOptions';
export interface ReservedNameInfo {
    universalReservedArray: RegExp[];
    specificReservedArray: string[];
}
/**
 * collect exist identifier names in current source file
 * @param sourceFile
 */
export declare function collectExistNames(sourceFile: SourceFile): Set<string>;
type IdentifiersAndStructs = {
    shadowIdentifiers: Identifier[];
    shadowStructs: StructDeclaration[];
};
/**
 * collect exist identifiers in current source file
 * @param sourceFile
 * @param context
 */
export declare function collectIdentifiersAndStructs(sourceFile: SourceFile, context: TransformationContext): IdentifiersAndStructs;
export declare function isCommentedNode(node: Node, sourceFile: SourceFile): boolean;
export declare function isSuperCallStatement(node: Node): boolean;
/**
 * separate wildcards from specific items.
 */
export declare function separateUniversalReservedItem(originalArray: string[]): ReservedNameInfo;
/**
 * check if the item contains '*', '?'.
 */
export declare function containWildcards(item: string): boolean;
/**
 * Convert specific characters into regular expressions.
 */
export declare function wildcardTransformer(wildcard: string, isPath?: boolean): string;
/**
 * Determine whether the original name needs to be preserved.
 */
export declare function needToBeReserved(reservedSet: Set<string>, universalArray: RegExp[], originalName: string): boolean;
/**
 * Determine whether it can match the wildcard character in the array.
 */
export declare function isMatchWildcard(wildcardArray: RegExp[], item: string): boolean;
/**
 * Separate parts of an array that contain wildcard characters.
 */
export declare function handleReservedConfig(config: IOptions, optionName: string, reservedListName: string, universalLisName: string, enableRemove?: string): void;
export declare function isReservedLocalVariable(mangledName: string): boolean;
export declare function isReservedTopLevel(originalName: string): boolean;
export declare function isReservedProperty(originalName: string): boolean;
/**
 * Reasons for not being obfuscated.
 */
export declare enum WhitelistType {
    SDK = "sdk",
    LANG = "lang",
    CONF = "conf",
    STRUCT = "struct",
    EXPORT = "exported",
    STRPROP = "strProp",
    ENUM = "enum"
}
/**
 * If the property name is in the whitelist, record the reason for not being obfuscated.
 * @param nameWithScope: If both property obfuscation and top-level obfuscation or export obfuscation are enabled,
 * this interface is also used to record the reasons why the top-level names or export names were not obfuscated,
 * and the top-level names or export names include the scope.
 */
export declare function needToRecordProperty(originalName: string, recordMap?: Map<string, Set<string>>, nameWithScope?: string): boolean;
export declare function isInTopLevelWhitelist(originalName: string, recordMap: Map<string, Set<string>>, nameWithScope: string): boolean;
export declare function isInPropertyWhitelist(originalName: string, recordMap: Map<string, Set<string>>): boolean;
export declare function isInLocalWhitelist(originalName: string, recordMap: Map<string, Set<string>>, nameWithScope: string): boolean;
export declare function recordReservedName(originalName: string, type: string, recordObj?: Map<string, Set<string>>): void;
export declare function recordHistoryUnobfuscatedNames(nameWithScope: string): void;
export {};
